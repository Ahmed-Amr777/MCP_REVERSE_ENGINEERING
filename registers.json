[
  {
    "start_page": 51,
    "end_page": 52,
    "page_range": "51-52",
    "section": "3.4.1",
    "full_name": "Data register (CRC_DR)",
    "short_name": "CRC_DR",
    "address_offset": "0x00",
    "reset_value": "0xFFFF FFFF",
    "content": "DR [31:16]\nDR [15:0]\nBits 31:0Data register bits\nUsed as an input register when writing new data into the CRC calculator.\nHolds the previous CRC calculation result when it is read.\nCRC calculation unitRM0008\n52/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 52,
    "end_page": 52,
    "page_range": "52",
    "section": "3.4.2",
    "full_name": "Independent data register (CRC_IDR)",
    "short_name": "CRC_IDR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 52,
    "end_page": 52,
    "page_range": "52",
    "section": "3.4.3",
    "full_name": "Control register (CRC_CR)",
    "short_name": "CRC_CR",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 62,
    "end_page": 64,
    "page_range": "62-64",
    "section": "4.4.1",
    "full_name": "Power control register (PWR_CR)",
    "short_name": "PWR_CR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:9Reserved, always read as 0.\nRM0008Power control (PWR)\nDoc ID 13902 Rev 963/995\nBit 8DBP: Disable backup domain write protection.\nIn reset state, the RTC and backup registers are protected against parasitic write access.\nThis bit must be set to enable write access to these registers.\n0: Access to RTC and Backup registers disabled\n1: Access to RTC and Backup registers enabled\nNote:If the HSE divided by 128 is used as the RTC clock, this bit must remain set to 1.\nBits 7:5PLS[2:0]: PVD level selection.\nThese bits are written by software to select the voltage threshold detected by the Power\nVoltage Detector\n000: 2.2V\n001: 2.3V\n010: 2.4V\n011: 2.5V\n100: 2.6V\n101: 2.7V\n110: 2.8V\n111: 2.9V\nNote:Refer to the electrical characteristics of the datasheet for more details.\nBit 4PVDE: Power voltage detector enable.\nThis bit is set and cleared by software.\n0: PVD disabled\n1: PVD enabled\nBit 3CSBF: Clear standby flag.\nThis bit is always read as 0.\n0: No effect\n1: Clear the SBF Standby Flag (write).\nBit 2CWUF: Clear wakeup flag.\nThis bit is always read as 0.\n0: No effect\n1: Clear the WUF Wakeup Flag after 2 System clock cycles. (write)\nBit 1PDDS: Power down deepsleep.\nThis bit is set and cleared by software. It works together with the LPDS bit.\n0: Enter Stop mode when the CPU enters Deepsleep. The regulator status depends on the\nLPDS bit.\n1: Enter Standby mode when the CPU enters Deepsleep.\nBit 0LPDS: Low-power deepsleep.\nThis bit is set and cleared by software. It works together with the PDDS bit.\n0: Voltage regulator on during Stop mode\n1: Voltage regulator in low-power mode during Stop mode\nPower control (PWR)RM0008\n64/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 64,
    "end_page": 65,
    "page_range": "64-65",
    "section": "4.4.2",
    "full_name": "Power control/status register (PWR_CSR)",
    "short_name": "PWR_CSR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Additional APB cycles are needed to read this register versus a standard APB read.\nBits 31:9Reserved, always read as 0.\nBit 8EWUP: Enable WKUP pin\nThis bit is set and cleared by software.\n0: WKUP pin is used for general purpose I/O. An event on the WKUP pin does not wakeup\nthe device from Standby mode.\n1: WKUP pin is used for wakeup from Standby mode and forced in input pull down\nconfiguration (rising edge on WKUP pin wakes-up the system from Standby mode).\nNote:This bit is reset by a system Reset.\nBits 7:3Reserved, always read as 0.\nBit 2PVDO: PVD output\nThis bit is set and cleared by hardware. It is valid only if PVD is enabled by the PVDE bit.\n0: V\nis higher than the PVD threshold selected with the PLS[2:0] bits.\n1: V\nis lower than the PVD threshold selected with the PLS[2:0] bits.\nNote:The PVD is stopped by Standby mode. For this reason, this bit is equal to 0 after\nStandby or reset until the PVDE bit is set.\nBit 1SBF: Standby flag\nThis bit is set by hardware and cleared only by a POR/PDR (power on reset/power down reset)\nor by setting the CSBF bit in the Power control register (PWR_CR)\n0: Device has not been in Standby mode\n1: Device has been in Standby mode\nBit 0WUF: Wakeup flag\nThis bit is set by hardware and cleared only by a POR/PDR (power on reset/power down\nreset) or by setting the CWUF bit in the Power control register (PWR_CR)\n0: No wakeup event occurred\n1: A wakeup event was received from the WKUP pin or from the RTC alarm\nNote:An additional wakeup event is detected if the WKUP pin is enabled (by setting the\nEWUP bit) when the WKUP pin level is already high.\nRM0008Power control (PWR)\nDoc ID 13902 Rev 965/995"
  },
  {
    "start_page": 68,
    "end_page": 68,
    "page_range": "68",
    "section": "5.4.1",
    "full_name": "Backup data register x (BKP_DRx) (x = 1 ..42)",
    "short_name": "",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 68,
    "end_page": 69,
    "page_range": "68-69",
    "section": "5.4.2",
    "full_name": "RTC clock calibration register (BKP_RTCCR)",
    "short_name": "BKP_RTCCR",
    "address_offset": "0x2C",
    "reset_value": "0x0000 0000",
    "content": "Bits 15:0D[15:0] Backup data\nThese bits can be written with user data.\nNote:The BKP_DRx registers are not reset by a System reset or Power reset or when the\ndevice wakes up from Standby mode.\nThey are reset by a Backup Domain reset or by a TAMPER pin event (if the TAMPER\npin function is activated).\nBits 15:10Reserved, always read as 0.\nBit 9ASOS: Alarm or second output selection\nWhen the ASOE bit is set, the ASOS bit can be used to select whether the signal output on\nthe TAMPER pin is the RTC Second pulse signal or the Alarm pulse signal:\n0: RTC Alarm pulse output selected\n1: RTC Second pulse output selected\nNote:This bit is reset only by a Backup domain reset.\nBit 8ASOE: Alarm or second output enable\nSetting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the\nTAMPER pin depending on the ASOS bit.\nThe output pulse duration is one RTC clock period. The TAMPER pin must not be enabled\nwhile the ASOE bit is set.\nNote:This bit is reset only by a Backup domain reset.\nBit 7CCO: Calibration clock output\n0: No effect\n1: Setting this bit outputs the RTC clock with a frequency divided by 64 on the TAMPER pin.\nThe TAMPER pin must not be enabled while the CCO bit is set in order to avoid unwanted\nTamper detection.\nNote:This bit is reset when the V\nsupply is powered off.\nRM0008Backup registers (BKP)\nDoc ID 13902 Rev 969/995"
  },
  {
    "start_page": 69,
    "end_page": 69,
    "page_range": "69",
    "section": "5.4.3",
    "full_name": "Backup control register (BKP_CR)",
    "short_name": "BKP_CR",
    "address_offset": "0x30",
    "reset_value": "0x0000 0000",
    "content": "Note:Setting the TPAL and TPE bits at the same time is always safe, however resetting both at\nthe same time can generate a spurious Tamper event. For this reason it is recommended to\nchange the TPAL bit only when the TPE bit is reset."
  },
  {
    "start_page": 69,
    "end_page": 70,
    "page_range": "69-70",
    "section": "5.4.4",
    "full_name": "Backup control/status register (BKP_CSR)",
    "short_name": "BKP_CSR",
    "address_offset": "0x34",
    "reset_value": "0x0000 0000",
    "content": "Bit 6:0CAL[6:0]: Calibration value\nThis value indicates the number of clock pulses that will be ignored every 2^20 clock pulses.\nThis allows the calibration of the RTC, slowing down the clock by steps of 1000000/2^20\nThe clock of the RTC can be slowed down from 0 to 121PPM.\nBits 15:2Reserved, always read as 0.\nBit 1TPAL: TAMPER pin active level\n0: A high level on the TAMPER pin resets all data backup registers (if TPE bit is set).\n1: A low level on the TAMPER pin resets all data backup registers (if TPE bit is set).\nBit 0TPE: TAMPER pin enable\n0: The TAMPER pin is free for general purpose I/O\n1: Tamper alternate I/O function is activated.\nBits 15:10Reserved, always read as 0.\nBit 9TIF: Tamper interrupt flag\nThis bit is set by hardware when a Tamper event is detected and the TPIE bit is set. It is\ncleared by writing 1 to the CTI bit (also clears the interrupt). It is also cleared if the TPIE bit\nis reset.\n0: No Tamper interrupt\n1: A Tamper interrupt occurred\nNote:This bit is reset only by a system reset and wakeup from Standby mode.\nBackup registers (BKP)RM0008\n70/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 83,
    "end_page": 84,
    "page_range": "83-84",
    "section": "6.3.1",
    "full_name": "Clock control register (RCC_CR)",
    "short_name": "RCC_CR",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 31:26Reserved, always read as 0.\nBit 25PLLRDY: PLL clock ready flag\nSet by hardware to indicate that the PLL is locked.\n0: PLL unlocked\n1: PLL locked\nBit 24PLLON: PLL enable\nSet and cleared by software to enable PLL.\nCleared by hardware when entering Stop or Standby mode. This bit can not be reset if the\nPLL clock is used as system clock or is selected to become the system clock.\n0: PLL OFF\n1: PLL ON\nBits 23:20Reserved, always read as 0.\nBit 19CSSON: Clock security system enable\nSet and cleared by software to enable clock detector.\n0: Clock detector OFF\n1: Clock detector ON if external 4-25 MHz oscillator is ready.\nBit 18HSEBYP: External high-speed clock bypass\nSet and cleared by software in debug for bypassing the oscillator with an external clock. This\nbit can be written only if the external 4-25 MHz oscillator is disabled.\n0: external 4-25 MHz oscillator not bypassed\n1: external 4-25 MHz oscillator bypassed with external clock\nBit 17HSERDY: External high-speed clock ready flag\nSet by hardware to indicate that the external 4-25 MHz oscillator is stable. This bit needs 6\ncycles of external 4-25 MHz oscillator clock to fall down after HSEON reset.\n0: external 4-25 MHz oscillator not ready\n1: external 4-25 MHz oscillator ready\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n84/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 84,
    "end_page": 87,
    "page_range": "84-87",
    "section": "6.3.2",
    "full_name": "Clock configuration register (RCC_CFGR)",
    "short_name": "RCC_CFGR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Access: 0  wait state  2, word, half-word and byte access\n1 or 2 wait states inserted only if the access occurs during clock source switch.\nBit 16HSEON: External high-speed clock enable\nSet and cleared by software.\nCleared by hardware to stop the external 1-25MHz oscillator when entering in Stop or\nStandby mode. This bit cannot be reset if the external 4-25 MHz oscillator is used directly or\nindirectly as the system clock or is selected to become the system clock.\n0: HSE oscillator OFF\n1: HSE oscillator ON\nBits 15:8HSICAL[7:0]: Internal high-speed clock calibration\nThese bits are initialized automatically at startup.\nBits 7:3HSITRIM[4:0]: Internal high-speed clock trimming\nThese bits provide an additional user-programmable trimming value that is added to the\nHSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature\nthat influence the frequency of the internal HSI RC.\nThe default value is 16, which, when added to the HSICAL value, should trim the HSI to 8\nMHz ± 1%. The trimming step (F\n) is around 40 kHz between two consecutive HSICAL\nBit 2Reserved, always read as 0.\nBit 1HSIRDY: Internal high-speed clock ready flag\nSet by hardware to indicate that internal 8 MHz RC oscillator is stable. After the HSION bit is\ncleared, HSIRDY goes low after 6 internal 8 MHz RC oscillator clock cycles.\n0: internal 8 MHz RC oscillator not ready\n1: internal 8 MHz RC oscillator ready\nBit 0HSION: Internal high-speed clock enable\nSet and cleared by software.\nSet by hardware to force the internal 8 MHz RC oscillator ON when leaving Stop or Standby\nmode or in case of failure of the external 4-25 MHz oscillator used directly or indirectly as\nsystem clock. This bit cannot be reset if the internal 8 MHz RC is used directly or indirectly\nas system clock or is selected to become the system clock.\n0: internal 8 MHz RC oscillator OFF\n1: internal 8 MHz RC oscillator ON\nADC PRE[1:0]PPRE2[2:0]PPRE1[2:0]HPRE[3:0]SWS[1:0]SW[1:0]\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 985/995\nBits 31:27Reserved, always read as 0.\nBits 26:24MCO: Microcontroller clock output\nSet and cleared by software.\n0xx: No clock\n100: System clock (SYSCLK) selected\n101: HSI clock selected\n110: HSE clock selected\n111: PLL clock divided by 2 selected\nNote:This clock output may have some truncated cycles at startup or during MCO clock\nsource switching.\nWhen the System Clock is selected to output to the MCO pin, make sure that this clock\ndoes not exceed 50 MHz (the maximum I/O speed).\nBit 22USBPRE: USB prescaler\nSet and cleared by software to generate 48 MHz USB clock. This bit must be valid before\nenabling the USB clock in the RCC_APB1ENR register. This bit can’t be reset if the USB\nclock is enabled.\n0: PLL clock is divided by 1.5\n1: PLL clock is not divided\nBits 21:18PLLMUL: PLL multiplication factor\nThese bits are written by software to define the PLL multiplication factor. These bits can be\nwritten only when PLL is disabled.\nCaution: The PLL output frequency must not exceed 72 MHz.\n0000: PLL input clock x 2\n0001: PLL input clock x 3\n0010: PLL input clock x 4\n0011: PLL input clock x 5\n0100: PLL input clock x 6\n0101: PLL input clock x 7\n0110: PLL input clock x 8\n0111: PLL input clock x 9\n1000: PLL input clock x 10\n1001: PLL input clock x 11\n1010: PLL input clock x 12\n1011: PLL input clock x 13\n1100: PLL input clock x 14\n1101: PLL input clock x 15\n1110: PLL input clock x 16\n1111: PLL input clock x 16\nBit 17PLLXTPRE: HSE divider for PLL entry\nSet and cleared by software to divide HSE before PLL entry. This bit can be written only\nwhen PLL is disabled.\n0: HSE clock not divided\n1: HSE clock divided by 2\nBit 16PLLSRC: PLL entry clock source\nSet and cleared by software to select PLL clock source. This bit can be written only when\nPLL is disabled.\n0: HSI oscillator clock / 2 selected as PLL input clock\n1: HSE oscillator clock selected as PLL input clock\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n86/995 Doc ID 13902 Rev 9\nBits 14:14ADCPRE: ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADCs.\n00: PLCK2 divided by 2\n01: PLCK2 divided by 4\n10: PLCK2 divided by 6\n11: PLCK2 divided by 8\nBits 13:11PPRE2: APB high-speed prescaler (APB2)\nSet and cleared by software to control the division factor of the APB high-speed clock\n0xx: HCLK not divided\n100: HCLK divided by 2\n101: HCLK divided by 4\n110: HCLK divided by 8\n111: HCLK divided by 16\nBits 10:8PPRE1: APB low-speed prescaler (APB1)\nSet and cleared by software to control the division factor of the APB low-speed clock\nWarning: the software has to set correctly these bits to not exceed 36 MHz on this domain.\n0xx: HCLK not divided\n100: HCLK divided by 2\n101: HCLK divided by 4\n110: HCLK divided by 8\n111: HCLK divided by 16\nBits 7:4HPRE: AHB prescaler\nSet and cleared by software to control the division factor of the AHB clock.\n0xxx: SYSCLK not divided\n1000: SYSCLK divided by 2\n1001: SYSCLK divided by 4\n1010: SYSCLK divided by 8\n1011: SYSCLK divided by 16\n1100: SYSCLK divided by 64\n1101: SYSCLK divided by 128\n1110: SYSCLK divided by 256\n1111: SYSCLK divided by 512\nNote:The prefetch buffer must be kept on when using a prescaler different from 1 on the\nAHB clock. Refer to Reading the Flash memory on page47 section for more details.\nBits 3:2SWS: System clock switch status\nSet and cleared by hardware to indicate which clock source is used as system clock.\n00: HSI oscillator used as system clock\n01: HSE oscillator used as system clock\n10: PLL used as system clock\n11: not applicable\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 987/995"
  },
  {
    "start_page": 87,
    "end_page": 89,
    "page_range": "87-89",
    "section": "6.3.3",
    "full_name": "Clock interrupt register (RCC_CIR)",
    "short_name": "RCC_CIR",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 1:0SW: System clock switch\nSet and cleared by software to select SYSCLK source.\nSet by hardware to force HSI selection when leaving Stop and Standby mode or in case of\nfailure of the HSE oscillator used directly or indirectly as system clock (if the Clock Security\nSystem is enabled).\n00: HSI selected as system clock\n01: HSE selected as system clock\n10: PLL selected as system clock\n11: not allowed\nBits 31:24Reserved, always read as 0.\nBit 23CSSC: Clock security system interrupt clear\nThis bit is set by software to clear the CSSF flag.\n0: No effect\n1: Clear CSSF flag\nBits 22:21Reserved, always read as 0.\nBit 20PLLRDYC: PLL ready interrupt clear\nThis bit is set by software to clear the PLLRDYF flag.\n0: No effect\n1: PLLRDYF cleared\nBit 19HSERDYC: HSE ready interrupt clear\nThis bit is set by software to clear the HSERDYF flag.\n0: No effect\n1: HSERDYF cleared\nBit 18HSIRDYC: HSI ready interrupt clear\nThis bit is set software to clear the HSIRDYF flag.\n0: No effect\n1: HSIRDYF cleared\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n88/995 Doc ID 13902 Rev 9\nBit 17LSERDYC: LSE ready interrupt clear\nThis bit is set by software to clear the LSERDYF flag.\n0: No effect\n1: LSERDYF cleared\nBit 16LSIRDYC: LSI ready interrupt clear\nThis bit is set by software to clear the LSIRDYF flag.\n0: No effect\n1: LSIRDYF cleared\nBits 15:13Reserved, always read as 0.\nBit 12PLLRDYIE: PLL ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by PLL lock.\n0: PLL lock interrupt disabled\n1: PLL lock interrupt enabled\nBit 11HSERDYIE: HSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the external 4-25 MHz\noscillator stabilization.\n0: HSE ready interrupt disabled\n1: HSE ready interrupt enabled\nBit 10HSIRDYIE: HSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the internal 8 MHz RC\noscillator stabilization.\n0: HSI ready interrupt disabled\n1: HSI ready interrupt enabled\nBit 9LSERDYIE: LSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the external 32 kHz\noscillator stabilization.\n0: LSE ready interrupt disabled\n1: LSE ready interrupt enabled\nBit 8LSIRDYIE: LSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by internal RC 40 kHz\noscillator stabilization.\n0: LSI ready interrupt disabled\n1: LSI ready interrupt enabled\nBit 7CSSF: Clock security system interrupt flag\nSet by hardware when a failure is detected in the external 4-25 MHz oscillator.\nCleared by software setting the CSSC bit.\n0: No clock security interrupt caused by HSE clock failure\n1: Clock security interrupt caused by HSE clock failure\nBits 6:5Reserved, always read as 0.\nBit 4PLLRDYF: PLL ready interrupt flag\nSet by hardware when the PLL locks and PLLRDYDIE is set.\nCleared by software setting the PLLRDYC bit.\n0: No clock ready interrupt caused by PLL lock\n1: Clock ready interrupt caused by PLL lock\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 989/995"
  },
  {
    "start_page": 89,
    "end_page": 91,
    "page_range": "89-91",
    "section": "6.3.4",
    "full_name": "APB2 peripheral reset register (RCC_APB2RSTR)",
    "short_name": "RCC_APB2RSTR",
    "address_offset": "0x0C",
    "reset_value": "0x00000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBit3HSERDYF: HSE ready interrupt flag\nSet by hardware when External Low Speed clock becomes stable and HSERDYDIE is set.\nCleared by software setting the HSERDYC bit.\n0: No clock ready interrupt caused by the external 4-25 MHz oscillator\n1: Clock ready interrupt caused by the external 4-25 MHz oscillator\nBit 2HSIRDYF: HSI ready interrupt flag\nSet by hardware when the Internal High Speed clock becomes stable and HSIRDYDIE is\nCleared by software setting the HSIRDYC bit.\n0: No clock ready interrupt caused by the internal 8 MHz RC oscillator\n1: Clock ready interrupt caused by the internal 8 MHz RC oscillator\nBit 1LSERDYF: LSE ready interrupt flag\nSet by hardware when the External Low Speed clock becomes stable and LSERDYDIE is\nCleared by software setting the LSERDYC bit.\n0: No clock ready interrupt caused by the external 32 kHz oscillator\n1: Clock ready interrupt caused by the external 32 kHz oscillator\nBit 0LSIRDYF: LSI ready interrupt flag\nSet by hardware when the internal low speed clock becomes stable and LSIRDYDIE is set.\nCleared by software setting the LSIRDYC bit.\n0: No clock ready interrupt caused by the internal RC 40 kHz oscillator\n1: Clock ready interrupt caused by the internal RC 40 kHz oscillator\nBits 31:16Reserved, always read as 0.\nBit 15ADC3RST: ADC3 interface reset\nSet and cleared by software.\n0: No effect\n1: Reset ADC3 interface\nBit 14USART1RST: USART1 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART1\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n90/995 Doc ID 13902 Rev 9\nBit 13TIM8RST: TIM8 timer reset\nSet and cleared by software.\n0: No effect\n1: Reset TIM8 timer\nBit 12SPI1RST: SPI 1 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI 1\nBit 11TIM1RST: TIM1 timer reset\nSet and cleared by software.\n0: No effect\n1: Reset TIM1 timer\nBit 10ADC2RST: ADC 2 interface reset\nSet and cleared by software.\n0: No effect\n1: Reset ADC 2 interface\nBit 9ADC1RST: ADC 1 interface reset\nSet and cleared by software.\n0: No effect\n1: Reset ADC 1 interface\nBit 8IOPGRST: IO port G reset\nSet and cleared by software.\n0: No effect\n1: Reset IO port G\nBit 7IOPFRST: IO port F reset\nSet and cleared by software.\n0: No effect\n1: Reset IO port F\nBit 6IOPERST: IO port E reset\nSet and cleared by software.\n0: No effect\n1: Reset IO port E\nBit 5IOPDRST: IO port D reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port D\nBit 4IOPCRST: IO port C reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port C\nBit 3IOPBRST: IO port B reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port B\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 991/995"
  },
  {
    "start_page": 91,
    "end_page": 93,
    "page_range": "91-93",
    "section": "6.3.5",
    "full_name": "APB1 peripheral reset register (RCC_APB1RSTR)",
    "short_name": "RCC_APB1RSTR",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBit 2IOPARST: I/O port A reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port A\nBit 1Reserved, always read as 0.\nBit 0AFIORST: Alternate function I/O reset\nSet and cleared by software.\n0: No effect\n1: Reset Alternate Function\nBits 31:30Reserved, always read as 0.\nBit 29DACRST: DAC interface reset\nSet and cleared by software.\n0: No effect\n1: Reset DAC interface\nBit 28PWRRST: Power interface reset\nSet and cleared by software.\n0: No effect\n1: Reset power interface\nBit 27BKPRST: Backup interface reset\nSet and cleared by software.\n0: No effect\n1: Reset backup interface\nBit 26Reserved, always read as 0.\nBit 25CANRST: CAN reset\nSet and cleared by software.\n0: No effect\n1: Reset CAN\nBit 24Reserved, always read as 0.\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n92/995 Doc ID 13902 Rev 9\nBit 23USBRST: USB reset\nSet and cleared by software.\n0: No effect\n1: Reset USB\nBit 22 I2C2RST: I2C 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset I2C 2\nBit 21I2C1RST: I2C 1 reset\nSet and cleared by software.\n0: No effect\n1: Reset I2C 1\nBit 20UART5RST: USART 5 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 5\nBit 19UART4RST: USART 4 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 4\nBit 18USART3RST: USART 3 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 3\nBit 17USART2RST: USART 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 2\nBits 16Reserved, always read as 0.\nBit 15SPI3RST: SPI 3 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI 3\nBit 14SPI2RST: SPI 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI 2\nBits 13:12Reserved, always read as 0.\nBit 11WWDGRST: Window watchdog reset\nSet and cleared by software.\n0: No effect\n1: Reset window watchdog\nBits 10:6Reserved, always read as 0.\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 993/995"
  },
  {
    "start_page": 93,
    "end_page": 95,
    "page_range": "93-95",
    "section": "6.3.6",
    "full_name": "AHB peripheral clock enable register (RCC_AHBENR)",
    "short_name": "RCC_AHBENR",
    "address_offset": "0x14",
    "reset_value": "0x0000 0014",
    "content": "Access: no wait state, word, half-word and byte access\nNote:When the peripheral clock is not active, the peripheral register values may not be readable\nby software and the returned value is always 0x0.\nBit 5TIM7RST: Timer 7 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 7\nBit 4TIM6RST: Timer 6 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 6\nBit 3TIM5RST: Timer 5 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 5\nBit 2TIM4RST: Timer 4 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 4\nBit 1TIM3RST: Timer 3 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 3\nBit 0TIM2RST: Timer 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 2\nBits 31:11Reserved, always read as 0.\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n94/995 Doc ID 13902 Rev 9\nBit 10SDIOEN: SDIO clock enable\nSet and cleared by software.\n0: SDIO clock disabled\n1: SDIO clock enabled\nBits 9Reserved, always read as 0.\nBit 8FSMCEN: FSMC clock enable\nSet and cleared by software.\n0: FSMC clock disabled\n1: FSMC clock enabled\nBit 7Reserved, always read as 0.\nBit 6CRCEN: CRC clock enable\nSet and cleared by software.\n0: CRC clock disabled\n1: CRC clock enabled\nBit 5Reserved, always read as 0.\nBit 4FLITFEN: FLITF clock enable\nSet and cleared by software to disable/enable FLITF clock during sleep mode.\n0: FLITF clock disabled during Sleep mode\n1: FLITF clock enabled during Sleep mode\nBit 3Reserved, always read as 0.\nBit 2SRAMEN: SRAM interface clock enable\nSet and cleared by software to disable/enable SRAM interface clock during Sleep mode.\n0: SRAM interface clock disabled during Sleep mode.\n1: SRAM interface clock enabled during Sleep mode\nBit 1DMA2EN: DMA2 clock enable\nSet and cleared by software.\n0: DMA2 clock disabled\n1: DMA2 clock enabled\nBit 0DMA1EN: DMA1 clock enable\nSet and cleared by software.\n0: DMA1 clock disabled\n1: DMA1 clock enabled\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 995/995"
  },
  {
    "start_page": 99,
    "end_page": 101,
    "page_range": "99-101",
    "section": "6.3.9",
    "full_name": "Backup domain control register (RCC_BDCR)",
    "short_name": "RCC_BDCR",
    "address_offset": "0x20",
    "reset_value": "0x0000 0000",
    "content": "Access: 0  wait state  3, word, half-word and byte access\nWait states are inserted in case of successive accesses to this register.\nNote:LSEON, LSEBYP, RTCSEL and RTCEN bits of the Backup domain control register\n(RCC_BDCR) are in the Backup domain. As a result, after Reset, these bits are write-\nprotected and the DBP bit in the Power control register (PWR_CR) has to be set before\nthese can be modified. Refer to Section5 on page 66 for further information. These bits are\nonly reset after a Backup domain Reset (see Section6.1.3: Backup domain reset). Any\ninternal or external Reset will not have any effect on these bits.\nBit 4TIM6EN: Timer 6 clock enable\nSet and cleared by software.\n0: Timer 6 clock disabled\n1: Timer 6 clock enabled\nBit 3TIM5EN: Timer 5 clock enable\nSet and cleared by software.\n0: Timer 5 clock disabled\n1: Timer 5 clock enabled\nBit 2TIM4EN: Timer 4 clock enable\nSet and cleared by software.\n0: Timer 4 clock disabled\n1: Timer 4 clock enabled\nBit 1TIM3EN: Timer 3 clock enable\nSet and cleared by software.\n0: Timer 3 clock disabled\n1: Timer 3 clock enabled\nBit 0TIM2EN: Timer 2 clock enable\nSet and cleared by software.\n0: Timer 2 clock disabled\n1: Timer 2 clock enabled\nBits 31:17Reserved, always read as 0.\nLow-, medium- and high-density reset and clock control (RCC)RM0008\n100/995 Doc ID 13902 Rev 9\nBit 16BDRST: Backup domain software reset\nSet and cleared by software.\n0: Reset not activated\n1: Resets the entire Backup domain\nBit 15RTCEN: RTC clock enable\nSet and cleared by software.\n0: RTC clock disabled\n1: RTC clock enabled\nBits 14:10Reserved, always read as 0.\nBits 9:8RTCSEL[1:0]: RTC clock source selection\nSet by software to select the clock source for the RTC. Once the RTC clock source has been\nselected, it cannot be changed anymore unless the Backup domain is reset. The BDRST bit\ncan be used to reset them.\n00: No clock\n01: LSE oscillator clock used as RTC clock\n10: LSI oscillator clock used as RTC clock\n11: HSE oscillator clock divided by 128 used as RTC clock\nBits 7:3Reserved, always read as 0.\nBit 2LSEBYP: External low-speed oscillator bypass\nSet and cleared by software to bypass oscillator in debug mode. This bit can be written only\nwhen the external 32 kHz oscillator is disabled.\n0: LSE oscillator not bypassed\n1: LSE oscillator bypassed\nBit 1LSERDY: External low-speed oscillator ready\nSet and cleared by hardware to indicate when the external 32 kHz oscillator is stable. After\nthe LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock\n0: External 32 kHz oscillator not ready\n1: External 32 kHz oscillator ready\nBit 0LSEON: External low-speed oscillator enable\nSet and cleared by software.\n0: External 32 kHz oscillator OFF\n1: External 32 kHz oscillator ON\nRM0008Low-, medium- and high-density reset and clock control (RCC)\nDoc ID 13902 Rev 9101/995"
  },
  {
    "start_page": 113,
    "end_page": 115,
    "page_range": "113-115",
    "section": "7.3.1",
    "full_name": "Clock control register (RCC_CR)",
    "short_name": "RCC_CR",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 31:30Reserved, always read as 0.\nBit 29PLL3RDY: PLL3 clock ready flag\nSet by hardware to indicate that the PLL3 is locked.\n0: PLL3 unlocked\n1: PLL3 locked\nConnectivity line devices: reset and clock control (RCC)RM0008\n114/995 Doc ID 13902 Rev 9\nBit 28PLL3ON: PLL3 enable\nSet and cleared by software to enable PLL3.\nCleared by hardware when entering Stop or Standby mode.\n0: PLL3 OFF\n1: PLL3 ON\nBit 27PLL2RDY: PLL2 clock ready flag\nSet by hardware to indicate that the PLL2 is locked.\n0: PLL2 unlocked\n1: PLL2 locked\nBit 26PLL2ON: PLL2 enable\nSet and cleared by software to enable PLL2.\nCleared by hardware when entering Stop or Standby mode. This bit can not be cleared if\nthe PLL2 clock is used indirectly as system clock (i.e. it is used as PLL clock entry that is\nused as system clock).\n0: PLL2 OFF\n1: PLL2 ON\nBit 25PLLRDY: PLL clock ready flag\nSet by hardware to indicate that the PLL is locked.\n0: PLL unlocked\n1: PLL locked\nBit 24PLLON: PLL enable\nSet and cleared by software to enable PLL.\nCleared by hardware when entering Stop or Standby mode. This bit can not be reset if the\nPLL clock is used as system clock or is selected to become the system clock. Software\nmust disable the USB OTG FS clock before clearing this bit.\n0: PLL OFF\n1: PLL ON\nBits 23:20Reserved, always read as 0.\nBit 19CSSON: Clock security system enable\nSet and cleared by software to enable clock detector.\n0: Clock detector OFF\n1: Clock detector ON if external 3-25 MHz oscillator is ready.\nBit 18HSEBYP: External high-speed clock bypass\nSet and cleared by software in debug for bypassing the oscillator with an external clock.\nThis bit can be written only if the external 3-25 MHz oscillator is disabled.\n0: external 3-25 MHz oscillator not bypassed\n1: external 3-25 MHz oscillator bypassed with external clock\nBit 17HSERDY: External high-speed clock ready flag\nSet by hardware to indicate that the external 3-25 MHz oscillator is stable. This bit needs 6\ncycles of external 3-25 MHz oscillator clock to fall down after HSEON reset.\n0: external 3-25 MHz oscillator not ready\n1: external 3-25 MHz oscillator ready\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9115/995"
  },
  {
    "start_page": 115,
    "end_page": 118,
    "page_range": "115-118",
    "section": "7.3.2",
    "full_name": "Clock configuration register (RCC_CFGR)",
    "short_name": "RCC_CFGR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Access: 0  wait state  2, word, half-word and byte access\n1 or 2 wait states inserted only if the access occurs during a clock source switch.\nBit 16HSEON: External high-speed clock enable\nSet and cleared by software.\nCleared by hardware to stop the external 3-25MHz oscillator when entering Stop or Standby\nmode. This bit can not be reset if the external 3-25 MHz oscillator is used directly or\nindirectly as system clock or is selected to become the system clock.\n0: HSE oscillator OFF\n1: HSE oscillator ON\nBits 15:8HSICAL[7:0]: Internal high-speed clock calibration\nThese bits are initialized automatically at startup.\nBits 7:3HSITRIM[4:0]: Internal high-speed clock trimming\nThese bits provide an additional user-programmable trimming value that is added to the\nHSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature\nthat influence the frequency of the internal HSI RC.\nThe default value is 16, which, when added to the HSICAL value, should trim the HSI to 8\nMHz ± 1%. The trimming step (F\n) is around 40 kHz between two consecutive HSICAL\nBit 2Reserved, always read as 0.\nBit 1HSIRDY: Internal high-speed clock ready flag\nSet by hardware to indicate that internal 8 MHz RC oscillator is stable. After the HSION bit is\ncleared, HSIRDY goes low after 6 internal 8 MHz RC oscillator clock cycles.\n0: Internal 8 MHz RC oscillator not ready\n1: Internal 8 MHz RC oscillator ready\nBit 0HSION: Internal high-speed clock enable\nSet and cleared by software.\nSet by hardware to force the internal 8 MHz RC oscillator ON when leaving Stop or Standby\nmode or in case of failure of the external 3-25 MHz oscillator used directly or indirectly as\nsystem clock. This bit can not be cleared if the internal 8 MHz RC is used directly or\nindirectly as system clock or is selected to become the system clock.\n0: Internal 8 MHz RC oscillator OFF\n1: Internal 8 MHz RC oscillator ON\nADC PRE[1:0]PPRE2[2:0]PPRE1[2:0]HPRE[3:0]SWS[1:0]SW[1:0]\nBits 31:27Reserved, always read as 0.\nConnectivity line devices: reset and clock control (RCC)RM0008\n116/995 Doc ID 13902 Rev 9\nBits 26:24MCO[3:0]: Microcontroller clock output\nSet and cleared by software.\n00xx: No clock\n0100: System clock (SYSCLK) selected\n0101: HSI clock selected\n0110: HSE clock selected\n0111: PLL clock divided by 2 selected\n1000: PLL2 clock selected\n1001: PLL3 clock divided by 2 selected\n1010: XT1 external 3-25 MHz oscillator clock selected (for Ethernet)\n1011: PLL3 clock selected (for Ethernet)\nNote:This clock output may have some truncated cycles at startup or during MCO clock source\nThe selected clock to output onto the MCO pin must not exceed 50 MHz (the maximum I/O\nBit 22OTGFSPRE: USB OTG FS prescaler\nSet and cleared by software to generate the 48 MHz USB OTG FS clock. This bit must be valid\nbefore enabling the OTG FS clock in the RCC_APB1ENR register. This bit can not be cleared if the\nOTG FS clock is enabled.\n0: PLL VCO clock is divided by 3\n1: PLL VCO clock is divided by 2\nBits 21:18PLLMUL[3:0]: PLL multiplication factor\nThese bits are written by software to define the PLL multiplication factor. They can be written only\nwhen PLL is disabled.\n000x: Reserved\n0010: PLL input clock x 4\n0011: PLL input clock x 5\n0100: PLL input clock x 6\n0101: PLL input clock x 7\n0110: PLL input clock x 8\n0111: PLL input clock x 9\n10xx: Reserved\n1100: Reserved\n1101: PLL input clock x 6.5\n111x: Reserved\nCaution:The PLL output frequency must not exceed 72 MHz.\nBit 17PLLXTPRE: LSB of division factor PREDIV1\nSet and cleared by software to select the least significant bit of the PREDIV1 division factor. It is the\nsame bit as bit(0) in the RCC_CFGR2 register, so modifying bit(0) in the RCC_CFGR2 register\nchanges this bit accordingly.\nIf bits[3:1] in register RCC_CFGR2 are not set, this bit controls if PREDIV1 divides its input clock by\n2 (PLLXTPRE=1) or not (PLLXTPRE=0).\nThis bit can be written only when PLL is disabled.\nBit 16PLLSRC: PLL entry clock source\nSet and cleared by software to select PLL clock source. This bit can be written only when PLL is\n0: HSI oscillator clock / 2 selected as PLL input clock\n1: Clock from PREDIV1 selected as PLL input clock\nNote:When changing the main PLL’s entry clock source, the original clock source must be switched\noff only after the selection of the new clock source.\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9117/995\nBits 14:14ADCPRE[1:0]: ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADCs.\n00: PLCK2 divided by 2\n01: PLCK2 divided by 4\n10: PLCK2 divided by 6\n11: PLCK2 divided by 8\nBits 13:11PPRE2[2:0]: APB high-speed prescaler (APB2)\nSet and cleared by software to control the division factor of the APB High speed clock (PCLK2).\n0xx: HCLK not divided\n100: HCLK divided by 2\n101: HCLK divided by 4\n110: HCLK divided by 8\n111: HCLK divided by 16\nBits 10:8PPRE1[2:0]: APB Low-speed prescaler (APB1)\nSet and cleared by software to control the division factor of the APB Low speed clock (PCLK1).\n0xx: HCLK not divided\n100: HCLK divided by 2\n101: HCLK divided by 4\n110: HCLK divided by 8\n111: HCLK divided by 16\nCaution:Software must configure these bits ensure that the frequency in this domain does not\nexceed 36 MHz.\nBits 7:4HPRE[3:0]: AHB prescaler\nSet and cleared by software to control AHB clock division factor.\n0xxx: SYSCLK not divided\n1000: SYSCLK divided by 2\n1001: SYSCLK divided by 4\n1010: SYSCLK divided by 8\n1011: SYSCLK divided by 16\n1100: SYSCLK divided by 64\n1101: SYSCLK divided by 128\n1110: SYSCLK divided by 256\n1111: SYSCLK divided by 512\nNote:The prefetch buffer must be kept on when using a prescaler different from 1 on the AHB clock.\nRefer to the section Reading the Flash memory on page47 for more details.\nBits 3:2SWS[1:0]: System clock switch status\nSet and cleared by hardware to indicate which clock source is used as system clock.\n00: HSI oscillator used as system clock\n01: HSE oscillator used as system clock\n10: PLL used as system clock\n11: Not applicable\nConnectivity line devices: reset and clock control (RCC)RM0008\n118/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 118,
    "end_page": 121,
    "page_range": "118-121",
    "section": "7.3.3",
    "full_name": "Clock interrupt register (RCC_CIR)",
    "short_name": "RCC_CIR",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 1:0SW[1:0]: System clock Switch\nSet and cleared by software to select SYSCLK source.\nSet by hardware to force HSI selection when leaving Stop and Standby mode or in case of failure of\nthe HSE oscillator used directly or indirectly as system clock (if the Clock Security System is\n00: HSI selected as system clock\n01: HSE selected as system clock\n10: PLL selected as system clock\n11: Not allowed\nBits 31:24Reserved, always read as 0.\nBit 23CSSC: Clock security system interrupt clear\nThis bit is set by software to clear the CSSF flag.\n0: No effect\n1: Clear CSSF flag\nBit 22PLL3RDYC: PLL3 Ready Interrupt Clear\nThis bit is set by software to clear the PLL3RDYF flag.\n0: No effect\n1: Clear PLL3RDYF flag\nBit 21PLL2RDYC: PLL2 Ready Interrupt Clear\nThis bit is set by software to clear the PLL2RDYF flag.\n0: No effect\n1: Clear PLL2RDYF flag\nBit 20PLLRDYC: PLL ready interrupt clear\nThis bit is set by software to clear the PLLRDYF flag.\n0: No effect\n1: Clear PLLRDYF flag\nBit 19HSERDYC: HSE ready interrupt clear\nThis bit is set by software to clear the HSERDYF flag.\n0: No effect\n1: Clear HSERDYF flag\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9119/995\nBit 18HSIRDYC: HSI ready interrupt clear\nThis bit is set by software to clear the HSIRDYF flag.\n0: No effect\n1: Clear HSIRDYF flag\nBit 17LSERDYC: LSE ready interrupt clear\nThis bit is set by software to clear the LSERDYF flag.\n0: No effect\n1: Clear LSERDYF flag\nBit 16LSIRDYC: LSI ready interrupt clear\nThis bit is set by software to clear the LSIRDYF flag.\n0: No effect\n1: Clear LSIRDYF flag\nBit 15Reserved, always read as 0.\nBit 14PLL3RDYIE: PLL3 Ready Interrupt Enable\nSet and cleared by software to enable/disable interrupt caused by PLL3 lock.\n0: PLL3 lock interrupt disabled\n1: PLL3 lock interrupt enabled\nBit 13PLL2RDYIE: PLL2 Ready Interrupt Enable\nSet and cleared by software to enable/disable interrupt caused by PLL2 lock.\n0: PLL2 lock interrupt disabled\n1: PLL2 lock interrupt enabled\nBit 12PLLRDYIE: PLL ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by PLL lock.\n0: PLL lock interrupt disabled\n1: PLL lock interrupt enabled\nBit 11HSERDYIE: HSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the external 3-25 MHz\noscillator stabilization.\n0: HSE ready interrupt disabled\n1: HSE ready interrupt enabled\nBit 10HSIRDYIE: HSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the internal 8 MHz RC\noscillator stabilization.\n0: HSI ready interrupt disabled\n1: HSI ready interrupt enabled\nBit 9LSERDYIE: LSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the external 32 kHz\noscillator stabilization.\n0: LSE ready interrupt disabled\n1: LSE ready interrupt enabled\nBit 8LSIRDYIE: LSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by internal RC 40 kHz\noscillator stabilization.\n0: LSI ready interrupt disabled\n1: LSI ready interrupt enabled\nConnectivity line devices: reset and clock control (RCC)RM0008\n120/995 Doc ID 13902 Rev 9\nBit 7CSSF: Clock security system interrupt flag\nSet by hardware when a failure is detected in the external 3-25 MHz oscillator. It is cleared\nby software setting the CSSC bit.\n0: No clock security interrupt caused by HSE clock failure\n1: Clock security interrupt caused by HSE clock failure\nBit 6PLL3RDYF: PLL3 Ready Interrupt flag\nSet by hardware when the PLL3 locks and PLL3RDYIE is set. It is cleared by software\nsetting the PLL3RDYC bit.\n0: No clock ready interrupt caused by PLL3 lock\n1: Clock ready interrupt caused by PLL3 lock\nBit 5PLL2RDYF: PLL2 Ready Interrupt flag\nSet by hardware when the PLL2 locks and PLL2RDYDIE is set. It is cleared by software\nsetting the PLL2RDYC bit.\n0: No clock ready interrupt caused by PLL2 lock\n1: Clock ready interrupt caused by PLL2 lock\nBit 4PLLRDYF: PLL ready interrupt flag\nSet by hardware when the PLL locks and PLLRDYDIE is set. It is cleared by software setting\nthe PLLRDYC bit.\n0: No clock ready interrupt caused by PLL lock\n1: Clock ready interrupt caused by PLL lock\nBit3HSERDYF: HSE ready interrupt flag\nSet by hardware when External Low Speed clock becomes stable and HSERDYIE is set. It\nis cleared by software setting the HSERDYC bit.\n0: No clock ready interrupt caused by the external 3-25 MHz oscillator\n1: Clock ready interrupt caused by the external 3-25 MHz oscillator\nBit 2HSIRDYF: HSI ready interrupt flag\nSet by hardware when the Internal High Speed clock becomes stable and HSIRDYIE is set.\nIt is cleared by software setting the HSIRDYC bit.\n0: No clock ready interrupt caused by the internal 8 MHz RC oscillator\n1: Clock ready interrupt caused by the internal 8 MHz RC oscillator\nBit 1LSERDYF: LSE ready interrupt flag\nSet by hardware when the External Low Speed clock becomes stable and LSERDYIE is set.\nIt is cleared by software setting the LSERDYC bit.\n0: No clock ready interrupt caused by the external 32 kHz oscillator\n1: Clock ready interrupt caused by the external 32 kHz oscillator\nBit 0LSIRDYF: LSI ready interrupt flag\nSet by hardware when Internal Low Speed clock becomes stable and LSIRDYIE is set. It is\ncleared by software setting the LSIRDYC bit.\n0: No clock ready interrupt caused by the internal RC 40 kHz oscillator\n1: Clock ready interrupt caused by the internal RC 40 kHz oscillator\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9121/995"
  },
  {
    "start_page": 121,
    "end_page": 122,
    "page_range": "121-122",
    "section": "7.3.4",
    "full_name": "APB2 peripheral reset register (RCC_APB2RSTR)",
    "short_name": "RCC_APB2RSTR",
    "address_offset": "0x0C",
    "reset_value": "0x00000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 31:15Reserved, always read as 0.\nBit 14USART1RST: USART1 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART1\nBit 13Reserved, always read as 0.\nBit 12SPI1RST: SPI 1 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI 1\nBit 11TIM1RST: TIM1 timer reset\nSet and cleared by software.\n0: No effect\n1: Reset TIM1 timer\nBit 10ADC2RST: ADC 2 interface reset\nSet and cleared by software.\n0: No effect\n1: Reset ADC 2 interface\nBit 9ADC1RST: ADC 1 interface reset\nSet and cleared by software.\n0: No effect\n1: Reset ADC 1 interface\nBits 8:7Reserved, always read as 0.\nBit 6IOPERST: I/O port E reset\nSet and cleared by software.\n0: No effect\n1: Reset I:O port E\nBit 5IOPDRST: I/O port D reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port D\nConnectivity line devices: reset and clock control (RCC)RM0008\n122/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 122,
    "end_page": 125,
    "page_range": "122-125",
    "section": "7.3.5",
    "full_name": "APB1 peripheral reset register (RCC_APB1RSTR)",
    "short_name": "RCC_APB1RSTR",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBit 4IOPCRST: IO port C reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port C\nBit 3IOPBRST: IO port B reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port B\nBit 2IOPARST: I/O port A reset\nSet and cleared by software.\n0: No effect\n1: Reset I/O port A\nBit 1Reserved, always read as 0.\nBit 0AFIORST: Alternate function I/O reset\nSet and cleared by software.\n0: No effect\n1: Reset Alternate Function\nBits 31:30Reserved, always read as 0.\nBit 29DACRST: DAC interface reset\nSet and cleared by software.\n0: No effect\n1: Reset DAC interface\nBit 28PWRRST: Power interface reset\nSet and cleared by software.\n0: No effect\n1: Reset power interface\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9123/995\nBit 27BKPRST: Backup interface reset\nSet and cleared by software.\n0: No effect\n1: Reset backup interface\nBit 26CAN2RST: CAN2 reset\nSet and cleared by software.\n0: No effect\n1: Reset CAN2\nBit 25CAN1RST: CAN1 reset\nSet and cleared by software.\n0: No effect\n1: Reset CAN1\nBits 24:23Reserved, always read as 0.\nBit 22 I2C2RST: I2C 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset I2C 2\nBit 21I2C1RST: I2C1 reset\nSet and cleared by software.\n0: No effect\n1: Reset I2C 1\nBit 20UART5RST: USART 5 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 5\nBit 19UART4RST: USART 4 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 4\nBit 18USART3RST: USART 3 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 3\nBit 17USART2RST: USART 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset USART 2\nBits 16Reserved, always read as 0.\nBit 15SPI3RST: SPI3 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI 3\nBit 14SPI2RST: SPI2 reset\nSet and cleared by software.\n0: No effect\n1: Reset SPI2\nConnectivity line devices: reset and clock control (RCC)RM0008\n124/995 Doc ID 13902 Rev 9\nBits 13:12Reserved, always read as 0.\nBit 11WWDGRST: Window watchdog reset\nSet and cleared by software.\n0: No effect\n1: Reset window watchdog\nBits 10:6Reserved, always read as 0.\nBit 5TIM7RST: Timer 7 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 7\nBit 4TIM6RST: Timer 6 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 6\nBit 3TIM5RST: Timer 5 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 5\nBit 2TIM4RST: Timer 4 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 4\nBit 1TIM3RST: Timer 3 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 3\nBit 0TIM2RST: Timer 2 reset\nSet and cleared by software.\n0: No effect\n1: Reset timer 2\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9125/995"
  },
  {
    "start_page": 125,
    "end_page": 126,
    "page_range": "125-126",
    "section": "7.3.6",
    "full_name": "AHB Peripheral Clock enable register (RCC_AHBENR)",
    "short_name": "RCC_AHBENR",
    "address_offset": "0x14",
    "reset_value": "0x0000 0014",
    "content": "Access: no wait state, word, half-word and byte access\nBits 31:17Reserved, always read as 0.\nBit 16ETHMACRXEN: Ethernet MAC RX clock enable\nSet and cleared by software.\n0: Ethernet MAC RX clock disabled\n1: Ethernet MAC RX clock enabled\nNote:In the RMII mode, if this clock is enabled, the RMII clock of the MAC is also enabled.\nBit 15ETHMACTXEN: Ethernet MAC TX clock enable\nSet and cleared by software.\n0: Ethernet MAC TX clock disabled\n1: Ethernet MAC TX clock enabled\nNote:In the RMII mode, if this clock is enabled, the RMII clock of the MAC is also enabled.\nBit 14ETHMACEN: Ethernet MAC clock enable\nSet and cleared by software. Selection of PHY interface (MII/RMII) must be done before\nenabling the MAC clock.\n0: Ethernet MAC clock disabled\n1: Ethernet MAC clock enabled\nBit 13Reserved, always read as 0.\nBit 12OTGFSEN: USB OTG FS clock enable\nSet and cleared by software.\n0: USB OTG FS clock disabled\n1: USB OTG FS clock enabled\nBits 11:7Reserved, always read as 0.\nBit 6CRCEN: CRC clock enable\nSet and cleared by software.\n0: CRC clock disabled\n1: CRC clock enabled\nBit 5Reserved, always read as 0.\nConnectivity line devices: reset and clock control (RCC)RM0008\n126/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 133,
    "end_page": 134,
    "page_range": "133-134",
    "section": "7.3.11",
    "full_name": "AHB peripheral clock reset register (RCC_AHBRSTR)",
    "short_name": "RCC_AHBRSTR",
    "address_offset": "0x28",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBit 24RMVF: Remove reset flag\nSet by software to clear the reset flags.\n0: No effect\n1: Clear the reset flags\nBits 23:2Reserved, always read as 0.\nBit 1LSIRDY: Internal low speed oscillator ready\nSet and cleared by hardware to indicate when the internal RC 40 kHz oscillator is stable.\nAfter the LSION bit is cleared, LSIRDY goes low after 3 internal 40 kHz RC oscillator clock\n0: Internal RC 40 kHz oscillator not ready\n1: Internal RC 40 kHz oscillator ready\nBit 0LSION: Internal low speed oscillator enable\nSet and cleared by software.\n0: Internal RC 40 kHz oscillator OFF\n1: Internal RC 40 kHz oscillator ON\nBits 31:15Reserved, always read as 0.\nBit 14ETHMACRST Ethernet MAC reset\nSet and cleared by software.\n0: No effect\n1: Reset ETHERNET MAC\nBit 13Reserved, always read as 0.\nBit 12OTGFSRST USB OTG FS reset\nSet and cleared by software.\n0: No effect\n1: Reset USB OTG FS\nBits 11:0Reserved, always read as 0.\nConnectivity line devices: reset and clock control (RCC)RM0008\n134/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 134,
    "end_page": 136,
    "page_range": "134-136",
    "section": "7.3.12",
    "full_name": "Clock configuration register2 (RCC_CFGR2)",
    "short_name": "RCC_CFGR2",
    "address_offset": "0x2C",
    "reset_value": "0x0000 0000",
    "content": "Access: no wait state, word, half-word and byte access\nBits 31:19Reserved, always read as 0.\nBit 18I2S3SRC: I2S3 clock source\nSet and cleared by software to select I2S3 clock source. This bit must be valid before\nenabling I2S3 clock.\n0: System clock (SYSCLK) selected as I2S3 clock entry\n1: PLL3 VCO clock selected as I2S3 clock entry\nBit 17I2S2SRC: I2S2 clock source\nSet and cleared by software to select I2S2 clock source. This bit must be valid before\nenabling I2S2 clock.\n0: System clock (SYSCLK) selected as I2S2 clock entry\n1: PLL3 VCO clock selected as I2S2 clock entry\nBit 16PREDIV1SRC: PREDIV1 entry clock source\nSet and cleared by software to select PREDIV1 clock source. This bit can be written only\nwhen PLL is disabled.\n0: HSE oscillator clock selected as PREDIV1 clock entry\n1: PLL2 selected as PREDIV1 clock entry\nBits 15:12PLL3MUL[3:0]: PLL3 Multiplication Factor\nSet and cleared by software to control PLL3 multiplication factor. These bits can be written\nonly when PLL3 is disabled.\n00xx: Reserved\n010x: Reserved\n0110: PLL3 clock entry x 8\n0111: PLL3 clock entry x 9\n1000: PLL3 clock entry x 10\n1001: PLL3 clock entry x 11\n1010: PLL3 clock entry x 12\n1011: PLL3 clock entry x 13\n1100: PLL3 clock entry x 14\n1101: Reserved\n1110: PLL3 clock entry x 16\n1111: PLL3 clock entry x 20\nRM0008Connectivity line devices: reset and clock control (RCC)\nDoc ID 13902 Rev 9135/995\nBits 11:8PLL2MUL[3:0]: PLL2 Multiplication Factor\nSet and cleared by software to control PLL2 multiplication factor. These bits can be written\nonly when PLL2 is disabled.\n00xx: Reserved\n010x: Reserved\n0110: PLL2 clock entry x 8\n0111: PLL2 clock entry x 9\n1000: PLL2 clock entry x 10\n1001: PLL2 clock entry x 11\n1010: PLL2 clock entry x 12\n1011: PLL2 clock entry x 13\n1100: PLL2 clock entry x 14\n1101: Reserved\n1110: PLL2 clock entry x 16\n1111: PLL2 clock entry x 20\nBits 7:4PREDIV2[3:0]: PREDIV2 division factor\nSet and cleared by software to select PREDIV2 division factor. These bits can be written only\nwhen both PLL2 and PLL3 are disabled.\n0000: PREDIV2 input clock not divided\n0001: PREDIV2 input clock divided by 2\n0010: PREDIV2 input clock divided by 3\n0011: PREDIV2 input clock divided by 4\n0100: PREDIV2 input clock divided by 5\n0101: PREDIV2 input clock divided by 6\n0110: PREDIV2 input clock divided by 7\n0111: PREDIV2 input clock divided by 8\n1000: PREDIV2 input clock divided by 9\n1001: PREDIV2 input clock divided by 10\n1010: PREDIV2 input clock divided by 11\n1011: PREDIV2 input clock divided by 12\n1100: PREDIV2 input clock divided by 13\n1101: PREDIV2 input clock divided by 14\n1110: PREDIV2 input clock divided by 15\n1111: PREDIV2 input clock divided by 16\nConnectivity line devices: reset and clock control (RCC)RM0008\n136/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 148,
    "end_page": 149,
    "page_range": "148-149",
    "section": "8.2.1",
    "full_name": "Port configuration register low (GPIOx_CRL) (x=A..G)",
    "short_name": "",
    "address_offset": "0x00",
    "reset_value": "0x4444 4444",
    "content": "Bits 31:30, 27:26,\n23:22, 19:18, 15:14,\n11:10, 7:6, 3:2\nCNFy[1:0]: Port x configuration bits (y= 0 .. 7)\nThese bits are written by software to configure the corresponding I/O port.\nRefer to Table17: Port bit configuration table on page140.\nIn input mode (MODE[1:0]=00):\n00: Analog input mode\n01: Floating input (reset state)\n10: Input with pull-up / pull-down\n11: Reserved\nIn output mode (MODE[1:0]\n00: General purpose output push-pull\n01: General purpose output Open-drain\n10: Alternate function output Push-pull\n11: Alternate function output Open-drain\nBits 29:28, 25:24,\n21:20, 17:16, 13:12,\n9:8, 5:4, 1:0\nMODEy[1:0]: Port x mode bits (y= 0 .. 7)\nThese bits are written by software to configure the corresponding I/O port.\nRefer to Table17: Port bit configuration table on page140.\n00: Input mode (reset state)\n01: Output mode, max speed 10 MHz.\n10: Output mode, max speed 2 MHz.\n11: Output mode, max speed 50 MHz.\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9149/995"
  },
  {
    "start_page": 149,
    "end_page": 149,
    "page_range": "149",
    "section": "8.2.2",
    "full_name": "Port configuration register high (GPIOx_CRH) (x=A..G)",
    "short_name": "",
    "address_offset": "0x04",
    "reset_value": "0x4444 4444",
    "content": ""
  },
  {
    "start_page": 149,
    "end_page": 150,
    "page_range": "149-150",
    "section": "8.2.3",
    "full_name": "Port input data register (GPIOx_IDR) (x=A..G)",
    "short_name": "",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": "Bits 31:30, 27:26,\n23:22, 19:18, 15:14,\n11:10, 7:6, 3:2\nCNFy[1:0]: Port x configuration bits (y= 8 .. 15)\nThese bits are written by software to configure the corresponding I/O port.\nRefer to Table17: Port bit configuration table on page140.\nIn input mode (MODE[1:0]=00):\n00: Analog input mode\n01: Floating input (reset state)\n10: Input with pull-up / pull-down\n11: Reserved\nIn output mode (MODE[1:0]\n00: General purpose output push-pull\n01: General purpose output Open-drain\n10: Alternate function output Push-pull\n11: Alternate function output Open-drain\nBits 29:28, 25:24,\n21:20, 17:16, 13:12,\n9:8, 5:4, 1:0\nMODEy[1:0]: Port x mode bits (y= 8 .. 15)\nThese bits are written by software to configure the corresponding I/O port.\nRefer to Table17: Port bit configuration table on page140.\n00: Input mode (reset state)\n01: Output mode, max speed 10 MHz.\n10: Output mode, max speed 2 MHz.\n11: Output mode, max speed 50 MHz.\nBits 31:16Reserved, always read as 0.\nBits 15:0IDRy[15:0]: Port input data (y= 0 .. 15)\nThese bits are read only and can be accessed in Word mode only. They contain the input\nvalue of the corresponding I/O port.\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n150/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 150,
    "end_page": 150,
    "page_range": "150",
    "section": "8.2.4",
    "full_name": "Port output data register (GPIOx_ODR) (x=A..G)",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 150,
    "end_page": 151,
    "page_range": "150-151",
    "section": "8.2.5",
    "full_name": "Port bit set/reset register (GPIOx_BSRR) (x=A..G)",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:16Reserved, always read as 0.\nBits 15:0ODRy[15:0]: Port output data (y= 0 .. 15)\nThese bits can be read and written by software and can be accessed in Word mode only.\nNote:For atomic bit set/reset, the ODR bits can be individually set and cleared by writing to\nthe GPIOx_BSRR register (x = A .. G).\nBits 31:16BRy: Port x Reset bit y (y= 0 .. 15)\nThese bits are write-only and can be accessed in Word mode only.\n0: No action on the corresponding ODRx bit\n1: Reset the corresponding ODRx bit\nNote:If both BSx and BRx are set, BSx has priority.\nBits 15:0BSy: Port x Set bit y (y= 0 .. 15)\nThese bits are write-only and can be accessed in Word mode only.\n0: No action on the corresponding ODRx bit\n1: Set the corresponding ODRx bit\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9151/995"
  },
  {
    "start_page": 151,
    "end_page": 151,
    "page_range": "151",
    "section": "8.2.6",
    "full_name": "Port bit reset register (GPIOx_BRR) (x=A..G)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 151,
    "end_page": 158,
    "page_range": "151-158",
    "section": "8.2.7",
    "full_name": "Port configuration lock register (GPIOx_LCKR) (x=A..G)",
    "short_name": "",
    "address_offset": "0x18",
    "reset_value": "0x0000 0000",
    "content": "This register is used to lock the configuration of the port bits when a correct write sequence\nis applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the\nGPIO. During the write sequence, the value of LCKR[15:0] must not change. When the\nLOCK sequence has been applied on a port bit it is no longer possible to modify the value of\nthe port bit until the next reset.\nEach lock bit freezes the corresponding 4 bits of the control register (CRL, CRH).\nBits 31:16Reserved\nBits 15:0BRy: Port x Reset bit y (y= 0 .. 15)\nThese bits are write-only and can be accessed in Word mode only.\n0: No action on the corresponding ODRx bit\n1: Reset the corresponding ODRx bit\nBits 31:17Reserved\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n152/995 Doc ID 13902 Rev 9\n8.3 Alternate function I/O and debug configuration (AFIO)\nTo optimize the number of peripherals available for the 64-pin or the 100-pin or the 144-pin\npackage, it is possible to remap some alternate functions to some other pins. This is\nachieved by software, by programming the AF remap and debug I/O configuration register\n(AFIO_MAPR) on page159. In this case, the alternate functions are no longer mapped to\ntheir original assignations.\n8.3.1 Using OSC32_IN/OSC32_OUT pins as GPIO ports PC14/PC15\nThe LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general-purpose I/O\nPC14 and PC15, respectively, when the LSE oscillator is off. The LSE has priority over the\nGP IOs function.\nNote:1The PC14/PC15 GPIO functionality is lost when the 1.8 V domain is powered off (by\nentering standby mode) or when the backup domain is supplied by V\nno more\nsupplied). In this case the IOs are set in analog input mode.\n2Refer to the note on IO usage restrictions in Section4.1.2 on page 54.\n8.3.2 Using OSC_IN/OSC_OUT pins as GPIO ports PD0/PD1\nThe HSE oscillator pins OSC_IN/OSC_OUT can be used as general-purpose I/O PD0/PD1\nby programming the PD01_REMAP bit in the AF remap and debug I/O configuration register\nThis remap is available only on 36-, 48- and 64-pin packages (PD0 and PD1 are available\non 100-pin and 144-pin packages, no need for remapping).\nNote:The external interrupt/event function is not remapped. PD0 and PD1 cannot be used for\nexternal interrupt/event generation on 36-, 48- and 64-pin packages.\nBit 16LCKK[16]: Lock key\nThis bit can be read anytime. It can only be modified using the Lock Key Writing Sequence.\n0: Port configuration lock key not active\n1: Port configuration lock key active. GPIOx_LCKR register is locked until an MCU reset\nLOCK key writing sequence:\nWrite 1\nWrite 0\nWrite 1\nRead 0\nRead 1 (this read is optional but confirms that the lock is active)\nNote:During the LOCK Key Writing sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence will abort the lock.\nBits 15:0LCKy: Port x Lock bit y (y= 0 .. 15)\nThese bits are read write but can only be written when the LCKK bit is 0.\n0: Port configuration not locked\n1: Port configuration locked.\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9153/995\n8.3.3 CAN1 alternate function remapping\nThe CAN signals can be mapped on Port A, Port B or Port D as shown in Table30. For port\nD, remapping is not possible in devices delivered in 36-, 48- and 64-pin packages.\n8.3.4 CAN2 alternate function remapping\nCAN2 is available in connectivity line devices. The external signal can be remapped as\nshown in ChapterTable 31.\n8.3.5 JTAG/SWD alternate function remapping\nThe debug interface signals are mapped on the GPIO ports as shown in Table32.\nTable 30.CAN1 alternate function remapping\nAlternate function\n1.CAN1_RX and CAN1_TX in connectivity line devices; CAN_RX and CAN_TX in other devices with a single\nCAN interface.\nCAN_REMAP[1:0] =\nCAN_REMAP[1:0] =\n2.Remap not available on 36-pin package\nCAN_REMAP[1:0] =\n3.This remapping is available only on 100-pin and 144-pin packages, when PD0 and PD1 are not remapped\non OSC-IN and OSC-OUT.\nCAN1_RX or CAN_RXPA11PB8PD0\nCAN1_TX or CAN_RXPA12PB9PD1\nTable 31.CAN2 alternate function remapping\nAlternate functionCAN2_REMAP = “0”CAN2_REMAP = “1”\nTable 32.Debug interface signals\nAlternate functionGPIO port\nJTMS / SWDIOPA13\nJTCK / SWCLKPA14\nJTDO / TRACESWOPB3\nJNTRST PB4\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n154/995 Doc ID 13902 Rev 9\nTo optimize the number of free GPIOs during debugging, this mapping can be configured in\ndifferent ways by programming the SWJ_CFG[1:0] bits in the AF remap and debug I/O\nconfiguration register (AFIO_MAPR). Refer to Table33\n8.3.6 ADC alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR).\nTable 33.Debug port mapping\nSWJ _CFG\nAvailable debug ports\nSWJ I/O pin assigned\nPA13 /\nPA14 /\nPA15 /\nPB3 / JTDO/\nFull SWJ (JTAG-DP + SW-DP)\n(Reset state)\nFull SWJ (JTAG-DP + SW-DP)\nbut without JNTRST\nJTAG-DP Disabled and\nSW-DP Enabled\n1.Released only if not using asynchronous trace.\nJTAG-DP Disabled and\nSW-DP Disabled\nTable 34.ADC1 external trigger injected conversion alternate function remapping\n1.Remap available only for high-density devices.\nAlternate functionADC1_ETRGINJ_REMAP = 0ADC1_ETRGINJ_REMAP = 1\nADC1 external trigger injected\nADC1 external trigger injected\nconversion is connected to\nADC1 external trigger injected\nconversion is connected to\nTable 35.ADC1 external trigger regular conversion alternate function remapping\n1.Remap available only for high-density devices.\nAlternate functionADC1_ETRGREG_REMAP = 0ADC1_ETRGREG_REMAP = 1\nADC1 external trigger regular\nADC1 external trigger regular\nconversion is connected to\nADC1 external trigger regular\nconversion is connected to\nTable 36.ADC2 external trigger injected conversion alternate function remapping\n1.Remap available only for high-density devices.\nAlternate functionADC2_ETRGINJ_REMAP = 0ADC2_ETRGINJ_REMAP = 1\nADC2 external trigger injected\nADC2 external trigger injected\nconversion is connected to\nEXTI 15\nADC2 external trigger injected\nconversion is connected to\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9155/995\n8.3.7 Timer alternate function remapping\nTimer 4 channels 1 to 4 can be remapped from Port B to Port D. Other timer remapping\npossibilities are listed in Table40 to Table42. Refer to AF remap and debug I/O\nconfiguration register (AFIO_MAPR).\nTable 37.ADC2 external trigger regular conversion alternate function remapping\n1.Remap available only for high-density devices.\nAlternate functionADC2_ETRGREG_REG = 0ADC2_ETRGREG_REG = 1\nADC2 external trigger regular\nADC2 external trigger regular\nconversion is connected to\nADC2 external trigger regular\nconversion is connected to\nTable 38.TIM5 alternate function remapping\n1.Remap available only for high-density and connectivity line devices.\nAlternate functionTIM5CH4_IREMAP = 0TIM5CH4_IREMAP = 1\nTIM5 Channel4 is\nconnected to PA3\nLSI internal clock is connected to TIM5_CH4\ninput for calibration purpose.\nTable 39.TIM4 alternate function remapping\nAlternate functionTIM4_REMAP = 0TIM4_REMAP = 1\n1.Remap available only for 100-pin and for 144-pin package.\nTable 40.TIM3 alternate function remapping\nAlternate function\nTIM3_REMAP[1:0] =\n“00” (no remap)\nTIM3_REMAP[1:0] =\n“10” (partial remap)\nTIM3_REMAP[1:0] =\n“11” (full remap)\n1.Remap available only for 64-pin, 100-pin and 144-pin packages.\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n156/995 Doc ID 13902 Rev 9\n8.3.8 USART Alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR).\nTable 41.TIM2 alternate function remapping\nAlternate function\n0] = “00” (no\n0] = “01” (partial\n0] = “10” (partial\n1.Remap not available on 36-pin package.\n0] = “11” (full\n2.TIM_CH1 and TIM_ETR share the same pin but cannot be used at the same time (which is why we have\nthis notation: TIM2_CH1_ETR).\nTable 42.TIM1 alternate function remapping\nAlternate functions\nTIM1_REMAP[1:0] =\n“00” (no remap)\nTIM1_REMAP[1:0] =\n“01” (partial remap)\nTIM1_REMAP[1:0] =\n“11” (full remap)\n1.Remap available only for 100-pin and 144-pin packages.\n2.Remap not available on 36-pin package.\nTable 43.USART3 remapping\nAlternate function\n= “00” (no remap)\nUSART3_REMAP[1:0] =\n“01” (partial remap)\n1.Remap available only for 64-pin, 100-pin and 144-pin packages\n= “11” (full remap)\n2.Remap available only for 100-pin and 144-pin packages.\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9157/995\n8.3.9 I2C1 alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR)\n8.3.10 SPI1 alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR)\n8.3.11 SPI3 alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR). This remap is\navailable only in connectivity line devices.\nTable 44.USART2 remapping\nAlternate functionsUSART2_REMAP = 0USART2_REMAP = 1\n1.Remap available only for 100-pin and 144-pin packages.\nTable 45.USART1 remapping\nAlternate functionUSART1_REMAP = 0USART1_REMAP = 1\nTable 46.I2C1 remapping\nAlternate functionI2C1_REMAP = 0 I2C1_REMAP = 1\n1.Remap not available on 36-pin package.\nTable 47.SPI1 remapping\nAlternate functionSPI1_REMAP = 0SPI1_REMAP = 1\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n158/995 Doc ID 13902 Rev 9\n8.3.12 Ethernet alternate function remapping\nRefer to AF remap and debug I/O configuration register (AFIO_MAPR). Ethernet is available\nonly in connectivity line devices."
  },
  {
    "start_page": 158,
    "end_page": 159,
    "page_range": "158-159",
    "section": "8.4.1",
    "full_name": "Event control register (AFIO_EVCR)",
    "short_name": "AFIO_EVCR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "Table 48.SPI3 remapping\nAlternate functionSPI3_REMAP = 0SPI3_REMAP = 1\nTable 49.ETH remapping\nAlternate functionETH_REMAP = 0ETH_REMAP = 1\nBits 31:8Reserved\nBit 7EVOE: Event output enable\nSet and cleared by software. When set the EVENTOUT Cortex output is connected to the\nI/O selected by the PORT[2:0] and PIN[3:0] bits.\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9159/995"
  },
  {
    "start_page": 159,
    "end_page": 165,
    "page_range": "159-165",
    "section": "8.4.2",
    "full_name": "AF remap and debug I/O configuration register (AFIO_MAPR)",
    "short_name": "AFIO_MAPR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Memory map and bit definitions for low-, medium- and high-density devices:\nBits 6:4PORT[2:0]: Port selection\nSet and cleared by software. Select the port used to output the Cortex EVENTOUT signal.\nNote:The EVENTOUT signal output capability is not extended to ports PF and PG.\n000: PA selected\n001: PB selected\n010: PC selected\n011: PD selected\n100: PE selected\nBits 3:0PIN[3:0]: Pin selection (x = A .. E)\nSet and cleared by software. Select the pin used to output the Cortex EVENTOUT signal.\n0000: Px0 selected\n0001: Px1 selected\n0010: Px2 selected\n0011: Px3 selected\n1111: Px15 selected\nBits 31:27Reserved\nBits 26:24SWJ_CFG[2:0]: Serial wire JTAG configuration\nThese bits are write-only (when read, the value is undefined). They are used to configure the\nSWJ and trace alternate function I/Os. The SWJ (Serial Wire JTAG) supports JTAG or SWD\naccess to the Cortex debug port. The default state after reset is SWJ ON without trace. This\nallows JTAG or SW mode to be enabled by sending a specific sequence on the JTMS /\nJTCK pin.\n000: Full SWJ (JTAG-DP + SW-DP): Reset State\n001: Full SWJ (JTAG-DP + SW-DP) but without JNTRST\n010: JTAG-DP Disabled and SW-DP Enabled\n100: JTAG-DP Disabled and SW-DP Disabled\nOther combinations: no effect\nBits 23:21Reserved\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n160/995 Doc ID 13902 Rev 9\nBits 20ADC2_ETRGREG_REMAP: ADC 2 external trigger regular conversion remapping\nSet and cleared by software. This bit controls the trigger input connected to ADC2 external\ntrigger regular conversion. When this bit is reset, the ADC2 external trigger regular\nconversion is connected to EXTI11. When this bit is set, the ADC2 external event regular\nconversion is connected to TIM8_TRGO.\nBits 19ADC2_ETRGINJ_REMAP: ADC 2 external trigger injected conversion remapping\nSet and cleared by software. This bit controls the trigger input connected to ADC2 external\ntrigger injected conversion. When this bit is reset, the ADC2 external trigger injected\nconversion is connected to EXTI15. When this bit is set, the ADC2 external event injected\nconversion is connected to TIM8_Channel4.\nBits 18ADC1_ETRGREG_REMAP: ADC 1 external trigger regular conversion remapping\nSet and cleared by software. This bit controls the trigger input connected to ADC1\nExternal trigger regular conversion. When reset the ADC1 External trigger regular\nconversion is connected to EXTI11. When set the ADC1 External Event regular conversion\nis connected to TIM8 TRGO.\nBits 17ADC1_ETRGINJ_REMAP: ADC 1 External trigger injected conversion remapping\nSet and cleared by software. This bit controls the trigger input connected to ADC1\nExternal trigger injected conversion. When reset the ADC1 External trigger injected\nconversion is connected to EXTI15. When set the ADC1 External Event injected conversion\nis connected to TIM8 Channel4.\nBits 16TIM5CH4_IREMAP: TIM5 channel4 internal remap\nSet and cleared by software. This bit controls the TIM5_CH4 internal mapping. When reset\nthe timer TIM5_CH4 is connected to PA3. When set the LSI internal clock is connected to\nTIM5_CH4 input for calibration purpose.\nBit 15PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT\nThis bit is set and cleared by software. It controls the mapping of PD0 and PD1 GPIO\nfunctionality. When the HSE oscillator is not used (application running on internal 8 MHz RC)\nPD0 and PD1 can be mapped on OSC_IN and OSC_OUT. This is available only on 36-, 48-\nand 64-pin packages (PD0 and PD1 are available on 100-pin and 144-pin packages, no\nneed for remapping).\n0: No remapping of PD0 and PD1\n1: PD0 remapped on OSC_IN, PD1 remapped on OSC_OUT,\nBits 14:13CAN_REMAP[1:0]: CAN alternate function remapping\nThese bits are set and cleared by software. They control the mapping of alternate functions\nCAN_RX and CAN_TX in devices with a single CAN interface.\n00: CAN_RX mapped to PA11, CAN_TX mapped to PA12\n01: Not used\n10: CAN_RX mapped to PB8, CAN_TX mapped to PB9 (not available on 36-pin package)\n11: CAN_RX mapped to PD0, CAN_TX mapped to PD1\nBit 12TIM4_REMAP: TIM4 remapping\nThis bit is set and cleared by software. It controls the mapping of TIM4 channels 1 to 4 onto\nthe GPIO ports.\n0: No remap (TIM4_CH1/PB6, TIM4_CH2/PB7, TIM4_CH3/PB8, TIM4_CH4/PB9)\n1: Full remap (TIM4_CH1/PD12, TIM4_CH2/PD13, TIM4_CH3/PD14, TIM4_CH4/PD15)\nNote:TIM4_ETR on PE0 is not re-mapped.\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9161/995\nBits 11:10TIM3_REMAP[1:0]: TIM3 remapping\nThese bits are set and cleared by software. They control the mapping of TIM3 channels 1 to\n4 on the GPIO ports.\n00: No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1)\n01: Not used\n10: Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1)\n11: Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9)\nNote:TIM3_ETR on PE0 is not re-mapped.\nBits 9:8TIM2_REMAP[1:0]: TIM2 remapping\nThese bits are set and cleared by software. They control the mapping of TIM2 channels 1 to\n4 and external trigger (ETR) on the GPIO ports.\n00: No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3)\n01: Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3)\n10: Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11)\n11: Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11)\nBits 7:6TIM1_REMAP[1:0]: TIM1 remapping\nThese bits are set and cleared by software. They control the mapping of TIM2 channels 1 to\n4, 1N to 3N, external trigger (ETR) and Break input (BKIN) on the GPIO ports.\n00: No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12,\nCH1N/PB13, CH2N/PB14, CH3N/PB15)\n01: Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6,\nCH1N/PA7, CH2N/PB0, CH3N/PB1)\n10: not used\n11: Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15,\nCH1N/PE8, CH2N/PE10, CH3N/PE12)\nBits 5:4USART3_REMAP[1:0]: USART3 remapping\nThese bits are set and cleared by software. They control the mapping of USART3 CTS,\nRTS,CK,TX and RX alternate functions on the GPIO ports.\n00: No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14)\n01: Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14)\n10: not used\n11: Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12)\nBit 3USART2_REMAP: USART2 remapping\nThis bit is set and cleared by software. It controls the mapping of USART2 CTS, RTS,CK,TX\nand RX alternate functions on the GPIO ports.\n0: No remap (CTS/PA0, RTS/PA1, TX/PA2, RX/PA3, CK/PA4)\n1: Remap (CTS/PD3, RTS/PD4, TX/PD5, RX/PD6, CK/PD7)\nBit 2USART1_REMAP: USART1 remapping\nThis bit is set and cleared by software. It controls the mapping of USART1 TX and RX\nalternate functions on the GPIO ports.\n0: No remap (TX/PA9, RX/PA10)\n1: Remap (TX/PB6, RX/PB7)\nBit 1I2C1_REMAP: I2C1 remapping\nThis bit is set and cleared by software. It controls the mapping of I2C1 SCL and SDA\nalternate functions on the GPIO ports.\n0: No remap (SCL/PB6, SDA/PB7)\n1: Remap (SCL/PB8, SDA/PB9)\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n162/995 Doc ID 13902 Rev 9\nMemory map and bit definitions for connectivity line devices:\nBit 0SPI1_REMAP: SPI1 remapping\nThis bit is set and cleared by software. It controls the mapping of SPI1 NSS, SCK, MISO,\nMOSI alternate functions on the GPIO ports.\n0: No remap (NSS/PA4, SCK/PA5, MISO/PA6, MOSI/PA7)\n1: Remap (NSS/PA15, SCK/PB3, MISO/PB4, MOSI/PB5)\nBit 31Reserved\nBit 30PTP_PPS_REMAP: Ethernet PTP PPS remapping\nThis bit is set and cleared by software. It enables the Ethernet MAC PPS_PTS to be output\non the PB5 pin.\n0: PTP_PPS not output on PB5 pin.\n1: PTP_PPS is output on PB5 pin.\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBit 29TIM2ITR1_IREMAP: TIM2 internal trigger 1 remapping\nThis bit is set and cleared by software. It controls the TIM2_ITR1 internal mapping.\n0: Connect TIM2_ITR1 internally to the Ethernet PTP output for calibration purposes.\n1: Connect USB OTG SOF (Start of Frame) output to TIM2_ITR1 for calibration purposes.\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBit 28SPI3_REMAP: SPI3 remapping\nThis bit is set and cleared by software. It controls the mapping of SPI3 NSS, SCK, MISO,\nMOSI alternate functions on the GPIO ports.\n0: No remap (NSS/PA15, SCK/PB3, MISO/PB4, MOSI/PB5)\n1: Remap (NSS/PA4, SCK/PC10, MISO/PC11, MOSI/PC12)\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBit 27Reserved\nBits 26:24SWJ_CFG[2:0]: Serial wire JTAG configuration\nThese bits are write-only (when read, the value is undefined). They are used to configure the\nSWJ and trace alternate function I/Os. The SWJ (Serial Wire JTAG) supports JTAG or SWD\naccess to the Cortex debug port. The default state after reset is SWJ ON without trace. This\nallows JTAG or SW mode to be enabled by sending a specific sequence on the JTMS /\nJTCK pin.\n000: Full SWJ (JTAG-DP + SW-DP): Reset State\n001: Full SWJ (JTAG-DP + SW-DP) but without JNTRST\n010: JTAG-DP Disabled and SW-DP Enabled\n100: JTAG-DP Disabled and SW-DP Disabled\nOther combinations: no effect\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9163/995\nBit 23MII_RMII_SEL: MII or RMII selection\nThis bit is set and cleared by software. It configures the Ethernet MAC internally for use with\nan external MII or RMII PHY.\n0: Configure Ethernet MAC for connection with an MII PHY\n1: Configure Ethernet MAC for connection with an RMII PHY\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBit 22CAN2_REMAP: CAN2 I/O remapping\nThis bit is set and cleared by software. It controls the CAN2_TX and CAN2_RX pins.\n0: No remap (CAN2_RX/PB12, CAN2_TX/PB13)\n1: Remap (CAN2_RX/PB5, CAN2_TX/PB6)\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBit 21ETH_REMAP: Ethernet MAC I/O remapping\nThis bit is set and cleared by software. It controls the Ethernet MAC connections with the\n0: No remap (RX_DV-CRS_DV/PA7, RXD0/PC4, RXD1/PC5, RXD2/PB0, RXD3/PB1)\n1: Remap (RX_DV-CRS_DV/PD8, RXD0/PD9, RXD1/PD10, RXD2/PD11, RXD3/PD12)\nNote:This bit is available only in connectivity line devices and is reserved otherwise.\nBits 20:17Reserved\nBits 16TIM5CH4_IREMAP: TIM5 channel4 internal remap\nSet and cleared by software. This bit controls the TIM5_CH4 internal mapping. When reset\nthe timer TIM5_CH4 is connected to PA3. When set the LSI internal clock is connected to\nTIM5_CH4 input for calibration purpose.\nBit 15PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT\nThis bit is set and cleared by software. It controls the mapping of PD0 and PD1 GPIO\nfunctionality. When the HSE oscillator is not used (application running on internal 8 MHz RC)\nPD0 and PD1 can be mapped on OSC_IN and OSC_OUT. This is available only on 36-, 48-\nand 64-pin packages (PD0 and PD1 are available on 100-pin and 144-pin packages, no\nneed for remapping).\n0: No remapping of PD0 and PD1\n1: PD0 remapped on OSC_IN, PD1 remapped on OSC_OUT,\nBits 14:13CAN1_REMAP[1:0]: CAN1 alternate function remapping\nThese bits are set and cleared by software. They control the mapping of alternate functions\nCAN1_RX and CAN1_TX.\n00: CAN1_RX mapped to PA11, CAN1_TX mapped to PA12\n01: Not used\n10: CAN1_RX mapped to PB8, CAN1_TX mapped to PB9 (not available on 36-pin package)\n11: CAN1_RX mapped to PD0, CAN1_TX mapped to PD1\nBit 12TIM4_REMAP: TIM4 remapping\nThis bit is set and cleared by software. It controls the mapping of TIM4 channels 1 to 4 onto\nthe GPIO ports.\n0: No remap (TIM4_CH1/PB6, TIM4_CH2/PB7, TIM4_CH3/PB8, TIM4_CH4/PB9)\n1: Full remap (TIM4_CH1/PD12, TIM4_CH2/PD13, TIM4_CH3/PD14, TIM4_CH4/PD15)\nNote:TIM4_ETR on PE0 is not re-mapped.\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n164/995 Doc ID 13902 Rev 9\nBits 11:10TIM3_REMAP[1:0]: TIM3 remapping\nThese bits are set and cleared by software. They control the mapping of TIM3 channels 1 to\n4 on the GPIO ports.\n00: No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1)\n01: Not used\n10: Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1)\n11: Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9)\nNote:TIM3_ETR on PE0 is not re-mapped.\nBits 9:8TIM2_REMAP[1:0]: TIM2 remapping\nThese bits are set and cleared by software. They control the mapping of TIM2 channels 1 to\n4 and external trigger (ETR) on the GPIO ports.\n00: No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3)\n01: Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3)\n10: Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11)\n11: Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11)\nBits 7:6TIM1_REMAP[1:0]: TIM1 remapping\nThese bits are set and cleared by software. They control the mapping of TIM2 channels 1 to\n4, 1N to 3N, external trigger (ETR) and Break input (BKIN) on the GPIO ports.\n00: No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12,\nCH1N/PB13, CH2N/PB14, CH3N/PB15)\n01: Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6,\nCH1N/PA7, CH2N/PB0, CH3N/PB1)\n10: not used\n11: Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15,\nCH1N/PE8, CH2N/PE10, CH3N/PE12)\nBits 5:4USART3_REMAP[1:0]: USART3 remapping\nThese bits are set and cleared by software. They control the mapping of USART3 CTS,\nRTS,CK,TX and RX alternate functions on the GPIO ports.\n00: No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14)\n01: Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14)\n10: not used\n11: Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12)\nBit 3USART2_REMAP: USART2 remapping\nThis bit is set and cleared by software. It controls the mapping of USART2 CTS, RTS,CK,TX\nand RX alternate functions on the GPIO ports.\n0: No remap (CTS/PA0, RTS/PA1, TX/PA2, RX/PA3, CK/PA4)\n1: Remap (CTS/PD3, RTS/PD4, TX/PD5, RX/PD6, CK/PD7)\nBit 2USART1_REMAP: USART1 remapping\nThis bit is set and cleared by software. It controls the mapping of USART1 TX and RX\nalternate functions on the GPIO ports.\n0: No remap (TX/PA9, RX/PA10)\n1: Remap (TX/PB6, RX/PB7)\nBit 1I2C1_REMAP: I2C1 remapping\nThis bit is set and cleared by software. It controls the mapping of I2C1 SCL and SDA\nalternate functions on the GPIO ports.\n0: No remap (SCL/PB6, SDA/PB7)\n1: Remap (SCL/PB8, SDA/PB9)\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9165/995"
  },
  {
    "start_page": 165,
    "end_page": 165,
    "page_range": "165",
    "section": "8.4.3",
    "full_name": "External interrupt configuration register 1 (AFIO_EXTICR1)",
    "short_name": "AFIO_EXTICR1",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 165,
    "end_page": 166,
    "page_range": "165-166",
    "section": "8.4.4",
    "full_name": "External interrupt configuration register 2 (AFIO_EXTICR2)",
    "short_name": "AFIO_EXTICR2",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bit 0SPI1_REMAP: SPI1 remapping\nThis bit is set and cleared by software. It controls the mapping of SPI1 NSS, SCK, MISO,\nMOSI alternate functions on the GPIO ports.\n0: No remap (NSS/PA4, SCK/PA5, MISO/PA6, MOSI/PA7)\n1: Remap (NSS/PA15, SCK/PB3, MISO/PB4, MOSI/PB5)\nBits 31:16Reserved\nBits 15:0 EXTIx[3:0]: EXTI x configuration (x= 0 to 3)\nThese bits are written by software to select the source input for EXTIx external interrupt.\nRefer to Section9.2.5: External interrupt/event line mapping on page176\n0000: PA[x] pin\n0001: PB[x] pin\n0010: PC[x] pin\n0011: PD[x] pin\n0100: PE[x] pin\n0101: PF[x] pin\n0110: PG[x] pin\nBits 31:16Reserved\nBits 15:0 EXTIx[3:0]: EXTI x configuration (x= 4 to 7)\nThese bits are written by software to select the source input for EXTIx external interrupt.\n0000: PA[x] pin\n0001: PB[x] pin\n0010: PC[x] pin\n0011: PD[x] pin\n0100: PE[x] pin\n0101: PF[x] pin\n0110: PG[x] pin\nGeneral-purpose and alternate-function I/Os (GPIOs and AFIOs)RM0008\n166/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 166,
    "end_page": 166,
    "page_range": "166",
    "section": "8.4.5",
    "full_name": "External interrupt configuration register 3 (AFIO_EXTICR3)",
    "short_name": "AFIO_EXTICR3",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 166,
    "end_page": 167,
    "page_range": "166-167",
    "section": "8.4.6",
    "full_name": "External interrupt configuration register 4 (AFIO_EXTICR4)",
    "short_name": "AFIO_EXTICR4",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "Bits 31:16Reserved\nBits 15:0 EXTIx[3:0]: EXTI x configuration (x= 8 to 11)\nThese bits are written by software to select the source input for EXTIx external interrupt.\n0000: PA[x] pin\n0001: PB[x] pin\n0010: PC[x] pin\n0011: PD[x] pin\n0100: PE[x] pin\n0101: PF[x] pin\n0110: PG[x] pin\nBits 31:16Reserved\nBits 15:0 EXTIx[3:0]: EXTI x configuration (x= 12 to 15)\nThese bits are written by software to select the source input for EXTIx external interrupt.\n0000: PA[x] pin\n0001: PB[x] pin\n0010: PC[x] pin\n0011: PD[x] pin\n0100: PE[x] pin\n0101: PF[x] pin\n0110: PG[x] pin\nRM0008General-purpose and alternate-function I/Os (GPIOs and AFIOs)\nDoc ID 13902 Rev 9167/995"
  },
  {
    "start_page": 178,
    "end_page": 178,
    "page_range": "178",
    "section": "9.3.1",
    "full_name": "Interrupt mask register (EXTI_IMR)",
    "short_name": "EXTI_IMR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 178,
    "end_page": 179,
    "page_range": "178-179",
    "section": "9.3.2",
    "full_name": "Event mask register (EXTI_EMR)",
    "short_name": "EXTI_EMR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:20Reserved, must be kept at reset value (0).\nBits 19:0MRx: Interrupt Mask on line x\n0: Interrupt request from Line x is masked\n1: Interrupt request from Line x is not masked\nNote:Bit 19 is used in connectivity line devices only and is reserved otherwise.\nBits 31:20Reserved, must be kept at reset value (0).\nBits 19:0MRx: Event Mask on line x\n0: Event request from Line x is masked\n1: Event request from Line x is not masked\nNote:Bit 19 is used in connectivity line devices only and is reserved otherwise.\nRM0008Interrupts and events\nDoc ID 13902 Rev 9179/995"
  },
  {
    "start_page": 179,
    "end_page": 179,
    "page_range": "179",
    "section": "9.3.3",
    "full_name": "Rising trigger selection register (EXTI_RTSR)",
    "short_name": "EXTI_RTSR",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Note:The external wakeup lines are edge triggered, no glitches must be generated on these lines.\nIf a rising edge on external interrupt line occurs during writing of EXTI_RTSR register, the\npending bit will not be set.\nRising and Falling edge triggers can be set for the same interrupt line. In this configuration,\nboth generate a trigger condition."
  },
  {
    "start_page": 179,
    "end_page": 180,
    "page_range": "179-180",
    "section": "9.3.4",
    "full_name": "Falling trigger selection register (EXTI_FTSR)",
    "short_name": "EXTI_FTSR",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": "Note:The external wakeup lines are edge triggered, no glitches must be generated on these lines.\nIf a falling edge on external interrupt line occurs during writing of EXTI_FTSR register, the\npending bit will not be set.\nRising and Falling edge triggers can be set for the same interrupt line. In this configuration,\nboth generate a trigger condition.\nBits 31:20Reserved, must be kept at reset value (0).\nBits 19:0TRx: Rising trigger event configuration bit of line x\n0: Rising trigger disabled (for Event and Interrupt) for input line\n1: Rising trigger enabled (for Event and Interrupt) for input line.\nNote:Bit 19 is used in connectivity line devices only and is reserved otherwise.\nBits 31:20Reserved, must be kept at reset value (0).\nBits 19:0TRx: Falling trigger event configuration bit of line x\n0: Falling trigger disabled (for Event and Interrupt) for input line\n1: Falling trigger enabled (for Event and Interrupt) for input line.\nNote:Bit 19 used in connectivity line devices and is reserved otherwise.\nInterrupts and eventsRM0008\n180/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 180,
    "end_page": 180,
    "page_range": "180",
    "section": "9.3.5",
    "full_name": "Software interrupt event register (EXTI_SWIER)",
    "short_name": "EXTI_SWIER",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 191,
    "end_page": 192,
    "page_range": "191-192",
    "section": "10.4.1",
    "full_name": "DMA interrupt status register (DMA_ISR)",
    "short_name": "DMA_ISR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "TEIF7HTIF7 TCIF7GIF7TEIF6HTIF6 TCIF6GIF6TEIF5HTIF5 TCIF5GIF5\nTEIF4HTIF4 TCIF4GIF4TEIF3HTIF3 TCIF3GIF3TEIF2HTIF2 TCIF2GIF2TEIF1HTIF1 TCIF1GIF1\nBits 31:28Reserved, always read as 0.\nBits 27, 23, 19, 15,\n11, 7, 3\nTEIFx: Channel x transfer error flag (x = 1 ..7)\nThis bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the\nDMA_IFCR register.\n0: No transfer error (TE) on channel x\n1: A transfer error (TE) occurred on channel x\nBits 26, 22, 18, 14,\n10, 6, 2\nHTIFx: Channel x half transfer flag (x = 1 ..7)\nThis bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the\nDMA_IFCR register.\n0: No half transfer (HT) event on channel x\n1: A half transfer (HT) event occurred on channel x\nBits 25, 21, 17, 13,\n9, 5, 1\nTCIFx: Channel x transfer complete flag (x = 1 ..7)\nThis bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the\nDMA_IFCR register.\n0: No transfer complete (TC) event on channel x\n1: A transfer complete (TC) event occurred on channel x\nBits 24, 20, 16, 12,\n8, 4, 0\nGIFx: Channel x global interrupt flag (x = 1 ..7)\nThis bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the\nDMA_IFCR register.\n0: No TE, HT or TC event on channel x\n1: A TE, HT or TC event occurred on channel x\nDMA controller (DMA)RM0008\n192/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 192,
    "end_page": 193,
    "page_range": "192-193",
    "section": "10.4.2",
    "full_name": "DMA interrupt flag clear register (DMA_IFCR)",
    "short_name": "DMA_IFCR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:28Reserved, always read as 0.\nBits 27, 23, 19, 15,\n11, 7, 3\nCTEIFx: Channel x transfer error clear (x = 1 ..7)\nThis bit is set and cleared by software.\n0: No effect\n1: Clears the corresponding TEIF flag in the DMA_ISR register\nBits 26, 22, 18, 14,\n10, 6, 2\nCHTIFx: Channel x half transfer clear (x = 1 ..7)\nThis bit is set and cleared by software.\n0: No effect\n1: Clears the corresponding HTIF flag in the DMA_ISR register\nBits 25, 21, 17, 13,\n9, 5, 1\nCTCIFx: Channel x transfer complete clear (x = 1 ..7)\nThis bit is set and cleared by software.\n0: No effect\n1: Clears the corresponding TCIF flag in the DMA_ISR register\nBits 24, 20, 16, 12,\n8, 4, 0\nCGIFx: Channel x global interrupt clear (x = 1 ..7)\nThis bit is set and cleared by software.\n0: No effect\n1: Clears the GIF, TEIF, HTIF and TCIF flags in the DMA_ISR register\nRM0008DMA controller (DMA)\nDoc ID 13902 Rev 9193/995"
  },
  {
    "start_page": 193,
    "end_page": 194,
    "page_range": "193-194",
    "section": "10.4.3",
    "full_name": "DMA channel x configuration register (DMA_CCRx) (x = 1 ..7)",
    "short_name": "",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:15Reserved, always read as 0.\nBit 14MEM2MEM: Memory to memory mode\nThis bit is set and cleared by software.\n0: Memory to memory mode disabled\n1: Memory to memory mode enabled\nBits 13:12PL[1:0]: Channel priority level\nThese bits are set and cleared by software.\n00: Low\n01: Medium\n10: High\n11: Very high\nBits 11:10MSIZE[1:0]: Memory size\nThese bits are set and cleared by software.\n00: 8-bits\n01: 16-bits\n10: 32-bits\n11: Reserved\nBits 9:8PSIZE[1:0]: Peripheral size\nThese bits are set and cleared by software.\n00: 8-bits\n01: 16-bits\n10: 32-bits\n11: Reserved\nBit 7MINC: Memory increment mode\nThis bit is set and cleared by software.\n0: Memory increment mode disabled\n1: Memory increment mode enabled\nBit 6PINC: Peripheral increment mode\nThis bit is set and cleared by software.\n0: Peripheral increment mode disabled\n1: Peripheral increment mode enabled\nDMA controller (DMA)RM0008\n194/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 194,
    "end_page": 195,
    "page_range": "194-195",
    "section": "10.4.4",
    "full_name": "DMA channel x number of data register (DMA_CNDTRx) (x = 1 ..7)",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": "Bit 5CIRC: Circular mode\nThis bit is set and cleared by software.\n0: Circular mode disabled\n1: Circular mode enabled\nBit 4DIR: Data transfer direction\nThis bit is set and cleared by software.\n0: Read from peripheral\n1: Read from memory\nBit 3TEIE: Transfer error interrupt enable\nThis bit is set and cleared by software.\n0: TE interrupt disabled\n1: TE interrupt enabled\nBit 2HTIE: Half transfer interrupt enable\nThis bit is set and cleared by software.\n0: HT interrupt disabled\n1: HT interrupt enabled\nBit 1TCIE: Transfer complete interrupt enable\nThis bit is set and cleared by software.\n0: TC interrupt disabled\n1: TC interrupt enabled\nBit 0EN: Channel enable\nThis bit is set and cleared by software.\n0: Channel disabled\n1: Channel enabled\nBits 31:16Reserved, always read as 0.\nBits 15:0NDT[15:0]: Number of data to transfer\nNumber of data to be transferred (0 up to 65535). This register can only be written when the\nchannel is disabled. Once the channel is enabled, this register is read-only, indicating the\nremaining bytes to be transmitted. This register decrements after each DMA transfer.\nOnce the transfer is completed, this register can either stay at zero or be reloaded\nautomatically by the value previously programmed if the channel is configured in auto-reload\nIf this register is zero, no transaction can be served whether the channel is enabled or not.\nRM0008DMA controller (DMA)\nDoc ID 13902 Rev 9195/995"
  },
  {
    "start_page": 195,
    "end_page": 195,
    "page_range": "195",
    "section": "10.4.5",
    "full_name": "DMA channel x peripheral address register (DMA_CPARx) (x = 1 ..7)",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": "This register must not be written when the channel is enabled."
  },
  {
    "start_page": 195,
    "end_page": 196,
    "page_range": "195-196",
    "section": "10.4.6",
    "full_name": "DMA channel x memory address register (DMA_CMARx) (x = 1 ..7)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000 0000",
    "content": "This register must not be written when the channel is enabled.\nBits 31:0PA[31:0]: Peripheral address\nBase address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-\nword address.\nWhen PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word\nBits 31:0MA[31:0]: Memory address\nBase address of the memory area from/to which the data will be read/written.\nWhen MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a\nhalf-word address.\nWhen MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word\nDMA controller (DMA)RM0008\n196/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 219,
    "end_page": 220,
    "page_range": "219-220",
    "section": "11.12.1",
    "full_name": "ADC status register (ADC_SR)",
    "short_name": "ADC_SR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "ReservedSTRTJSTRTJEOC EOCAWD\nBits 31:5Reserved, must be kept cleared.\nBit 4STRT: Regular channel Start flag\nThis bit is set by hardware when regular channel conversion starts. It is cleared by software.\n0: No regular channel conversion started\n1: Regular channel conversion has started\nBit 3JSTRT: Injected channel Start flag\nThis bit is set by hardware when injected channel group conversion starts. It is cleared by\n0: No injected group conversion started\n1: Injected group conversion has started\nBit 2JEOC: Injected channel end of conversion\nThis bit is set by hardware at the end of all injected group channel conversion. It is cleared by\n0: Conversion is not complete\n1: Conversion complete\nBit 1EOC: End of conversion\nThis bit is set by hardware at the end of a group channel conversion (regular or injected). It is\ncleared by software or by reading the ADC_DR.\n0: Conversion is not complete\n1: Conversion complete\nBit 0AWD: Analog watchdog flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in\nthe ADC_LTR and ADC_HTR registers. It is cleared by software.\n0: No Analog watchdog event occurred\n1: Analog watchdog event occurred\nAnalog-to-digital converter (ADC)RM0008\n220/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 220,
    "end_page": 222,
    "page_range": "220-222",
    "section": "11.12.2",
    "full_name": "ADC control register 1 (ADC_CR1)",
    "short_name": "ADC_CR1",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "SCANJEOC IEAWDIEEOCIEAWDCH[4:0]\nBits 31:24Reserved, must be kept cleared.\nBit 23AWDEN: Analog watchdog enable on regular channels\nThis bit is set/reset by software.\n0: Analog watchdog disabled on regular channels\n1: Analog watchdog enabled on regular channels\nBit 22JAWDEN: Analog watchdog enable on injected channels\nThis bit is set/reset by software.\n0: Analog watchdog disabled on injected channels\n1: Analog watchdog enabled on injected channels\nBits 21:20Reserved, must be kept cleared.\nBits 19:16DUALMOD[3:0]: Dual mode selection\nThese bits are written by software to select the operating mode.\n0000: Independent mode.\n0001: Combined regular simultaneous + injected simultaneous mode\n0010: Combined regular simultaneous + alternate trigger mode\n0011: Combined injected simultaneous + fast interleaved mode\n0100: Combined injected simultaneous + slow Interleaved mode\n0101: Injected simultaneous mode only\n0110: Regular simultaneous mode only\n0111: Fast interleaved mode only\n1000: Slow interleaved mode only\n1001: Alternate trigger mode only\nNote:These bits are reserved in ADC2 and ADC3.\nIn dual mode, a change of channel configuration generates a restart that can produce a\nloss of synchronization. It is recommended to disable dual mode before any\nconfiguration change.\nBits 15:13 DISCNUM[2:0]: Discontinuous mode channel count\nThese bits are written by software to define the number of regular channels to be converted\nin discontinuous mode, after receiving an external trigger.\n000: 1 channel\n001: 2 channels\n111: 8 channels\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9221/995\nBit 12JDISCEN: Discontinuous mode on injected channels\nThis bit set and cleared by software to enable/disable discontinuous mode on injected group\n0: Discontinuous mode on injected channels disabled\n1: Discontinuous mode on injected channels enabled\nBit 11DISCEN: Discontinuous mode on regular channels\nThis bit set and cleared by software to enable/disable Discontinuous mode on regular\n0: Discontinuous mode on regular channels disabled\n1: Discontinuous mode on regular channels enabled\nBit 10JAUTO: Automatic Injected Group conversion\nThis bit set and cleared by software to enable/disable automatic injected group conversion\nafter regular group conversion.\n0: Automatic injected group conversion disabled\n1: Automatic injected group conversion enabled\nBit 9AWDSGL: Enable the watchdog on a single channel in scan mode\nThis bit set and cleared by software to enable/disable the analog watchdog on the channel\nidentified by the AWDCH[4:0] bits.\n0: Analog watchdog enabled on all channels\n1: Analog watchdog enabled on a single channel\nBit 8SCAN: Scan mode\nThis bit is set and cleared by software to enable/disable Scan mode. In Scan mode, the\ninputs selected through the ADC_SQRx or ADC_JSQRx registers are converted.\n0: Scan mode disabled\n1: Scan mode enabled\nNote:An EOC or JEOC interrupt is generated only on the end of conversion of the last\nchannel if the corresponding EOCIE or JEOCIE bit is set\nBit 7JEOCIE: Interrupt enable for injected channels\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt for\ninjected channels.\n0: JEOC interrupt disabled\n1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set.\nBit 6AWDIE: Analog watchdog interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt. In\nScan mode if the watchdog thresholds are crossed, scan is aborted only if this bit is enabled.\n0: Analog watchdog interrupt disabled\n1: Analog watchdog interrupt enabled\nBit 5EOCIE: Interrupt enable for EOC\nThis bit is set and cleared by software to enable/disable the End of Conversion interrupt.\n0: EOC interrupt disabled\n1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set.\nAnalog-to-digital converter (ADC)RM0008\n222/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 222,
    "end_page": 225,
    "page_range": "222-225",
    "section": "11.12.3",
    "full_name": "ADC control register 2 (ADC_CR2)",
    "short_name": "ADC_CR2",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Bits 4:0AWDCH[4:0]: Analog watchdog channel select bits\nThese bits are set and cleared by software. They select the input channel to be guarded by\nthe Analog watchdog.\n00000: ADC analog input Channel0\n00001: ADC analog input Channel1\n01111: ADC analog input Channel15\n10000: ADC analog input Channel16\n10001: ADC analog input Channel17\nOther values reserved.\nNote:ADC1 analog inputs Channel16 and Channel17 are internally connected to the\ntemperature sensor and to V\n, respectively.\nADC2 analog inputs Channel16 and Channel17 are internally connected to V\nADC3 analog inputs Channel9, Channel14, Channel15, Channel16 and Channel17 are\nconnected to V\nBits 31:24Reserved, must be kept cleared.\nBit 23TSVREFE: Temperature sensor and V\nThis bit is set and cleared by software to enable/disable the temperature sensor and V\nchannel. In devices with dual ADCs this bit is present only in ADC1.\n0: Temperature sensor and V\nchannel disabled\n1: Temperature sensor and V\nchannel enabled\nBit 22SWSTART: Start conversion of regular channels\nThis bit is set by software to start conversion and cleared by hardware as soon as conversion\nstarts. It starts a conversion of a group of regular channels if SWSTART is selected as trigger\nevent by the EXTSEL[2:0] bits.\n0: Reset state\n1: Starts conversion of regular channels\nBit 21JSWSTART: Start conversion of injected channels\nThis bit is set by software and cleared by software or by hardware as soon as the conversion\nstarts. It starts a conversion of a group of injected channels (if JSWSTART is selected as\ntrigger event by the JEXTSEL[2:0] bits.\n0: Reset state\n1: Starts conversion of injected channels\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9223/995\nBit 20EXTTRIG: External trigger conversion mode for regular channels\nThis bit is set and cleared by software to enable/disable the external trigger used to start\nconversion of a regular channel group.\n0: Conversion on external event disabled\n1: Conversion on external event enabled\nBits 19:17EXTSEL[2:0]: External event select for regular group\nThese bits select the external event used to trigger the start of conversion of a regular group:\nFor ADC1 and ADC2, the assigned triggers are:\n000: Timer 1 CC1 event\n001: Timer 1 CC2 event\n010: Timer 1 CC3 event\n011: Timer 2 CC2 event\n100: Timer 3 TRGO event\n101: Timer 4 CC4 event\n110: EXTI line11/TIM8_TRGO event (TIM8_TRGO is available only in high-density devices)\n111: SWSTART\nFor ADC3, the assigned triggers are:\n000: Timer 3 CC1 event\n001: Timer 2 CC3 event\n010: Timer 1 CC3 event\n011: Timer 8 CC1 event\n100: Timer 8 TRGO event\n101: Timer 5 CC1 event\n110: Timer 5 CC3 event\n111: SWSTART\nBit 16Reserved, must be kept cleared.\nBit 15JEXTTRIG: External trigger conversion mode for injected channels\nThis bit is set and cleared by software to enable/disable the external trigger used to start\nconversion of an injected channel group.\n0: Conversion on external event disabled\n1: Conversion on external event enabled\nAnalog-to-digital converter (ADC)RM0008\n224/995 Doc ID 13902 Rev 9\nBits 14:12JEXTSEL[2:0]: External event select for injected group\nThese bits select the external event used to trigger the start of conversion of an injected\nFor ADC1 and ADC2 the assigned triggers are:\n000: Timer 1 TRGO event\n001: Timer 1 CC4 event\n010: Timer 2 TRGO event\n011: Timer 2 CC1 event\n100: Timer 3 CC4 event\n101: Timer 4 TRGO event\n110: EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in High-density devices)\n111: JSWSTART\nFor ADC3 the assigned triggers are:\n000: Timer 1 TRGO event\n001: Timer 1 CC4 event\n010: Timer 4 CC3 event\n011: Timer 8 CC2 event\n100: Timer 8 CC4 event\n101: Timer 5 TRGO event\n110: Timer 5 CC4 event\n111: JSWSTART\nBit 11ALIGN: Data alignment\nThis bit is set and cleared by software. Refer to Figure 30.and Figure 31.\n0: Right Alignment\n1: Left Alignment\nBits 10:9Reserved, must be kept cleared.\nBit 8 DMA: Direct memory access mode\nThis bit is set and cleared by software. Refer to the DMA controller chapter for more details.\n0: DMA mode disabled\n1: DMA mode enabled\nNote:Only ADC1 and ADC3 can generate a DMA request.\nBits 7:4 Reserved, must be kept cleared.\nBit 3RSTCAL: Reset calibration\nThis bit is set by software and cleared by hardware. It is cleared after the calibration registers\nare initialized.\n0: Calibration register initialized.\n1: Initialize calibration register.\nNote:If RSTCAL is set when conversion is ongoing, additional cycles are required to clear the\ncalibration registers.\nBit 2CAL: A/D Calibration\nThis bit is set by software to start the calibration. It is reset by hardware after calibration is\n0: Calibration completed\n1: Enable calibration\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9225/995"
  },
  {
    "start_page": 225,
    "end_page": 226,
    "page_range": "225-226",
    "section": "11.12.4",
    "full_name": "ADC sample time register 1 (ADC_SMPR1)",
    "short_name": "ADC_SMPR1",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": "Bit 1CONT: Continuous conversion\nThis bit is set and cleared by software. If set conversion takes place continuously till this bit is\n0: Single conversion mode\n1: Continuous conversion mode\nBit 0ADON: A/D converter ON / OFF\nThis bit is set and cleared by software. If this bit holds a value of zero and a 1 is written to it\nthen it wakes up the ADC from Power Down state.\nConversion starts when this bit holds a value of 1 and a 1 is written to it. The application\nshould allow a delay of t\nbetween power up and start of conversion. Refer to Figure 26.\n0: Disable ADC conversion/calibration and go to power down mode.\n1: Enable ADC and to start conversion\nNote:If any other bit in this register apart from ADON is changed at the same time, then\nconversion is not triggered. This is to prevent triggering an erroneous conversion.\nBits 31:24 Reserved, must be kept cleared.\nBits 23:0SMPx[2:0]: Channel x Sample time selection\nThese bits are written by software to select the sample time individually for each channel.\nDuring sample cycles channel selection bits must remain unchanged.\n000: 1.5 cycles\n001: 7.5 cycles\n010: 13.5 cycles\n011: 28.5 cycles\n100: 41.5 cycles\n101: 55.5 cycles\n110: 71.5 cycles\n111: 239.5 cycles\nNote:ADC1 analog inputs Channel16 and Channel17 are internally connected to the\ntemperature sensor and to V\n, respectively.\nADC2 analog input Channel16 and Channel17 are internally connected to V\nADC3 analog inputs Channel14, Channel15, Channel16 and Channel17 are connected\nto V\nAnalog-to-digital converter (ADC)RM0008\n226/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 226,
    "end_page": 226,
    "page_range": "226",
    "section": "11.12.5",
    "full_name": "ADC sample time register 2 (ADC_SMPR2)",
    "short_name": "ADC_SMPR2",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 226,
    "end_page": 227,
    "page_range": "226-227",
    "section": "11.12.6",
    "full_name": "ADC injected channel data offset register x (ADC_JOFRx)(x=1..4)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:30 Reserved, must be kept cleared.\nBits 29:0SMPx[2:0]: Channel x Sample time selection\nThese bits are written by software to select the sample time individually for each channel.\nDuring sample cycles channel selection bits must remain unchanged.\n000: 1.5 cycles\n001: 7.5 cycles\n010: 13.5 cycles\n011: 28.5 cycles\n100: 41.5 cycles\n101: 55.5 cycles\n110: 71.5 cycles\n111: 239.5 cycles\nNote:ADC3 analog input Channel9 is connected to V\nBits 31:12 Reserved, must be kept cleared.\nBits 11:0JOFFSETx[11:0]: Data offset for injected channel x\nThese bits are written by software to define the offset to be subtracted from the raw\nconverted data when converting injected channels. The conversion result can be read from\nin the ADC_JDRx registers.\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9227/995"
  },
  {
    "start_page": 227,
    "end_page": 227,
    "page_range": "227",
    "section": "11.12.7",
    "full_name": "ADC watchdog high threshold register (ADC_HTR)",
    "short_name": "ADC_HTR",
    "address_offset": "0x24",
    "reset_value": "0x0000 0FFF",
    "content": ""
  },
  {
    "start_page": 227,
    "end_page": 227,
    "page_range": "227",
    "section": "11.12.8",
    "full_name": "ADC watchdog low threshold register (ADC_LTR)",
    "short_name": "ADC_LTR",
    "address_offset": "0x28",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 227,
    "end_page": 228,
    "page_range": "227-228",
    "section": "11.12.9",
    "full_name": "ADC regular sequence register 1 (ADC_SQR1)",
    "short_name": "ADC_SQR1",
    "address_offset": "0x2C",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:12 Reserved, must be kept cleared.\nBits 11:0HT[11:0]: Analog watchdog high threshold\nThese bits are written by software to define the high threshold for the analog watchdog.\nBits 31:12 Reserved, must be kept cleared.\nBits 11:0LT[11:0]: Analog watchdog low threshold\nThese bits are written by software to define the low threshold for the analog watchdog.\nAnalog-to-digital converter (ADC)RM0008\n228/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 228,
    "end_page": 229,
    "page_range": "228-229",
    "section": "11.12.10",
    "full_name": "ADC regular sequence register 2 (ADC_SQR2)",
    "short_name": "ADC_SQR2",
    "address_offset": "0x30",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:24 Reserved, must be kept cleared.\nBits 23:20L[3:0]: Regular channel sequence length\nThese bits are written by software to define the total number of conversions in the regular\nchannel conversion sequence.\n0000: 1 conversion\n0001: 2 conversions\n1111: 16 conversions\nBits 19:15SQ16[4:0]: 16th conversion in regular sequence\nThese bits are written by software with the channel number (0..17) assigned as the 16th in\nthe conversion sequence.\nBits 14:10SQ15[4:0]: 15th conversion in regular sequence\nBits 9:5SQ14[4:0]: 14th conversion in regular sequence\nBits 4:0SQ13[4:0]: 13th conversion in regular sequence\nBits 31:30 Reserved, must be kept cleared.\nBits 29:26SQ12[4:0]: 12th conversion in regular sequence\nThese bits are written by software with the channel number (0..17) assigned as the 12th in the\nsequence to be converted.\nBits 24:20SQ11[4:0]: 11th conversion in regular sequence\nBits 19:15SQ10[4:0]: 10th conversion in regular sequence\nBits 14:10SQ9[4:0]: 9th conversion in regular sequence\nBits 9:5SQ8[4:0]: 8th conversion in regular sequence\nBits 4:0SQ7[4:0]: 7th conversion in regular sequence\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9229/995"
  },
  {
    "start_page": 229,
    "end_page": 229,
    "page_range": "229",
    "section": "11.12.11",
    "full_name": "ADC regular sequence register 3 (ADC_SQR3)",
    "short_name": "ADC_SQR3",
    "address_offset": "0x34",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 229,
    "end_page": 230,
    "page_range": "229-230",
    "section": "11.12.12",
    "full_name": "ADC injected sequence register (ADC_JSQR)",
    "short_name": "ADC_JSQR",
    "address_offset": "0x38",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:30 Reserved, must be kept cleared.\nBits 29:25SQ6[4:0]: 6th conversion in regular sequence\nThese bits are written by software with the channel number (0..17) assigned as the 6th in the\nsequence to be converted.\nBits 24:20SQ5[4:0]: 5th conversion in regular sequence\nBits 19:15SQ4[4:0]: 4th conversion in regular sequence\nBits 14:10SQ3[4:0]: 3rd conversion in regular sequence\nBits 9:5SQ2[4:0]: 2nd conversion in regular sequence\nBits 4:0SQ1[4:0]: 1st conversion in regular sequence\nBits 31:22 Reserved, must be kept cleared.\nBits 21:20JL[1:0]: Injected sequence length\nThese bits are written by software to define the total number of conversions in the injected\nchannel conversion sequence.\n00: 1 conversion\n01: 2 conversions\n10: 3 conversions\n11: 4 conversions\nAnalog-to-digital converter (ADC)RM0008\n230/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 230,
    "end_page": 230,
    "page_range": "230",
    "section": "11.12.13",
    "full_name": "ADC injected data register x (ADC_JDRx) (x= 1..4)",
    "short_name": "",
    "address_offset": "0x3C",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 230,
    "end_page": 231,
    "page_range": "230-231",
    "section": "11.12.14",
    "full_name": "ADC regular data register (ADC_DR)",
    "short_name": "ADC_DR",
    "address_offset": "0x4C",
    "reset_value": "0x0000 0000",
    "content": "Bits 19:15JSQ4[4:0]: 4th conversion in injected sequence\nThese bits are written by software with the channel number (0..17) assigned as the 4th in\nthe sequence to be converted.\nNote:Unlike a regular conversion sequence, if JL[1:0] length is less than four, the channels\nare converted in a sequence starting from (4-JL). Example: ADC_JSQR[21:0] = 10\n00011 00011 00111 00010 means that a scan conversion will convert the following\nchannel sequence: 7, 3, 3. (not 2, 7, 3)\nBits 14:10JSQ3[4:0]: 3rd conversion in injected sequence\nBits 9:5JSQ2[4:0]: 2nd conversion in injected sequence\nBits 4:0JSQ1[4:0]: 1st conversion in injected sequence\nBits 31:16 Reserved, must be kept cleared.\nBits 15:0JDATA[15:0]: Injected data\nThese bits are read only. They contain the conversion result from injected channel x. The\ndata is left or right-aligned as shown in Figure30 and Figure31.\nBits 31:16ADC2DATA[15:0]: ADC2 data\n–In ADC1: In dual mode, these bits contain the regular data of ADC2. Refer to Section11.9:\nDual ADC mode\n–In ADC2 and ADC3: these bits are not used\nBits 15:0DATA[15:0]: Regular data\nThese bits are read only. They contain the conversion result from the regular channels. The\ndata is left or right-aligned as shown in Figure30 and Figure31.\nRM0008Analog-to-digital converter (ADC)\nDoc ID 13902 Rev 9231/995"
  },
  {
    "start_page": 244,
    "end_page": 247,
    "page_range": "244-247",
    "section": "12.5.1",
    "full_name": "DAC control register (DAC_CR)",
    "short_name": "DAC_CR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:29Reserved.\nBit 28DMAEN2: DAC channel2 DMA enable\nThis bit is set and cleared by software.\n0: DAC channel2 DMA mode disabled\n1: DAC channel2 DMA mode enabled\nRM0008Digital-to-analog converter (DAC)\nDoc ID 13902 Rev 9245/995\nBit 27:24MAMP2[3:0]: DAC channel2 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in\ntriangle generation mode.\n0000: Unmask bit0 of LFSR/ Triangle Amplitude equal to 1\n0001: Unmask bits[1:0] of LFSR/ Triangle Amplitude equal to 3\n0010: Unmask bits[2:0] of LFSR/ Triangle Amplitude equal to 7\n0011: Unmask bits[3:0] of LFSR/ Triangle Amplitude equal to 15\n0100: Unmask bits[4:0] of LFSR/ Triangle Amplitude equal to 31\n0101: Unmask bits[5:0] of LFSR/ Triangle Amplitude equal to 63\n0110: Unmask bits[6:0] of LFSR/ Triangle Amplitude equal to 127\n0111: Unmask bits[7:0] of LFSR/ Triangle Amplitude equal to 255\n1000: Unmask bits[8:0] of LFSR/ Triangle Amplitude equal to 511\n1001: Unmask bits[9:0] of LFSR/ Triangle Amplitude equal to 1023\n1010: Unmask bits[10:0] of LFSR/ Triangle Amplitude equal to 2047\n 1011: Unmask bits[11:0] of LFSR/ Triangle Amplitude equal to 4095\nBit 23:22WAVE2[1:0]: DAC channel2 noise/triangle wave generation enable\nThese bits are set/reset by software.\n00: wave generation disabled\n01: Noise wave generation enabled\n1x: Triangle wave generation enabled\nNote:only used if bit TEN2 = 1 (DAC channel2 trigger enabled)\nBits 21:19TSEL2[2:0]: DAC channel2 trigger selection\nThese bits select the external event used to trigger DAC channel2\n000: Timer 6 TRGO event\n001: Timer 3 TRGO event in connectivity line devices, Timer 8 TRGO in high-density devices\n010: Timer 7 TRGO event\n011: Timer 5 TRGO event\n100: Timer 2 TRGO event\n101: Timer 4 TRGO event\n110: External line9\n111: Software trigger\nNote:only used if bit TEN2 = 1 (DAC channel2 trigger enabled)\nBit 18TEN2: DAC channel2 trigger enable\nThis bit set and cleared by software to enable/disable DAC channel2 trigger\n0: DAC channel2 trigger disabled and data written into DAC_DHRx register is transferred\none APB1 clock cycle later to the DAC_DOR2 register.\n1: DAC channel2 trigger enabled and data transfer from DAC_DHRx register is transferred\nthree APB1 clock cycles later to the DAC_DOR2 register.\nNote:When software trigger is selected, it takes only one APB1 clock cycle for DAC_DHRx to\nDAC_DOR2 register transfer.\nBit 17BOFF2: DAC channel2 output buffer disable\nThis bit set and cleared by software to enable/disable DAC channel2 output buffer.\n0: DAC channel2 output buffer enabled\n1: DAC channel2 output buffer disabled\nBit 16EN2: DAC channel2 enable\nThis bit set and cleared by software to enable/disable DAC channel2.\n0: DAC channel2 disabled\n1: DAC channel2 enabled\nBits 15:13Reserved.\nDigital-to-analog converter (DAC)RM0008\n246/995 Doc ID 13902 Rev 9\nBit 12DMAEN1: DAC channel1 DMA enable\nThis bit is set and cleared by software.\n0: DAC channel1 DMA mode disabled\n1: DAC channel1 DMA mode enabled\nBits 11:8MAMP1[3:0]: DAC channel1 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in\ntriangle generation mode.\n0000: Unmask bit0 of LFSR/ Triangle Amplitude equal to 1\n0001: Unmask bits[1:0] of LFSR/ Triangle Amplitude equal to 3\n0010: Unmask bits[2:0] of LFSR/ Triangle Amplitude equal to 7\n0011: Unmask bits[3:0] of LFSR/ Triangle Amplitude equal to 15\n0100: Unmask bits[4:0] of LFSR/ Triangle Amplitude equal to 31\n0101: Unmask bits[5:0] of LFSR/ Triangle Amplitude equal to 63\n0110: Unmask bits[6:0] of LFSR/ Triangle Amplitude equal to 127\n0111: Unmask bits[7:0] of LFSR/ Triangle Amplitude equal to 255\n1000: Unmask bits[8:0] of LFSR/ Triangle Amplitude equal to 511\n1001: Unmask bits[9:0] of LFSR/ Triangle Amplitude equal to 1023\n1010: Unmask bits[10:0] of LFSR/ Triangle Amplitude equal to 2047\n 1011: Unmask bits[11:0] of LFSR/ Triangle Amplitude equal to 4095\nBits 7:6WAVE1[1:0]: DAC channel1 noise/triangle wave generation enable\nThese bits are set/reset by software.\n00: wave generation disabled\n01: Noise wave generation enabled\n1x: Triangle wave generation enabled\nNote: only used if bit TEN1 = 1 (DAC channel1 trigger enabled)\nBits 5:3TSEL1[2:0]: DAC channel1 trigger selection\nThese bits select the external event used to trigger DAC channel1\n000: Timer 6 TRGO event\n001: Timer 3 TRGO event in connectivity line devices, Timer 8 TRGO in high-density devices\n010: Timer 7 TRGO event\n011: Timer 5 TRGO event\n100: Timer 2 TRGO event\n101: Timer 4 TRGO event\n110: External line9\n111: Software trigger\nNote:only used if bit TEN1 = 1 (DAC channel1 trigger enabled)\nBit 2TEN1: DAC channel1 trigger enable\nThis bit set and cleared by software to enable/disable DAC channel1 trigger\n0: DAC channel1 trigger disabled and data written into DAC_DHRx register is transferred\none APB1 clock cycle later to the DAC_DOR1 register.\n1: DAC channel1 trigger enabled and data transfer from DAC_DHRx register is transferred\nthree APB1 clock cycles later to the DAC_DOR1 register.\nNote:When software trigger is selected, it takes only one APB1 clock cycle for DAC_DHRx to\nDAC_DOR1 register transfer.\nBit 1BOFF1: DAC channel1 output buffer disable\nThis bit set and cleared by software to enable/disable DAC channel1 output buffer.\n0: DAC channel1 output buffer enabled\n1: DAC channel1 output buffer disabled\nRM0008Digital-to-analog converter (DAC)\nDoc ID 13902 Rev 9247/995"
  },
  {
    "start_page": 247,
    "end_page": 247,
    "page_range": "247",
    "section": "12.5.2",
    "full_name": "DAC software trigger register (DAC_SWTRIGR)",
    "short_name": "DAC_SWTRIGR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 247,
    "end_page": 248,
    "page_range": "247-248",
    "section": "12.5.3",
    "full_name": "DAC channel1 12-bit right-aligned data holding register",
    "short_name": "",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "Bit 0EN1: DAC channel1 enable\nThis bit set and cleared by software to enable/disable DAC channel1.\n0: DAC channel1 disabled\n1: DAC channel1 enabled\nBits 31:2Reserved.\nBit 1SWTRIG2: DAC channel2 software trigger\nThis bit is set and cleared by software to enable/disable the software trigger.\n0: Software trigger disabled\n1: Software trigger enabled\nNote:This bit is reset by hardware (one APB1 clock cycle later) once the DAC_DHR2 register\nvalue is loaded to the DAC_DOR2 register.\nBit 0SWTRIG1: DAC channel1 software trigger\nThis bit is set and cleared by software to enable/disable the software trigger.\n0: Software trigger disabled\n1: Software trigger enabled\nNote:This bit is reset by hardware (one APB1 clock cycle later) once the DAC_DHR1 register\nvalue is loaded to the DAC_DOR1 register.\nBits 31:12Reserved.\nBit 11:0DACC1DHR[11:0]: DAC channel1 12-bit right-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel1.\nDigital-to-analog converter (DAC)RM0008\n248/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 248,
    "end_page": 248,
    "page_range": "248",
    "section": "12.5.4",
    "full_name": "DAC channel1 12-bit left aligned data holding register",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 248,
    "end_page": 248,
    "page_range": "248",
    "section": "12.5.5",
    "full_name": "DAC channel1 8-bit right aligned data holding register",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 248,
    "end_page": 249,
    "page_range": "248-249",
    "section": "12.5.6",
    "full_name": "DAC channel2 12-bit right aligned data holding register",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:16Reserved.\nBit 15:4DACC1DHR[11:0]: DAC channel1 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel1.\nBits 3:0Reserved.\nBits 31:8Reserved.\nBits 7:0DACC1DHR[7:0]: DAC channel1 8-bit right-aligned data\nThese bits are written by software which specify 8-bit data for DAC channel1.\nBits 31:12Reserved.\nBits 11:0DACC2DHR[11:0]: DAC channel2 12-bit right-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2.\nRM0008Digital-to-analog converter (DAC)\nDoc ID 13902 Rev 9249/995"
  },
  {
    "start_page": 249,
    "end_page": 249,
    "page_range": "249",
    "section": "12.5.7",
    "full_name": "DAC channel2 12-bit left aligned data holding register",
    "short_name": "",
    "address_offset": "0x18",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 249,
    "end_page": 249,
    "page_range": "249",
    "section": "12.5.8",
    "full_name": "DAC channel2 8-bit right-aligned data holding register",
    "short_name": "",
    "address_offset": "0x1C",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 249,
    "end_page": 250,
    "page_range": "249-250",
    "section": "12.5.9",
    "full_name": "Dual DAC 12-bit right-aligned data holding register",
    "short_name": "",
    "address_offset": "0x20",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:16Reserved.\nBits 15:4DACC2DHR[11:0]: DAC channel2 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2.\nBits 3:0Reserved.\nBits 31:8Reserved.\nBits 7:0DACC2DHR[7:0]: DAC channel2 8-bit right-aligned data\nThese bits are written by software which specify 8-bit data for DAC channel2.\nBits 31:28Reserved.\nBits 27:16DACC2DHR[11:0]: DAC channel2 12-bit right-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2.\nDigital-to-analog converter (DAC)RM0008\n250/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 250,
    "end_page": 250,
    "page_range": "250",
    "section": "12.5.10",
    "full_name": "DUAL DAC 12-bit left aligned data holding register",
    "short_name": "",
    "address_offset": "0x24",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 250,
    "end_page": 251,
    "page_range": "250-251",
    "section": "12.5.11",
    "full_name": "DUAL DAC 8-bit right aligned data holding register",
    "short_name": "",
    "address_offset": "0x28",
    "reset_value": "0x0000 0000",
    "content": "Bits 15:12Reserved.\nBits 11:0DACC1DHR[11:0]: DAC channel1 12-bit right-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel1.\nBits 31:20DACC2DHR[11:0]: DAC channel2 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2.\nBits 19:16Reserved.\nBits 15:4DACC1DHR[11:0]: DAC channel1 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel1.\nBits 3:0Reserved.\nBits 31:16Reserved.\nBits 15:8DACC2DHR[7:0]: DAC channel2 8-bit right-aligned data\nThese bits are written by software which specify 8-bit data for DAC channel2.\nBits 7:0DACC1DHR[7:0]: DAC channel1 8-bit right-aligned data\nThese bits are written by software which specify 8-bit data for DAC channel1.\nRM0008Digital-to-analog converter (DAC)\nDoc ID 13902 Rev 9251/995"
  },
  {
    "start_page": 251,
    "end_page": 251,
    "page_range": "251",
    "section": "12.5.12",
    "full_name": "DAC channel1 data output register (DAC_DOR1)",
    "short_name": "DAC_DOR1",
    "address_offset": "0x2C",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 251,
    "end_page": 252,
    "page_range": "251-252",
    "section": "12.5.13",
    "full_name": "DAC channel2 data output register (DAC_DOR2)",
    "short_name": "DAC_DOR2",
    "address_offset": "0x30",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:12Reserved.\nBit 11:0DACC1DOR[11:0]: DAC channel1 data output\nThese bits are read only, they contain data output for DAC channel1.\nBits 31:12Reserved.\nBit 11:0DACC2DOR[11:0]: DAC channel2 data output\nThese bits are read only, they contain data output for DAC channel2.\nDigital-to-analog converter (DAC)RM0008\n252/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 294,
    "end_page": 295,
    "page_range": "294-295",
    "section": "13.4.1",
    "full_name": "TIM1&TIM8 control register 1 (TIMx_CR1)",
    "short_name": "",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Bits 15:10Reserved, always read as 0\nBits 9:8CKD[1:0]: Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the\ndead-time and sampling clock (t\n)used by the dead-time generators and the digital filters\n(ETR, TIx),\n00: t\n01: t\n10: t\n11: Reserved, do not program this value.\nBit 7ARPE: Auto-reload preload enable\n0: TIMx_ARR register is not buffered.\n1: TIMx_ARR register is buffered.\nBits 6:5CMS[1:0]: Center-aligned mode selection\n00: Edge-aligned mode. The counter counts up or down depending on the direction bit\n01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nonly when the counter is counting down.\n10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nonly when the counter is counting up.\n11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nboth when the counter is counting up or down.\nNote:It is not allowed to switch from edge-aligned mode to center-aligned mode as long as\nthe counter is enabled (CEN=1)\nBit 4DIR: Direction\n0: Counter used as upcounter.\n1: Counter used as downcounter.\nNote:This bit is read only when the timer is configured in Center-aligned mode or Encoder\nBit 3OPM: One pulse mode\n0: Counter is not stopped at update event\n1: Counter stops counting at the next update event (clearing the bit CEN).\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9295/995"
  },
  {
    "start_page": 295,
    "end_page": 297,
    "page_range": "295-297",
    "section": "13.4.2",
    "full_name": "TIM1&TIM8 control register 2 (TIMx_CR2)",
    "short_name": "",
    "address_offset": "0x04",
    "reset_value": "0x0000",
    "content": "Bit 2URS: Update request source\nThis bit is set and cleared by software to select the UEV event sources.\n0: Any of the following events generate an update interrupt or DMA request if enabled.\nThese events can be:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\n1: Only counter overflow/underflow generates an update interrupt or DMA request if\nBit 1UDIS: Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\n0: UEV enabled. The Update (UEV) event is generated by one of the following events:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\nBuffered registers are then loaded with their preload values.\n1: UEV disabled. The Update event is not generated, shadow registers keep their value\n(ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is\nset or if a hardware reset is received from the slave mode controller.\nBit 0CEN: Counter enable\n0: Counter disabled\n1: Counter enabled\nNote:External clock, gated mode and encoder mode can work only if the CEN bit has been\npreviously set by software. However trigger mode can set the CEN bit automatically by\nBit 15Reserved, always read as 0\nBit 14OIS4: Output Idle state 4 (OC4 output)\nrefer to OIS1 bit\nBit 13OIS3N: Output Idle state 3 (OC3N output)\nrefer to OIS1N bit\nBit 12OIS3: Output Idle state 3 (OC3 output)\nrefer to OIS1 bit\nBit 11OIS2N: Output Idle state 2 (OC2N output)\nrefer to OIS1N bit\nBit 10OIS2: Output Idle state 2 (OC2 output)\nrefer to OIS1 bit\nAdvanced-control timers (TIM1&TIM8)RM0008\n296/995 Doc ID 13902 Rev 9\nBit 9OIS1N: Output Idle state 1 (OC1N output)\n0: OC1N=0 after a dead-time when MOE=0\n1: OC1N=1 after a dead-time when MOE=0\nNote:This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed\n(LOCK bits in TIMx_BKR register).\nBit 8OIS1: Output Idle state 1 (OC1 output)\n0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=0\n1: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0\nNote:This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed\n(LOCK bits in TIMx_BKR register).\nBit 7TI1S: TI1 selection\n0: The TIMx_CH1 pin is connected to TI1 input.\n1: The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)\nBits 6:4MMS[1:0]: Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for\nsynchronization (TRGO). The combination is as follows:\n000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the\nreset is generated by the trigger input (slave mode controller configured in reset mode) then\nthe signal on TRGO is delayed compared to the actual reset.\n001: Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is\nuseful to start several timers at the same time or to control a window in which a slave timer is\nenable. The Counter Enable signal is generated by a logic OR between CEN control bit and\nthe trigger input when configured in gated mode. When the Counter Enable signal is\ncontrolled by the trigger input, there is a delay on TRGO, except if the master/slave mode is\nselected (see the MSM bit description in TIMx_SMCR register).\n010: Update - The update event is selected as trigger output (TRGO). For instance a master\ntimer can then be used as a prescaler for a slave timer.\n011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be\nset (even if it was already high), as soon as a capture or a compare match occurred.\n100: Compare - OC1REF signal is used as trigger output (TRGO).\n101: Compare - OC2REF signal is used as trigger output (TRGO).\n110: Compare - OC3REF signal is used as trigger output (TRGO).\n111: Compare - OC4REF signal is used as trigger output (TRGO).\nBit 3CCDS: Capture/compare DMA selection\n0: CCx DMA request sent when CCx event occurs\n1: CCx DMA requests sent when update event occurs\nBit 2CCUS: Capture/compare control update selection\n0: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting\nthe COMG bit only.\n1: When capture/compare control bits are preloaded (CCPC=1), they are updated by setting\nthe COMG bit or when an rising edge occurs on TRGI.\nNote:This bit acts only on channels that have a complementary output.\nBit 1Reserved, always read as 0\nBit 0CCPC: Capture/compare preloaded control\n0: CCxE, CCxNE and OCxM bits are not preloaded\n1: CCxE, CCxNE and OCxM bits are preloaded, after having been written, they are updated\nonly when COM bit is set.\nNote:This bit acts only on channels that have a complementary output.\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9297/995"
  },
  {
    "start_page": 297,
    "end_page": 299,
    "page_range": "297-299",
    "section": "13.4.3",
    "full_name": "TIM1&TIM8 slave mode control register (TIMx_SMCR)",
    "short_name": "",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": "Bit 15ETP: External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations\n0: ETR is non-inverted, active at high level or rising edge.\n1: ETR is inverted, active at low level or falling edge.\nBit 14ECE: External clock enable\nThis bit enables External clock mode 2.\n0: External clock mode 2 disabled.\n1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF\nNote:1: Setting the ECE bit has the same effect as selecting external clock mode 1 with\nTRGI connected to ETRF (SMS=111 and TS=111).\n2: It is possible to simultaneously use external clock mode 2 with the following slave\nmodes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be\nconnected to ETRF in this case (TS bits must not be 111).\n3: If external clock mode 1 and external clock mode 2 are enabled at the same time,\nthe external clock input is ETRF.\nBits 13:12ETPS[1:0]: External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of TIMxCLK frequency. A\nprescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external\n00: Prescaler OFF.\n01: ETRP frequency divided by 2.\n10: ETRP frequency divided by 4.\n11: ETRP frequency divided by 8.\nAdvanced-control timers (TIM1&TIM8)RM0008\n298/995 Doc ID 13902 Rev 9\nBits 11:8ETF[3:0]: External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the\ndigital filter applied to ETRP. The digital filter is made of an event counter in which N events\nare needed to validate a transition on the output:\n0000: No filter, sampling is done at f\n0001: f\n, N=2.\n0010: f\n, N=4.\n0011: f\n, N=8.\n0100: f\n/2, N=6.\n0101: f\n/2, N=8.\n0110: f\n/4, N=6.\n0111: f\n/4, N=8.\n1000: f\n/8, N=6.\n1001: f\n/8, N=8.\n1010: f\n/16, N=5.\n1011: f\n/16, N=6.\n1100: f\n/16, N=8.\n1101: f\n/32, N=5.\n1110: f\n/32, N=6.\n1111: f\n/32, N=8.\nBit 7MSM: Master/slave mode\n0: No action\n1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect\nsynchronization between the current timer and its slaves (through TRGO). It is useful if we\nwant to synchronize several timers on a single external event.\nBits 6:4TS[2:0]: Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\n000: Internal Trigger 0 (ITR0)\n001: Internal Trigger 1 (ITR1)\n010: Internal Trigger 2 (ITR2)\n011: Internal Trigger 3 (ITR3)\n100: TI1 Edge Detector (TI1F_ED)\n101: Filtered Timer Input 1 (TI1FP1)\n110: Filtered Timer Input 2 (TI2FP2)\n111: External Trigger input (ETRF)\nSee Table72: TIMx Internal trigger connection on page299 for more details on ITRx meaning\nfor each Timer.\nNote:These bits must be changed only when they are not used (e.g. when SMS=000) to\navoid wrong edge detections at the transition.\nBit 3Reserved, always read as 0.\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9299/995"
  },
  {
    "start_page": 299,
    "end_page": 301,
    "page_range": "299-301",
    "section": "13.4.4",
    "full_name": "TIM1&TIM8 DMA/interrupt enable register (TIMx_DIER)",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bits 2:0SMS: Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to\nthe polarity selected on the external input (see Input Control register and Control Register\n000: Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal\n001: Encoder mode 1 - Counter counts up/down on TI2FP2 edge depending on TI1FP1\n010: Encoder mode 2 - Counter counts up/down on TI1FP1 edge depending on TI2FP2\n011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges\ndepending on the level of the other input.\n100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter\nand generates an update of the registers.\n101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The\ncounter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of\nthe counter are controlled.\n110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not\nreset). Only the start of the counter is controlled.\n111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.\nNote:The gated mode must not be used if TI1F_ED is selected as the trigger input\n(TS=’100’). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the\ngated mode checks the level of the trigger signal.\nTable 72.TIMx Internal trigger connection\n1.When a timer is not present in the product, the corresponding trigger ITRx is not available.\nSlave TIMITR0 (TS = 000)ITR1 (TS = 001)ITR2 (TS = 010)ITR3 (TS = 011)\nBit 15Reserved, always read as 0.\nBit 14TDE: Trigger DMA request enable\n0: Trigger DMA request disabled.\n1: Trigger DMA request enabled.\nBit 13COMDE: COM DMA request enable\n0: COM DMA request disabled.\n1: COM DMA request enabled.\nAdvanced-control timers (TIM1&TIM8)RM0008\n300/995 Doc ID 13902 Rev 9\nBit 12CC4DE: Capture/Compare 4 DMA request enable\n0: CC4 DMA request disabled.\n1: CC4 DMA request enabled.\nBit 11CC3DE: Capture/Compare 3 DMA request enable\n0: CC3 DMA request disabled.\n1: CC3 DMA request enabled.\nBit 10CC2DE: Capture/Compare 2 DMA request enable\n0: CC2 DMA request disabled.\n1: CC2 DMA request enabled.\nBit 9CC1DE: Capture/Compare 1 DMA request enable\n0: CC1 DMA request disabled.\n1: CC1 DMA request enabled.\nBit 8UDE: Update DMA request enable\n0: Update DMA request disabled.\n1: Update DMA request enabled.\nBit 7BIE: Break interrupt enable\n0: Break interrupt disabled.\n1: Break interrupt enabled.\nBit 6TIE: Trigger interrupt enable\n0: Trigger interrupt disabled.\n1: Trigger interrupt enabled.\nBit 5COMIE: COM interrupt enable\n0: COM interrupt disabled.\n1: COM interrupt enabled.\nBit 4CC4IE: Capture/Compare 4 interrupt enable\n0: CC4 interrupt disabled.\n1: CC4 interrupt enabled.\nBit 3CC3IE: Capture/Compare 3 interrupt enable\n0: CC3 interrupt disabled.\n1: CC3 interrupt enabled.\nBit 2CC2IE: Capture/Compare 2 interrupt enable\n0: CC2 interrupt disabled.\n1: CC2 interrupt enabled.\nBit 1CC1IE: Capture/Compare 1 interrupt enable\n0: CC1 interrupt disabled.\n1: CC1 interrupt enabled.\nBit 0UIE: Update interrupt enable\n0: Update interrupt disabled.\n1: Update interrupt enabled.\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9301/995"
  },
  {
    "start_page": 301,
    "end_page": 302,
    "page_range": "301-302",
    "section": "13.4.5",
    "full_name": "TIM1&TIM8 status register (TIMx_SR)",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": "Bit 15:13Reserved, always read as 0.\nBit 12CC4OF: Capture/Compare 4 overcapture flag\nrefer to CC1OF description\nBit 11CC3OF: Capture/Compare 3 overcapture flag\nrefer to CC1OF description\nBit 10CC2OF: Capture/Compare 2 overcapture flag\nrefer to CC1OF description\nBit 9CC1OF: Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input\ncapture mode. It is cleared by software by writing it to ‘0’.\n0: No overcapture has been detected.\n1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was\nalready set\nBit 8Reserved, always read as 0.\nBit 7BIF: Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by\nsoftware if the break input is not active.\n0: No break event occurred.\n1: An active level has been detected on the break input.\nBit 6TIF: Trigger interrupt flag\nThis flag is set by hardware on trigger event (active edge detected on TRGI input when the\nslave mode controller is enabled in all modes but gated mode, both edges in case gated\nmode is selected). It is cleared by software.\n0: No trigger event occurred.\n1: Trigger interrupt pending.\nBit 5COMIF: COM interrupt flag\nThis flag is set by hardware on COM event (when Capture/compare Control bits - CCxE,\nCCxNE, OCxM - have been updated). It is cleared by software.\n0: No COM event occurred.\n1: COM interrupt pending.\nBit 4CC4IF: Capture/Compare 4 interrupt flag\nrefer to CC1IF description\nBit 3CC3IF: Capture/Compare 3 interrupt flag\nrefer to CC1IF description\nAdvanced-control timers (TIM1&TIM8)RM0008\n302/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 302,
    "end_page": 304,
    "page_range": "302-304",
    "section": "13.4.6",
    "full_name": "TIM1&TIM8 event generation register (TIMx_EGR)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "Bit 2CC2IF: Capture/Compare 2 interrupt flag\nrefer to CC1IF description\nBit 1CC1IF: Capture/Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThis flag is set by hardware when the counter matches the compare value, with some\nexception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register\ndescription). It is cleared by software.\n0: No match.\n1: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register.\nWhen the contents of TIMx_CCR1 are greater than the contents of TIMx_ARR, the CC1IF\nbit goes high on the counter overflow (in upcounting and up/down-counting modes) or\nunderflow (in downcounting mode)\nIf channel CC1 is configured as input:\nThis bit is set by hardware on a capture. It is cleared by software or by reading the\nTIMx_CCR1 register.\n0: No input capture occurred\n1: The counter value has been captured in TIMx_CCR1 register (An edge has been\ndetected on IC1 which matches the selected polarity)\nBit 0UIF: Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\n0: No update occurred.\n1: Update interrupt pending. This bit is set by hardware when the registers are updated:\n–At overflow or underflow regarding the repetition counter value (update if repetition\ncounter = 0) and if the UDIS=0 in the TIMx_CR1 register.\n–When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0\nand UDIS=0 in the TIMx_CR1 register.\n–When CNT is reinitialized by a trigger event (refer to Section13.4.3: TIM1&TIM8 slave\nmode control register (TIMx_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register.\nBits 15:8Reserved, always read as 0.\nBit 7BG: Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by\n0: No action.\n1: A break event is generated. MOE bit is cleared and BIF flag is set. Related interrupt or\nDMA transfer can occur if enabled.\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9303/995\nBit 6TG: Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by\n0: No action.\n1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if\nBit 5COMG: Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware\n0: No action\n1: When CCPC bit is set, it allows to update CCxE, CCxNE and OCxM bits\nNote:This bit acts only on channels having a complementary output.\nBit 4CC4G: Capture/Compare 4 generation\nrefer to CC1G description\nBit 3CC3G: Capture/Compare 3 generation\nrefer to CC1G description\nBit 2CC2G: Capture/Compare 2 generation\nrefer to CC1G description\nBit 1CC1G: Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by\n0: No action.\n1: A capture/compare event is generated on channel 1:\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set,\nthe corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the\nCC1IF flag was already high.\nBit 0UG: Update generation\nThis bit can be set by software, it is automatically cleared by hardware.\n0: No action.\n1: Reinitialize the counter and generates an update of the registers. Note that the prescaler\ncounter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if\nthe center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload\nvalue (TIMx_ARR) if DIR=1 (downcounting).\nAdvanced-control timers (TIM1&TIM8)RM0008\n304/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 304,
    "end_page": 307,
    "page_range": "304-307",
    "section": "13.4.7",
    "full_name": "TIM1&TIM8 capture/compare mode register 1 (TIMx_CCMR1)",
    "short_name": "",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": "The channels can be used in input (capture mode) or in output (compare mode). The\ndirection of a channel is defined by configuring the corresponding CCxS bits. All the other\nbits of this register have a different function in input and in output mode. For a given bit,\nOCxx describes its function when the channel is configured in output, ICxx describes its\nfunction when the channel is configured in input. So you must take care that the same bit\ncan have a different meaning for the input stage and for the output stage.\nOutput compare mode:\nBit 15OC2CE: Output Compare 2 clear enable\nBits 14:12OC2M[2:0]: Output Compare 2 mode\nBit 11OC2PE: Output Compare 2 preload enable\nBit 10OC2FE: Output Compare 2 fast enable\nBits 9:8CC2S[1:0]: Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC2 channel is configured as output.\n01: CC2 channel is configured as input, IC2 is mapped on TI2.\n10: CC2 channel is configured as input, IC2 is mapped on TI1.\n11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through the TS bit (TIMx_SMCR register)\nNote: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).\nBit 7OC1CE: Output Compare 1 clear enable\nOC1CE: Output Compare 1 Clear Enable\n0: OC1Ref is not affected by the ETRF Input\n1: OC1Ref is cleared as soon as a High level is detected on ETRF input\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9305/995\nBits 6:4OC1M: Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and\nOC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on\nCC1P and CC1NP bits.\n000: Frozen - The comparison between the output compare register TIMx_CCR1 and the\ncounter TIMx_CNT has no effect on the outputs.\n001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter\nTIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the\ncounter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n100: Force inactive level - OC1REF is forced low.\n101: Force active level - OC1REF is forced high.\n110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1\nelse inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as\nTIMx_CNT>TIMx_CCR1 else active (OC1REF=’1’).\n111: PWM mode 2 - In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1\nelse active. In downcounting, channel 1 is active as long as TIMx_CNT>TIMx_CCR1 else\nNote:1: These bits can not be modified as long as LOCK level 3 has been programmed\n(LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in\n2: In PWM mode 1 or 2, the OCREF level changes only when the result of the\ncomparison changes or when the output compare mode switches from “frozen” mode\nto “PWM” mode.\nBit 3OC1PE: Output Compare 1 preload enable\n0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the\nnew value is taken in account immediately.\n1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload\nregister. TIMx_CCR1 preload value is loaded in the active register at each update event.\nNote:1: These bits can not be modified as long as LOCK level 3 has been programmed\n(LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in\n2: The PWM mode can be used without validating the preload register only in one\npulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\nBit 2OC1FE: Output Compare 1 fast enable\nThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.\n0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is\nON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is\n5 clock cycles.\n1: An active edge on the trigger input acts like a compare match on CC1 output. Then, OC is\nset to the compare level independently from the result of the comparison. Delay to sample\nthe trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if\nthe channel is configured in PWM1 or PWM2 mode.\nAdvanced-control timers (TIM1&TIM8)RM0008\n306/995 Doc ID 13902 Rev 9\nInput capture mode\nBits 1:0CC1S: Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC1 channel is configured as output.\n01: CC1 channel is configured as input, IC1 is mapped on TI1.\n10: CC1 channel is configured as input, IC1 is mapped on TI2.\n11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).\nBits 15:12IC2F: Input capture 2 filter\nBits 11:10IC2PSC[1:0]: Input capture 2 prescaler\nBits 9:8CC2S: Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC2 channel is configured as output.\n01: CC2 channel is configured as input, IC2 is mapped on TI2.\n10: CC2 channel is configured as input, IC2 is mapped on TI1.\n11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if an\ninternal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).\nBits 7:4IC1F[3:0]: Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied\nto TI1. The digital filter is made of an event counter in which N events are needed to validate a\ntransition on the output:\n0000: No filter, sampling is done at f\n0001: f\n, N=2.\n0010: f\n, N=4.\n0011: f\n, N=8.\n0100: f\n/2, N=6.\n0101: f\n/2, N=8.\n0110: f\n/4, N=6.\n0111: f\n/4, N=8.\n1000: f\n/8, N=6.\n1001: f\n/8, N=8.\n1010: f\n/16, N=5.\n1011: f\n/16, N=6.\n1100: f\n/16, N=8.\n1101: f\n/32, N=5.\n1110: f\n/32, N=6.\n1111: f\n/32, N=8.\nBits 3:2IC1PSC: Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).\nThe prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).\n00: no prescaler, capture is done each time an edge is detected on the capture input.\n01: capture is done once every 2 events.\n10: capture is done once every 4 events.\n11: capture is done once every 8 events.\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9307/995"
  },
  {
    "start_page": 307,
    "end_page": 308,
    "page_range": "307-308",
    "section": "13.4.8",
    "full_name": "TIM1&TIM8 capture/compare mode register 2 (TIMx_CCMR2)",
    "short_name": "",
    "address_offset": "0x1C",
    "reset_value": "0x0000",
    "content": "Refer to the above CCMR1 register description.\nOutput compare mode\nBits 1:0CC1S: Capture/Compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC1 channel is configured as output.\n01: CC1 channel is configured as input, IC1 is mapped on TI1.\n10: CC1 channel is configured as input, IC1 is mapped on TI2.\n11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if an\ninternal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).\nBit 15OC4CE: Output compare 4 clear enable\nBits 14:12OC4M: Output compare 4 mode\nBit 11OC4PE: Output compare 4 preload enable\nBit 10OC4FE: Output compare 4 fast enable\nBits 9:8CC4S: Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC4 channel is configured as output.\n01: CC4 channel is configured as input, IC4 is mapped on TI4.\n10: CC4 channel is configured as input, IC4 is mapped on TI3.\n11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).\nBit 7OC3CE: Output compare 3 clear enable\nBits 6:4OC3M: Output compare 3 mode\nBit 3OC3PE: Output compare 3 preload enable\nBit 2OC3FE: Output compare 3 fast enable\nBits 1:0CC3S: Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC3 channel is configured as output.\n01: CC3 channel is configured as input, IC3 is mapped on TI3.\n10: CC3 channel is configured as input, IC3 is mapped on TI4.\n11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).\nAdvanced-control timers (TIM1&TIM8)RM0008\n308/995 Doc ID 13902 Rev 9\nInput capture mode"
  },
  {
    "start_page": 308,
    "end_page": 311,
    "page_range": "308-311",
    "section": "13.4.9",
    "full_name": "TIM1&TIM8 capture/compare enable register (TIMx_CCER)",
    "short_name": "",
    "address_offset": "0x20",
    "reset_value": "0x0000",
    "content": "Bits 15:12IC4F: Input capture 4 filter\nBits 11:10IC4PSC: Input capture 4 prescaler\nBits 9:8CC4S: Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC4 channel is configured as output.\n01: CC4 channel is configured as input, IC4 is mapped on TI4.\n10: CC4 channel is configured as input, IC4 is mapped on TI3.\n11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).\nBits 7:4IC3F: Input capture 3 filter\nBits 3:2IC3PSC: Input capture 3 prescaler\nBits 1:0CC3S: Capture/compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC3 channel is configured as output.\n01: CC3 channel is configured as input, IC3 is mapped on TI3.\n10: CC3 channel is configured as input, IC3 is mapped on TI4.\n11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).\nBits 15:14Reserved, always read as 0.\nBit 13CC4P: Capture/Compare 4 output polarity\nrefer to CC1P description\nBit 12CC4E: Capture/Compare 4 output enable\nrefer to CC1E description\nBit 11CC3NP: Capture/Compare 3 complementary output polarity\nrefer to CC1NP description\nBit 10CC3NE: Capture/Compare 3 complementary output enable\nrefer to CC1NE description\nBit 9CC3P: Capture/Compare 3 output polarity\nrefer to CC1P description\nBit 8CC3E: Capture/Compare 3 output enable\nrefer to CC1E description\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9309/995\nBit 7CC2NP: Capture/Compare 2 complementary output polarity\nrefer to CC1NP description\nBit 6CC2NE: Capture/Compare 2 complementary output enable\nrefer to CC1NE description\nBit 5CC2P: Capture/Compare 2 output polarity\nrefer to CC1P description\nBit 4CC2E: Capture/Compare 2 output enable\nrefer to CC1E description\nBit 3CC1NP: Capture/Compare 1 complementary output polarity\n0: OC1N active high.\n1: OC1N active low.\nNote:This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits\nin TIMx_BDTR register) and CC1S=”00” (the channel is configured in output).\nBit 2CC1NE: Capture/Compare 1 complementary output enable\n0: Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N\nand CC1E bits.\n1: On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI,\nOSSR, OIS1, OIS1N and CC1E bits.\nBit 1CC1P: Capture/Compare 1 output polarity\nCC1 channel configured as output:\n0: OC1 active high.\n1: OC1 active low.\nCC1 channel configured as input:\nThis bit selects whether IC1 or IC1 is used for trigger or capture operations.\n0: non-inverted: capture is done on a rising edge of IC1. When used as external trigger, IC1\nis non-inverted.\n1: inverted: capture is done on a falling edge of IC1. When used as external trigger, IC1 is\nNote:This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits\nin TIMx_BDTR register).\nBit 0CC1E: Capture/Compare 1 output enable\nCC1 channel configured as output:\n0: Off - OC1 is not active. OC1 level is then function of MOE, OSSI, OSSR, OIS1, OIS1N\nand CC1NE bits.\n1: On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI,\nOSSR, OIS1, OIS1N and CC1NE bits.\nCC1 channel configured as input:\nThis bit determines if a capture of the counter value can actually be done into the input\ncapture/compare register 1 (TIMx_CCR1) or not.\n0: Capture disabled.\n1: Capture enabled.\nAdvanced-control timers (TIM1&TIM8)RM0008\n310/995 Doc ID 13902 Rev 9\nNote:The state of the external I/O pins connected to the complementary OCx and OCxN\nchannels depends on the OCx and OCxN channel state and the GPIO and AFIO registers.\nTable 73.Output control bits for complementary OCx and OCxN channels with\nbreak feature\nControl bitsOutput states(1)\n1.When both outputs of a channel are not used (CCxE = CCxNE = 0), the OISx, OISxN, CCxP and CCxNP\nbits must be kept cleared.\nOCx output stateOCxN output state\nOutput Disabled (not\ndriven by the timer)\nOCx=0, OCx_EN=0\nOutput Disabled (not driven by\nthe timer)\nOCxN=0, OCxN_EN=0\nOutput Disabled (not\ndriven by the timer)\nOCx=0, OCx_EN=0\nOCxREF + Polarity\nOCxN=OCxREF xor CCxNP,\nOCxREF + Polarity\nOCx=OCxREF xor CCxP,\nOutput Disabled (not driven by\nthe timer)\nOCxN=0, OCxN_EN=0\nOCREF + Polarity + dead-\nComplementary to OCREF (not\nOCREF) + Polarity + dead-time\nOutput Disabled (not\ndriven by the timer)\nOCx=CCxP, OCx_EN=0\nOutput Disabled (not driven by\nthe timer)\nOCxN=CCxNP, OCxN_EN=0\nOff-State (output enabled\nwith inactive state)\nOCx=CCxP, OCx_EN=1\nOCxREF + Polarity\nOCxN=OCxREF xor CCxNP,\nOCxREF + Polarity\nOCx=OCxREF xor CCxP,\nOff-State (output enabled with\ninactive state)\nOCxN=CCxNP, OCxN_EN=1\nOCREF + Polarity + dead-\nComplementary to OCREF (not\nOCREF) + Polarity + dead-time\nOutput Disabled (not driven by the timer)\nAsynchronously: OCx=CCxP, OCx_EN=0, OCxN=CCxNP,\nThen if the clock is present: OCx=OISx and OCxN=OISxN\nafter a dead-time, assuming that OISx and OISxN do not\ncorrespond to OCX and OCxN both in active state.\n101Off-State (output enabled with inactive state)\nAsynchronously: OCx=CCxP, OCx_EN=1, OCxN=CCxNP,\nThen if the clock is present: OCx=OISx and OCxN=OISxN\nafter a dead-time, assuming that OISx and OISxN do not\ncorrespond to OCX and OCxN both in active state\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9311/995\n13.4.10 TIM1&TIM8 counter (TIMx_CNT)\nAddress offset: 0x24\nReset value: 0x0000\n13.4.11 TIM1&TIM8 prescaler (TIMx_PSC)\nAddress offset: 0x28\nReset value: 0x0000"
  },
  {
    "start_page": 311,
    "end_page": 312,
    "page_range": "311-312",
    "section": "13.4.12",
    "full_name": "TIM1&TIM8 auto-reload register (TIMx_ARR)",
    "short_name": "",
    "address_offset": "0x2C",
    "reset_value": "0x0000",
    "content": "Bits 15:0CNT[15:0]: Counter value\nBits 15:0PSC[15:0]: Prescaler value\nThe counter clock frequency (CK_CNT) is equal to f\n/ (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event\n(including when the counter is cleared through UG bit of TIMx_EGR register or through trigger\ncontroller when configured in “reset mode”).\nBits 15:0ARR[15:0]: Prescaler value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section13.3.1: Time-base unit on page256 for more details about ARR update\nand behavior.\nThe counter is blocked while the auto-reload value is null.\nAdvanced-control timers (TIM1&TIM8)RM0008\n312/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 312,
    "end_page": 312,
    "page_range": "312",
    "section": "13.4.13",
    "full_name": "TIM1&TIM8 repetition counter register (TIMx_RCR)",
    "short_name": "",
    "address_offset": "0x30",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 312,
    "end_page": 313,
    "page_range": "312-313",
    "section": "13.4.14",
    "full_name": "TIM1&TIM8 capture/compare register 1 (TIMx_CCR1)",
    "short_name": "",
    "address_offset": "0x34",
    "reset_value": "0x0000",
    "content": "Bits 15:8Reserved, always read as 0.\nBits 7:0REP[7:0]: Repetition counter value\nThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic\ntransfers from preload to active registers) when preload registers are enable, as well as the\nupdate interrupt generation rate, if this interrupt is enable.\nEach time the REP_CNT related downcounter reaches zero, an update event is generated and\nit restarts counting from REP value. As REP_CNT is reloaded with REP value only at the\nrepetition update event U_RC, any write to the TIMx_RCR register is not taken in account until\nthe next repetition update event.\nIt means in PWM mode (REP+1) corresponds to:\n–the number of PWM periods in edge-aligned mode\n–the number of half PWM period in center-aligned mode.\nBits 15:0CCR1[15:0]: Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit\nOC1PE). Else the preload value is copied in the active capture/compare 1 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input:\nCCR1 is the counter value transferred by the last input capture 1 event (IC1).\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9313/995"
  },
  {
    "start_page": 313,
    "end_page": 313,
    "page_range": "313",
    "section": "13.4.15",
    "full_name": "TIM1&TIM8 capture/compare register 2 (TIMx_CCR2)",
    "short_name": "",
    "address_offset": "0x38",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 313,
    "end_page": 314,
    "page_range": "313-314",
    "section": "13.4.16",
    "full_name": "TIM1&TIM8 capture/compare register 3 (TIMx_CCR3)",
    "short_name": "",
    "address_offset": "0x3C",
    "reset_value": "0x0000",
    "content": "Bits 15:0CCR2[15:0]: Capture/Compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit\nOC2PE). Else the preload value is copied in the active capture/compare 2 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 is the counter value transferred by the last input capture 2 event (IC2).\nBits 15:0CCR3[15:0]: Capture/Compare value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit\nOC3PE). Else the preload value is copied in the active capture/compare 3 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC3 output.\nIf channel CC3 is configured as input:\nCCR3 is the counter value transferred by the last input capture 3 event (IC3).\nAdvanced-control timers (TIM1&TIM8)RM0008\n314/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 314,
    "end_page": 314,
    "page_range": "314",
    "section": "13.4.17",
    "full_name": "TIM1&TIM8 capture/compare register 4 (TIMx_CCR4)",
    "short_name": "",
    "address_offset": "0x40",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 314,
    "end_page": 316,
    "page_range": "314-316",
    "section": "13.4.18",
    "full_name": "TIM1&TIM8 break and dead-time register (TIMx_BDTR)",
    "short_name": "",
    "address_offset": "0x44",
    "reset_value": "0x0000",
    "content": "Note:As the bits AOE, BKP, BKE, OSSI, OSSR and DTG[7:0] can be write-locked depending on\nthe LOCK configuration, it can be necessary to configure all of them during the first write\naccess to the TIMx_BDTR register.\nBits 15:0CCR4[15:0]: Capture/Compare value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit\nOC4PE). Else the preload value is copied in the active capture/compare 4 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC4 output.\nIf channel CC4 is configured as input:\nCCR4 is the counter value transferred by the last input capture 4 event (IC4).\nBit 15MOE: Main output enable\nThis bit is cleared asynchronously by hardware as soon as the break input is active. It is set\nby software or automatically depending on the AOE bit. It is acting only on the channels\nwhich are configured in output.\n0: OC and OCN outputs are disabled or forced to idle state.\n1: OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in\nTIMx_CCER register).\nSee OC/OCN enable description for more details (Section13.4.9: TIM1&TIM8\ncapture/compare enable register (TIMx_CCER) on page308).\nBit 14AOE: Automatic output enable\n0: MOE can be set only by software\n1: MOE can be set by software or automatically at the next update event (if the break input is\nnot be active)\nNote:This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits\nin TIMx_BDTR register).\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9315/995\nBit 13BKP: Break polarity\n0: Break input BRK is active low\n1: Break input BRK is active high\nNote:This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits\nin TIMx_BDTR register).\nNote:Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\nBit 12BKE: Break enable\n0: Break inputs (BRK and CCS clock failure event) disabled\n1; Break inputs (BRK and CCS clock failure event) enabled\nNote:This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in\nTIMx_BDTR register).\nNote:Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.\nBit 11OSSR: Off-state selection for Run mode\nThis bit is used when MOE=1 on channels having a complementary output which are\nconfigured as outputs. OSSR is not implemented if no complementary output is implemented\nin the timer.\nSee OC/OCN enable description for more details (Section13.4.9: TIM1&TIM8\ncapture/compare enable register (TIMx_CCER) on page308).\n0: When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0).\n1: When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1\nor CCxNE=1. Then, OC/OCN enable output signal=1\nNote:This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK\nbits in TIMx_BDTR register).\nBit 10OSSI: Off-state selection for Idle mode\nThis bit is used when MOE=0 on channels configured as outputs.\nSee OC/OCN enable description for more details (Section13.4.9: TIM1&TIM8\ncapture/compare enable register (TIMx_CCER) on page308).\n0: When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0).\n1: When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or\nCCxNE=1. OC/OCN enable output signal=1)\nNote:This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK\nbits in TIMx_BDTR register).\nBits 9:8LOCK[1:0]: Lock configuration\nThese bits offer a write protection against software errors.\n00: LOCK OFF - No bit is write protected.\n01: LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits in TIMx_CR2\nregister and BKE/BKP/AOE bits in TIMx_BDTR register can no longer be written.\n10: LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits in TIMx_CCER\nregister, as long as the related channel is configured in output through the CCxS bits) as well\nas OSSR and OSSI bits can no longer be written.\n11: LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in\nTIMx_CCMRx registers, as long as the related channel is configured in output through the\nCCxS bits) can no longer be written.\nNote:The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register\nhas been written, their content is frozen until the next reset.\nAdvanced-control timers (TIM1&TIM8)RM0008\n316/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 316,
    "end_page": 317,
    "page_range": "316-317",
    "section": "13.4.19",
    "full_name": "TIM1&TIM8 DMA control register (TIMx_DCR)",
    "short_name": "",
    "address_offset": "0x48",
    "reset_value": "0x0000",
    "content": "Bits 7:0DTG[7:0]: Dead-time generator setup\nThis bit-field defines the duration of the dead-time inserted between the complementary\noutputs. DT correspond to this duration.\nDTG[7:5]=0xx => DT=DTG[7:0]x t\nwith t\nDTG[7:5]=10x => DT=(64+DTG[5:0])xt\nwith T\nDTG[7:5]=110 => DT=(32+DTG[4:0])xt\nwith T\nDTG[7:5]=111 => DT=(32+DTG[4:0])xt\nwith T\nExample if T\n=125ns (8MHz), dead-time possible values are:\n0 to 15875 ns by 125 ns steps,\n16 us to 31750 ns by 250 ns steps,\n32 us to 63us by 1 us steps,\n64 us to 126 us by 2 us steps\nNote:This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed\n(LOCK bits in TIMx_BDTR register).\nBits 15:13Reserved, always read as 0\nBits 12:8DBL[4:0]: DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer\nwhen a read or a write access is done to the TIMx_DMAR address), i.e. the number of\ntransfers. Transfers can be in half-words or in bytes (see example below).\n00000: 1 transfer,\n00001: 2 transfers,\n00010: 3 transfers,\n10001: 18 transfers.\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\n–If DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred,\nthe address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address\nfrom/to which the data will be copied. In this case, the transfer is done to 7 registers starting\nfrom the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\n–If you configure the DMA Data Size in half-words, 16-bit data will be transferred to each of\nthe 7 registers.\n–If you configure the DMA Data Size in bytes, the data will aslo be transferred to 7 registers:\nthe first register will contain the first MSB byte, the second register, the first LSB byte and so\non. So with the transfer Timer, you also have to specify the size of data transferred by DMA.\nBits 7:5Reserved, always read as 0\nRM0008Advanced-control timers (TIM1&TIM8)\nDoc ID 13902 Rev 9317/995\n13.4.20 TIM1&TIM8 DMA address for full transfer (TIMx_DMAR)\nAddress offset: 0x4C\nReset value: 0x0000"
  },
  {
    "start_page": 355,
    "end_page": 356,
    "page_range": "355-356",
    "section": "14.4.1",
    "full_name": "TIMx control register 1 (TIMx_CR1)",
    "short_name": "",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Bits 15:10Reserved, always read as 0\nBits 9:8CKD: Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and\nsampling clock used by the digital filters (ETR, TIx),\n00: t\n= t\n01: t\n= 2 × t\n10: t\n= 4 × t\n11: Reserved\nBit 7ARPE: Auto-reload preload enable\n0: TIMx_ARR register is not buffered.\n1: TIMx_ARR register is buffered.\nBits 6:5CMS: Center-aligned mode selection\n00: Edge-aligned mode. The counter counts up or down depending on the direction bit\n01: Center-aligned mode 1. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nonly when the counter is counting down.\n10: Center-aligned mode 2. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nonly when the counter is counting up.\n11: Center-aligned mode 3. The counter counts up and down alternatively. Output compare\ninterrupt flags of channels configured in output (CCxS=00 in TIMx_CCMRx register) are set\nboth when the counter is counting up or down.\nNote:It is not allowed to switch from edge-aligned mode to center-aligned mode as long as\nthe counter is enabled (CEN=1)\nBit 4DIR: Direction\n0: Counter used as upcounter.\n1: Counter used as downcounter.\nNote:This bit is read only when the timer is configured in Center-aligned mode or Encoder\nBit 3OPM: One pulse mode\n0: Counter is not stopped at update event\n1: Counter stops counting at the next update event (clearing the bit CEN).\nGeneral-purpose timer (TIMx)RM0008\n356/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 356,
    "end_page": 357,
    "page_range": "356-357",
    "section": "14.4.2",
    "full_name": "TIMx control register 2 (TIMx_CR2)",
    "short_name": "",
    "address_offset": "0x04",
    "reset_value": "0x0000",
    "content": "Bit 2URS: Update request source\nThis bit is set and cleared by software to select the UEV event sources.\n0: Any of the following events generate an update interrupt or DMA request if enabled.\nThese events can be:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\n1: Only counter overflow/underflow generates an update interrupt or DMA request if enabled.\nBit 1UDIS: Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\n0: UEV enabled. The Update (UEV) event is generated by one of the following events:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\nBuffered registers are then loaded with their preload values.\n1: UEV disabled. The Update event is not generated, shadow registers keep their value\n(ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit is\nset or if a hardware reset is received from the slave mode controller.\nBit 0CEN: Counter enable\n0: Counter disabled\n1: Counter enabled\nNote:External clock, gated mode and encoder mode can work only if the CEN bit has been\npreviously set by software. However trigger mode can set the CEN bit automatically by\nCEN is cleared automatically in one pulse mode, when an update event occurs.\nBits 15:8Reserved, always read as 0.\nBit 7TI1S: TI1 selection\n0: The TIMx_CH1 pin is connected to TI1 input.\n1: The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input (XOR combination)\nSee also Section13.3.18: Interfacing with Hall sensors on page288\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9357/995"
  },
  {
    "start_page": 357,
    "end_page": 360,
    "page_range": "357-360",
    "section": "14.4.3",
    "full_name": "TIMx slave mode control register (TIMx_SMCR)",
    "short_name": "",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": "Bits 6:4MMS: Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for\nsynchronization (TRGO). The combination is as follows:\n000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the\nreset is generated by the trigger input (slave mode controller configured in reset mode) then\nthe signal on TRGO is delayed compared to the actual reset.\n001: Enable - the Counter enable signal, CNT_EN, is used as trigger output (TRGO). It is\nuseful to start several timers at the same time or to control a window in which a slave timer is\nenabled. The Counter Enable signal is generated by a logic OR between CEN control bit and\nthe trigger input when configured in gated mode.\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO,\nexcept if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR\n010: Update - The update event is selected as trigger output (TRGO). For instance a master\ntimer can then be used as a prescaler for a slave timer.\n011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be\nset (even if it was already high), as soon as a capture or a compare match occurred.\n100: Compare - OC1REF signal is used as trigger output (TRGO).\n101: Compare - OC2REF signal is used as trigger output (TRGO).\n110: Compare - OC3REF signal is used as trigger output (TRGO).\n111: Compare - OC4REF signal is used as trigger output (TRGO).\nBit 3CCDS: Capture/compare DMA selection\n0: CCx DMA request sent when CCx event occurs\n1: CCx DMA requests sent when update event occurs\nBits 2:0Reserved, always read as 0\nBit 15ETP: External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations\n0: ETR is non-inverted, active at high level or rising edge.\n1: ETR is inverted, active at low level or falling edge.\nGeneral-purpose timer (TIMx)RM0008\n358/995 Doc ID 13902 Rev 9\nBit 14ECE: External clock enable\nThis bit enables External clock mode 2.\n0: External clock mode 2 disabled.\n1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF\n1: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI\nconnected to ETRF (SMS=111 and TS=111).\n2: It is possible to simultaneously use external clock mode 2 with the following slave modes:\nreset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to\nETRF in this case (TS bits must not be 111).\n3: If external clock mode 1 and external clock mode 2 are enabled at the same time, the\nexternal clock input is ETRF.\nBits 13:12ETPS: External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A\nprescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external\n00: Prescaler OFF.\n01: ETRP frequency divided by 2.\n10: ETRP frequency divided by 4.\n11: ETRP frequency divided by 8.\nBits 11:8ETF[3:0]: External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the\ndigital filter applied to ETRP. The digital filter is made of an event counter in which N events\nare needed to validate a transition on the output:\n0000: No filter, sampling is done at f\n0001:   f\n, N=2.\n0010:   f\n, N=4.\n0011:   f\n, N=8.\n0100:   f\n/2, N=6.\n0101:   f\n/2, N=8.\n0110:   f\n/4, N=6.\n0111:   f\n/4, N=8.\n1000:   f\n/8, N=6.\n1001:   f\n/8, N=8.\n1010:   f\n/16, N=5.\n1011:   f\n/16, N=6.\n1100:   f\n/16, N=8.\n1101:   f\n/32, N=5.\n1110:   f\n/32, N=6.\n1111:   f\n/32, N=8.\nBit 7MSM: Master/Slave mode\n0: No action\n1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect\nsynchronization between the current timer and its slaves (through TRGO). It is useful if we\nwant to synchronize several timers on a single external event.\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9359/995\nBits 6:4TS: Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\n000: Internal Trigger 0 (ITR0). TIM1\n001: Internal Trigger 1 (ITR1). TIM2\n010: Internal Trigger 2 (ITR2). TIM3\n011: Internal Trigger 3 (ITR3). TIM4\n100: TI1 Edge Detector (TI1F_ED).\n101: Filtered Timer Input 1 (TI1FP1).\n110: Filtered Timer Input 2 (TI2FP2).\n111: External Trigger input (ETRF).\nSee Table76: TIMx Internal trigger connection on page359 for more details on ITRx\nmeaning for each Timer.\nNote:These bits must be changed only when they are not used (e.g. when SMS=000) to\navoid wrong edge detections at the transition.\nBit 3Reserved, always read as 0.\nBits 2:0SMS: Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to\nthe polarity selected on the external input (see Input Control register and Control Register\n000: Slave mode disabled - if CEN = ‘1’ then the prescaler is clocked directly by the internal\n001: Encoder mode 1 - Counter counts up/down on TI2FP2 edge depending on TI1FP1\n010: Encoder mode 2 - Counter counts up/down on TI1FP1 edge depending on TI2FP2\n011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges\ndepending on the level of the other input.\n100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter\nand generates an update of the registers.\n101: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The\ncounter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of\nthe counter are controlled.\n110: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not\nreset). Only the start of the counter is controlled.\n111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.\nNote:The gated mode must not be used if TI1F_ED is selected as the trigger input\n(TS=’100’). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the\ngated mode checks the level of the trigger signal.\nTable 76.TIMx Internal trigger connection\n1.When a timer is not present in the product, the corresponding trigger ITRx is not available.\nSlave TIMITR0 (TS = 000)ITR1 (TS = 001)ITR2 (TS = 010)ITR3 (TS = 011)\nGeneral-purpose timer (TIMx)RM0008\n360/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 360,
    "end_page": 361,
    "page_range": "360-361",
    "section": "14.4.4",
    "full_name": "TIMx DMA/Interrupt enable register (TIMx_DIER)",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bit 15Reserved, always read as 0.\nBit 14TDE: Trigger DMA request enable\n0: Trigger DMA request disabled.\n1: Trigger DMA request enabled.\nBit 13Reserved, always read as 0\nBit 12CC4DE: Capture/Compare 4 DMA request enable\n0: CC4 DMA request disabled.\n1: CC4 DMA request enabled.\nBit 11CC3DE: Capture/Compare 3 DMA request enable\n0: CC3 DMA request disabled.\n1: CC3 DMA request enabled.\nBit 10CC2DE: Capture/Compare 2 DMA request enable\n0: CC2 DMA request disabled.\n1: CC2 DMA request enabled.\nBit 9CC1DE: Capture/Compare 1 DMA request enable\n0: CC1 DMA request disabled.\n1: CC1 DMA request enabled.\nBit 8UDE: Update DMA request enable\n0: Update DMA request disabled.\n1: Update DMA request enabled.\nBit 7Reserved, always read as 0.\nBit 6TIE: Trigger interrupt enable\n0: Trigger interrupt disabled.\n1: Trigger interrupt enabled.\nBit 5Reserved, always read as 0.\nBit 4CC4IE: Capture/Compare 4 interrupt enable\n0: CC4 interrupt disabled.\n1: CC4 interrupt enabled.\nBit 3CC3IE: Capture/Compare 3 interrupt enable\n0: CC3 interrupt disabled.\n1: CC3 interrupt enabled.\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9361/995"
  },
  {
    "start_page": 361,
    "end_page": 362,
    "page_range": "361-362",
    "section": "14.4.5",
    "full_name": "TIMx status register (TIMx_SR)",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": "Bit 2CC2IE: Capture/Compare 2 interrupt enable\n0: CC2 interrupt disabled.\n1: CC2 interrupt enabled.\nBit 1CC1IE: Capture/Compare 1 interrupt enable\n0: CC1 interrupt disabled.\n1: CC1 interrupt enabled.\nBit 0UIE: Update interrupt enable\n0: Update interrupt disabled.\n1: Update interrupt enabled.\nBit 15:13Reserved, always read as 0.\nBit 12CC4OF: Capture/Compare 4 overcapture flag\nrefer to CC1OF description\nBit 11CC3OF: Capture/Compare 3 overcapture flag\nrefer to CC1OF description\nBit 10CC2OF: Capture/compare 2 overcapture flag\nrefer to CC1OF description\nBit 9CC1OF: Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input\ncapture mode. It is cleared by software by writing it to ‘0’.\n0: No overcapture has been detected.\n1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was\nalready set\nBits 8:7Reserved, always read as 0.\nBit 6TIF: Trigger interrupt flag\nThis flag is set by hardware on trigger event (active edge detected on TRGI input when the\nslave mode controller is enabled in all modes but gated mode, both edges in case gated\nmode is selected). It is cleared by software.\n0: No trigger event occurred.\n1: Trigger interrupt pending.\nBit 5Reserved, always read as 0\nBit 4CC4IF: Capture/Compare 4 interrupt flag\nrefer to CC1IF description\nBit 3CC3IF: Capture/Compare 3 interrupt flag\nrefer to CC1IF description\nGeneral-purpose timer (TIMx)RM0008\n362/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 362,
    "end_page": 363,
    "page_range": "362-363",
    "section": "14.4.6",
    "full_name": "TIMx event generation register (TIMx_EGR)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "Bit 2CC2IF: Capture/Compare 2 interrupt flag\nrefer to CC1IF description\nBit 1CC1IF: Capture/compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThis flag is set by hardware when the counter matches the compare value, with some\nexception in center-aligned mode (refer to the CMS bits in the TIMx_CR1 register\ndescription). It is cleared by software.\n0: No match.\n1: The content of the counter TIMx_CNT has matched the content of the TIMx_CCR1\nIf channel CC1 is configured as input:\nThis bit is set by hardware on a capture. It is cleared by software or by reading the\nTIMx_CCR1 register.\n0: No input capture occurred.\n1: The counter value has been captured in TIMx_CCR1 register (An edge has been\ndetected on IC1 which matches the selected polarity).\nBit 0UIF: Update interrupt flag\n–This bit is set by hardware on an update event. It is cleared by software.\n0: No update occurred.\n1: Update interrupt pending. This bit is set by hardware when the registers are updated:\n–At overflow or underflow regarding the repetition counter value (update if repetition\ncounter = 0) and if the UDIS=0 in the TIMx_CR1 register.\n–When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0\nand UDIS=0 in the TIMx_CR1 register.\n–When CNT is reinitialized by a trigger event (refer to the synchro control register\ndescription), if URS=0 and UDIS=0 in the TIMx_CR1 register.\nBits 15:7Reserved, always read as 0.\nBit 6TG: Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by\n0: No action.\n1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if\nBit 5Reserved, always read as 0.\nBit 4CC4G: Capture/compare 4 generation\nrefer to CC1G description\nBit 3CC3G: Capture/compare 3 generation\nrefer to CC1G description\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9363/995"
  },
  {
    "start_page": 363,
    "end_page": 367,
    "page_range": "363-367",
    "section": "14.4.7",
    "full_name": "TIMx capture/compare mode register 1 (TIMx_CCMR1)",
    "short_name": "",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": "The channels can be used in input (capture mode) or in output (compare mode). The\ndirection of a channel is defined by configuring the corresponding CCxS bits. All the other\nbits of this register have a different function in input and in output mode. For a given bit,\nOCxx describes its function when the channel is configured in output, ICxx describes its\nfunction when the channel is configured in input. So you must take care that the same bit\ncan have a different meaning for the input stage and for the output stage.\nOutput compare mode\nBit 2CC2G: Capture/compare 2 generation\nrefer to CC1G description\nBit 1CC1G: Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by\n0: No action.\n1: A capture/compare event is generated on channel 1:\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set,\nthe corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the\nCC1IF flag was already high.\nBit 0UG: Update generation\nThis bit can be set by software, it is automatically cleared by hardware.\n0: No action.\n1: Re-initialize the counter and generates an update of the registers. Note that the prescaler\ncounter is cleared too (anyway the prescaler ratio is not affected). The counter is cleared if\nthe center-aligned mode is selected or if DIR=0 (upcounting), else it takes the auto-reload\nvalue (TIMx_ARR) if DIR=1 (downcounting).\nBit 15OC2CE: Output compare 2 clear enable\nBits 14:12OC2M[2:0]: Output compare 2 mode\nBit 11OC2PE: Output compare 2 preload enable\nBit 10OC2FE: Output compare 2 fast enable\nGeneral-purpose timer (TIMx)RM0008\n364/995 Doc ID 13902 Rev 9\nBits 9:8CC2S[1:0]: Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC2 channel is configured as output.\n01: CC2 channel is configured as input, IC2 is mapped on TI2.\n10: CC2 channel is configured as input, IC2 is mapped on TI1.\n11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through the TS bit (TIMx_SMCR register)\nNote:CC2S bits are writable only when the channel is OFF (CC2E = ’0’ in TIMx_CCER).\nBit 7OC1CE: Output compare 1 clear enable\nOC1CE: Output Compare 1 Clear Enable\n0: OC1Ref is not affected by the ETRF input\n1: OC1Ref is cleared as soon as a High level is detected on ETRF input\nBits 6:4OC1M: Output compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and\nOC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends\non CC1P and CC1NP bits.\n000: Frozen - The comparison between the output compare register TIMx_CCR1 and the\ncounter TIMx_CNT has no effect on the outputs.\n001: Set channel 1 to active level on match. OC1REF signal is forced high when the counter\nTIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n010: Set channel 1 to inactive level on match. OC1REF signal is forced low when the\ncounter TIMx_CNT matches the capture/compare register 1 (TIMx_CCR1).\n011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.\n100: Force inactive level - OC1REF is forced low.\n101: Force active level - OC1REF is forced high.\n110: PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1\nelse inactive. In downcounting, channel 1 is inactive (OC1REF=‘0’) as long as\nTIMx_CNT>TIMx_CCR1 else active (OC1REF=’1’).\n111: PWM mode 2 - In upcounting, channel 1 is inactive as long as\nTIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as long as\nTIMx_CNT>TIMx_CCR1 else inactive.\nNote:1: These bits can not be modified as long as LOCK level 3 has been programmed\n(LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in\n2: In PWM mode 1 or 2, the OCREF level changes only when the result of the\ncomparison changes or when the output compare mode switches from “frozen” mode\nto “PWM” mode.\nBit 3OC1PE: Output compare 1 preload enable\n0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the\nnew value is taken in account immediately.\n1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload\nregister. TIMx_CCR1 preload value is loaded in the active register at each update event.\nNote:1: These bits can not be modified as long as LOCK level 3 has been programmed\n(LOCK bits in TIMx_BDTR register) and CC1S=’00’ (the channel is configured in\n2: The PWM mode can be used without validating the preload register only in one\npulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9365/995\nInput capture mode\nBit 2OC1FE: Output compare 1 fast enable\nThis bit is used to accelerate the effect of an event on the trigger in input on the CC output.\n0: CC1 behaves normally depending on counter and CCR1 values even when the trigger is\nON. The minimum delay to activate CC1 output when an edge occurs on the trigger input is\n5 clock cycles.\n1: An active edge on the trigger input acts like a compare match on CC1 output. Then, OC\nis set to the compare level independently from the result of the comparison. Delay to sample\nthe trigger input and to activate CC1 output is reduced to 3 clock cycles. OCFE acts only if\nthe channel is configured in PWM1 or PWM2 mode.\nBits 1:0CC1S: Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC1 channel is configured as output.\n01: CC1 channel is configured as input, IC1 is mapped on TI1.\n10: CC1 channel is configured as input, IC1 is mapped on TI2.\n11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC1S bits are writable only when the channel is OFF (CC1E = ’0’ in TIMx_CCER).\nBits 15:12IC2F: Input capture 2 filter\nBits 11:10IC2PSC[1:0]: Input capture 2 prescaler\nBits 9:8CC2S: Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC2 channel is configured as output.\n01: CC2 channel is configured as input, IC2 is mapped on TI2.\n10: CC2 channel is configured as input, IC2 is mapped on TI1.\n11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC2S bits are writable only when the channel is OFF (CC2E = ’0’ in TIMx_CCER).\nGeneral-purpose timer (TIMx)RM0008\n366/995 Doc ID 13902 Rev 9\nBits 7:4IC1F: Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital\nfilter applied to TI1. The digital filter is made of an event counter in which N events are\nneeded to validate a transition on the output:\n0000: No filter, sampling is done at f\n0001: f\n, N=2.\n0010: f\n, N=4.\n0011: f\n, N=8.\n0100: f\n/2, N=6.\n0101: f\n/2, N=8.\n0110: f\n/4, N=6.\n0111: f\n/4, N=8.\n1000: f\n/8, N=6.\n1001: f\n/8, N=8.\n1010: f\n/16, N=5.\n1011: f\n/16, N=6.\n1100: f\n/16, N=8.\n1101: f\n/32, N=5.\n1110: f\n/32, N=6.\n1111: f\n/32, N=8.\nNote:In current silicon revision, f\nis replaced in the formula by CK_INT when ICxF[3:0]=\n1, 2 or 3.\nBits 3:2IC1PSC: Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1).\nThe prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).\n00: no prescaler, capture is done each time an edge is detected on the capture input.\n01: capture is done once every 2 events.\n10: capture is done once every 4 events.\n11: capture is done once every 8 events.\nBits 1:0CC1S: Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC1 channel is configured as output.\n01: CC1 channel is configured as input, IC1 is mapped on TI1.\n10: CC1 channel is configured as input, IC1 is mapped on TI2.\n11: CC1 channel is configured as input, IC1 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC1S bits are writable only when the channel is OFF (CC1E = ’0’ in TIMx_CCER).\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9367/995"
  },
  {
    "start_page": 367,
    "end_page": 368,
    "page_range": "367-368",
    "section": "14.4.8",
    "full_name": "Capture/compare mode register 2 (TIMx_CCMR2)",
    "short_name": "",
    "address_offset": "0x1C",
    "reset_value": "0x0000",
    "content": "Refer to the above CCMR1 register description.\nOutput compare mode\nBit 15OC4CE: Output compare 4 clear enable\nBits 14:12OC4M: Output compare 4 mode\nBit 11OC4PE: Output compare 4 preload enable\nBit 10OC4FE: Output compare 4 fast enable\nBits 9:8CC4S: Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC4 channel is configured as output.\n01: CC4 channel is configured as input, IC4 is mapped on TI4.\n10: CC4 channel is configured as input, IC4 is mapped on TI3.\n11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC4S bits are writable only when the channel is OFF (CC4E = ’0’ in TIMx_CCER).\nBit 7OC3CE: Output compare 3 clear enable\nBits 6:4OC3M: Output compare 3 mode\nBit 3OC3PE: Output compare 3 preload enable\nBit 2OC3FE: Output compare 3 fast enable\nBits 1:0CC3S: Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC3 channel is configured as output.\n01: CC3 channel is configured as input, IC3 is mapped on TI3.\n10: CC3 channel is configured as input, IC3 is mapped on TI4.\n11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only if\nan internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC3S bits are writable only when the channel is OFF (CC3E = ’0’ in TIMx_CCER).\nGeneral-purpose timer (TIMx)RM0008\n368/995 Doc ID 13902 Rev 9\nInput capture mode"
  },
  {
    "start_page": 368,
    "end_page": 370,
    "page_range": "368-370",
    "section": "14.4.9",
    "full_name": "TIMx capture/compare enable register (TIMx_CCER)",
    "short_name": "",
    "address_offset": "0x20",
    "reset_value": "0x0000",
    "content": "Bits 15:12IC4F: Input capture 4 filter\nBits 11:10IC4PSC: Input capture 4 prescaler\nBits 9:8CC4S: Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC4 channel is configured as output.\n01: CC4 channel is configured as input, IC4 is mapped on TI4.\n10: CC4 channel is configured as input, IC4 is mapped on TI3.\n11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC4S bits are writable only when the channel is OFF (CC4E = ’0’ in TIMx_CCER).\nBits 7:4IC3F: Input capture 3 filter\nBits 3:2IC3PSC: Input capture 3 prescaler\nBits 1:0CC3S: Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n00: CC3 channel is configured as output.\n01: CC3 channel is configured as input, IC3 is mapped on TI3.\n10: CC3 channel is configured as input, IC3 is mapped on TI4.\n11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode is working only\nif an internal trigger input is selected through TS bit (TIMx_SMCR register)\nNote:CC3S bits are writable only when the channel is OFF (CC3E = ’0’ in TIMx_CCER).\nBits 15:14Reserved, always read as 0.\nBit 13CC4P: Capture/Compare 4 output polarity\nrefer to CC1P description\nBit 12CC4E: Capture/Compare 4 output enable\nrefer to CC1E description\nBits 11:10Reserved, always read as 0.\nBit 9CC3P: Capture/Compare 3 output polarity\nrefer to CC1P description\nBit 8CC3E: Capture/Compare 3 output enable\nrefer to CC1E description\nBits 7:6Reserved, always read as 0.\nBit 5CC2P: Capture/Compare 2 output polarity\nrefer to CC1P description\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9369/995\nNote:The state of the external I/O pins connected to the standard OCx channels depends on the\nOCx channel state and the GPIO and AFIO registers.\n14.4.10 TIMx counter (TIMx_CNT)\nAddress offset: 0x24\nReset value: 0x0000\nBit 4CC2E: Capture/Compare 2 output enable\nrefer to CC1E description\nBits 3:2Reserved, always read as 0.\nBit 1CC1P: Capture/Compare 1 output polarity\nCC1 channel configured as output:\n0: OC1 active high.\n1: OC1 active low.\nCC1 channel configured as input:\nThis bit selects whether IC1 or IC1 is used for trigger or capture operations.\n0: non-inverted: capture is done on a rising edge of IC1. When used as external trigger, IC1\nis non-inverted.\n1: inverted: capture is done on a falling edge of IC1. When used as external trigger, IC1 is\nBit 0CC1E: Capture/Compare 1 output enable\nCC1 channel configured as output:\n0: Off - OC1 is not active.\n1: On - OC1 signal is output on the corresponding output pin.\nCC1 channel configured as input:\nThis bit determines if a capture of the counter value can actually be done into the input\ncapture/compare register 1 (TIMx_CCR1) or not.\n0: Capture disabled.\n1: Capture enabled.\nTable 77.Output control bit for standard OCx channels\nCCxE bitOCx output state\n0Output Disabled (OCx=0, OCx_EN=0)\n1OCx=OCxREF + Polarity, OCx_EN=1\nBits 15:0CNT[15:0]: Counter value\nGeneral-purpose timer (TIMx)RM0008\n370/995 Doc ID 13902 Rev 9\n14.4.11 TIMx prescaler (TIMx_PSC)\nAddress offset: 0x28\nReset value: 0x0000"
  },
  {
    "start_page": 370,
    "end_page": 370,
    "page_range": "370",
    "section": "14.4.12",
    "full_name": "TIMx auto-reload register (TIMx_ARR)",
    "short_name": "",
    "address_offset": "0x2C",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 370,
    "end_page": 371,
    "page_range": "370-371",
    "section": "14.4.13",
    "full_name": "TIMx capture/compare register 1 (TIMx_CCR1)",
    "short_name": "",
    "address_offset": "0x34",
    "reset_value": "0x0000",
    "content": "Bits 15:0PSC[15:0]: Prescaler value\nThe counter clock frequency CK_CNT is equal to f\n/ (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event.\nBits 15:0ARR[15:0]: Prescaler value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section14.3.1: Time-base unit on page321 for more details about ARR update\nand behavior.\nThe counter is blocked while the auto-reload value is null.\nBits 15:0CCR1[15:0]: Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit\nOC1PE). Else the preload value is copied in the active capture/compare 1 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signaled on OC1 output.\nIf channel CC1is configured as input:\nCCR1 is the counter value transferred by the last input capture 1 event (IC1).\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9371/995"
  },
  {
    "start_page": 371,
    "end_page": 371,
    "page_range": "371",
    "section": "14.4.14",
    "full_name": "TIMx capture/compare register 2 (TIMx_CCR2)",
    "short_name": "",
    "address_offset": "0x38",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 371,
    "end_page": 372,
    "page_range": "371-372",
    "section": "14.4.15",
    "full_name": "TIMx capture/compare register 3 (TIMx_CCR3)",
    "short_name": "",
    "address_offset": "0x3C",
    "reset_value": "0x0000",
    "content": "Bits 15:0CCR2[15:0]: Capture/Compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit\nOC2PE). Else the preload value is copied in the active capture/compare 2 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 is the counter value transferred by the last input capture 2 event (IC2).\nBits 15:0CCR3[15:0]: Capture/Compare value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit\nOC3PE). Else the preload value is copied in the active capture/compare 3 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC3 output.\nIf channel CC3is configured as input:\nCCR3 is the counter value transferred by the last input capture 3 event (IC3).\nGeneral-purpose timer (TIMx)RM0008\n372/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 372,
    "end_page": 372,
    "page_range": "372",
    "section": "14.4.16",
    "full_name": "TIMx capture/compare register 4 (TIMx_CCR4)",
    "short_name": "",
    "address_offset": "0x40",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 372,
    "end_page": 373,
    "page_range": "372-373",
    "section": "14.4.17",
    "full_name": "TIMx DMA control register (TIMx_DCR)",
    "short_name": "",
    "address_offset": "0x48",
    "reset_value": "0x0000",
    "content": "Bits 15:0CCR4[15:0]: Capture/Compare value\n1/ if CC4 channel is configured as output (CC4S bits):\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit\nOC4PE). Else the preload value is copied in the active capture/compare 4 register when an\nupdate event occurs.\nThe active capture/compare register contains the value to be compared to the counter\nTIMx_CNT and signalled on OC4 output.\n2/ if CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register):\nCCR4 is the counter value transferred by the last input capture 4 event (IC4).\nBits 15:13Reserved, always read as 0\nBits 12:8DBL[4:0]: DMA burst length\nThis 5-bits vector defines the length of DMA transfers (the timer recognizes a burst transfer\nwhen a read or a write access is done to the TIMx_DMAR address), i.e. the number of bytes to\nbe transferred.\n00000: 1 byte,\n00001: 2 bytes,\n00010: 3 bytes,\n10001: 18 bytes.\nBits 7:5Reserved, always read as 0\nBits 4:0DBA[4:0]: DMA base address\nThis 5-bit vector defines the base-address for DMA transfers (when read/write access are\ndone through the TIMx_DMAR address). DBA is defined as an offset starting from the\naddress of the TIMx_CR1 register.\n00000: TIMx_CR1,\n00001: TIMx_CR2,\n00010: TIMx_SMCR,\nRM0008General-purpose timer (TIMx)\nDoc ID 13902 Rev 9373/995\n14.4.18 TIMx DMA address for full transfer (TIMx_DMAR)\nAddress offset: 0x4C\nReset value: 0x0000"
  },
  {
    "start_page": 381,
    "end_page": 383,
    "page_range": "381-383",
    "section": "15.4.1",
    "full_name": "TIM6&TIM7 control register 1 (TIMx_CR1)",
    "short_name": "",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Counter clock = CK_CNT = CK_PSC\nCounter register01020304050607323334353631\nBits 15:8Reserved, always read as 0\nBit 7ARPE: Auto-reload preload enable\n0: TIMx_ARR register is not buffered.\n1: TIMx_ARR register is buffered.\nBits 6:4Reserved, always read as 0\nBit 3OPM: One-pulse mode\n0: Counter is not stopped at update event\n1: Counter stops counting at the next update event (clearing the CEN bit).\nBasic timers (TIM6&TIM7)RM0008\n382/995 Doc ID 13902 Rev 9\nBit 2URS: Update request source\nThis bit is set and cleared by software to select the UEV event sources.\n0: Any of the following events generates an update interrupt or DMA request if enabled.\nThese events can be:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\n1: Only counter overflow/underflow generates an update interrupt or DMA request if\nBit 1UDIS: Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\n0: UEV enabled. The Update (UEV) event is generated by one of the following events:\n–Counter overflow/underflow\n–Setting the UG bit\n–Update generation through the slave mode controller\nBuffered registers are then loaded with their preload values.\n1: UEV disabled. The Update event is not generated, shadow registers keep their value\n(ARR, PSC). However the counter and the prescaler are reinitialized if the UG bit is set or if\na hardware reset is received from the slave mode controller.\nBit 0CEN: Counter enable\n0: Counter disabled\n1: Counter enabled\nNote:Gated mode can work only if the CEN bit has been previously set by software. However\ntrigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an update event occurs.\nRM0008Basic timers (TIM6&TIM7)\nDoc ID 13902 Rev 9383/995"
  },
  {
    "start_page": 383,
    "end_page": 383,
    "page_range": "383",
    "section": "15.4.2",
    "full_name": "TIM6&TIM7 control register 2 (TIMx_CR2)",
    "short_name": "",
    "address_offset": "0x04",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 383,
    "end_page": 384,
    "page_range": "383-384",
    "section": "15.4.3",
    "full_name": "TIM6&TIM7 DMA/Interrupt enable register (TIMx_DIER)",
    "short_name": "",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bits 15:7Reserved, always read as 0.\nBits 6:4MMS: Master mode selection\nThese bits are used to select the information to be sent in master mode to slave timers for\nsynchronization (TRGO). The combination is as follows:\n000: Reset - the UG bit from the TIMx_EGR register is used as a trigger output (TRGO). If\nreset is generated by the trigger input (slave mode controller configured in reset mode) then\nthe signal on TRGO is delayed compared to the actual reset.\n001: Enable - the Counter enable signal, CNT_EN, is used as a trigger output (TRGO). It is\nuseful to start several timers at the same time or to control a window in which a slave timer\nis enabled. The Counter Enable signal is generated by a logic OR between CEN control bit\nand the trigger input when configured in gated mode.\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO,\nexcept if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR\n010: Update - The update event is selected as a trigger output (TRGO). For instance a\nmaster timer can then be used as a prescaler for a slave timer.\nBits 3:0Reserved, always read as 0\nBit 15:9Reserved, always read as 0.\nBit 8UDE: Update DMA request enable\n0: Update DMA request disabled.\n1: Update DMA request enabled.\nBit 7:1Reserved, always read as 0.\nBit 0UIE: Update interrupt enable\n0: Update interrupt disabled.\n1: Update interrupt enabled.\nBasic timers (TIM6&TIM7)RM0008\n384/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 384,
    "end_page": 384,
    "page_range": "384",
    "section": "15.4.4",
    "full_name": "TIM6&TIM7 status register (TIMx_SR)",
    "short_name": "",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 384,
    "end_page": 385,
    "page_range": "384-385",
    "section": "15.4.5",
    "full_name": "TIM6&TIM7 event generation register (TIMx_EGR)",
    "short_name": "",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "15.4.6 TIM6&TIM7 counter (TIMx_CNT)\nAddress offset: 0x24\nReset value: 0x0000\nBits 15:1Reserved, always read as 0.\nBit 0UIF: Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\n0: No update occurred.\n1: Update interrupt pending. This bit is set by hardware when the registers are updated:\n–At overflow or underflow regarding the repetition counter value and if UDIS = 0 in the\nTIMx_CR1 register.\n–When CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if\nURS=0 and UDIS=0 in the TIMx_CR1 register.\nBits 15:1Reserved, always read as 0.\nBit 0UG: Update generation\nThis bit can be set by software, it is automatically cleared by hardware.\n0: No action.\n1: Re-initializes the timer counter and generates an update of the registers. Note that the\nprescaler counter is cleared too (but the prescaler ratio is not affected).\nBits 15:0CNT[15:0]: Counter value\nRM0008Basic timers (TIM6&TIM7)\nDoc ID 13902 Rev 9385/995\n15.4.7 TIM6&TIM7 prescaler (TIMx_PSC)\nAddress offset: 0x28\nReset value: 0x0000"
  },
  {
    "start_page": 385,
    "end_page": 386,
    "page_range": "385-386",
    "section": "15.4.8",
    "full_name": "TIM6&TIM7 auto-reload register (TIMx_ARR)",
    "short_name": "",
    "address_offset": "0x2C",
    "reset_value": "0x0000",
    "content": "Bits 15:0PSC[15:0]: Prescaler value\nThe counter clock frequency CK_CNT is equal to f\n/ (PSC[15:0] + 1).\nPSC contains the value to be loaded into the active prescaler register at each update event.\nBits 15:0ARR[15:0]: Prescaler value\nARR is the value to be loaded into the actual auto-reload register.\nRefer to Section15.3.1: Time-base unit on page376 for more details about ARR update and\nThe counter is blocked while the auto-reload value is null.\nBasic timers (TIM6&TIM7)RM0008\n386/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 392,
    "end_page": 393,
    "page_range": "392-393",
    "section": "16.4.1",
    "full_name": "RTC control register high (RTC_CRH)",
    "short_name": "RTC_CRH",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "These bits are used to mask interrupt requests. Note that at reset all interrupts are disabled,\nso it is possible to write to the RTC registers to ensure that no interrupt requests are pending\nafter initialization. It is not possible to write to the RTC_CRH register when the peripheral is\ncompleting a previous write operation (flagged by RTOFF=0, see Section16.3.4 on page\nThe RTC functions are controlled by this control register. Some bits must be written using a\nspecific configuration procedure (see Configuration procedure:).\nBits 15:3Reserved, forced by hardware to 0.\nBit 2OWIE: Overflow interrupt enable\n0: Overflow interrupt is masked.\n1: Overflow interrupt is enabled.\nBit 1ALRIE: Alarm interrupt enable\n0: Alarm interrupt is masked.\n1: Alarm interrupt is enabled.\nBit 0SECIE: Second interrupt enable\n0: Second interrupt is masked.\n1: Second interrupt is enabled.\nRM0008Real-time clock (RTC)\nDoc ID 13902 Rev 9393/995"
  },
  {
    "start_page": 393,
    "end_page": 394,
    "page_range": "393-394",
    "section": "16.4.2",
    "full_name": "RTC control register low (RTC_CRL)",
    "short_name": "RTC_CRL",
    "address_offset": "0x04",
    "reset_value": "0x0020",
    "content": "Bits 15:6Reserved, forced by hardware to 0.\nBit 5RTOFF: RTC operation OFF\nWith this bit the RTC reports the status of the last write operation performed on its registers,\nindicating if it has been completed or not. If its value is ‘0’ then it is not possible to write to\nany of the RTC registers. This bit is read only.\n0: Last write operation on RTC registers is still ongoing.\n1: Last write operation on RTC registers terminated.\nBit 4CNF: Configuration flag\nThis bit must be set by software to enter in configuration mode so as to allow new values to\nbe written in the RTC_CNT, RTC_ALR or RTC_PRL registers. The write operation is only\nexecuted when the CNF bit is reset by software after has been set.\n0: Exit configuration mode (start update of RTC registers).\n1: Enter configuration mode.\nBit 3RSF: Registers synchronized flag\nThis bit is set by hardware at each time the RTC_CNT and RTC_DIV registers are updated\nand cleared by software. Before any read operation after an APB1 reset or an APB1 clock\nstop, this bit must be cleared by software, and the user application must wait until it is set to\nbe sure that the RTC_CNT, RTC_ALR or RTC_PRL registers are synchronized.\n0: Registers not yet synchronized.\n1: Registers synchronized.\nBit 2OWF: Overflow flag\nThis bit is set by hardware when the 32-bit programmable counter overflows. An interrupt is\ngenerated if OWIE=1 in the RTC_CRH register. It can be cleared only by software. Writing\n‘1’ has no effect.\n0: Overflow not detected\n1: 32-bit programmable counter overflow occurred.\nBit 1ALRF: Alarm flag\nThis bit is set by hardware when the 32-bit programmable counter reaches the threshold set\nin the RTC_ALR register. An interrupt is generated if ALRIE=1 in the RTC_CRH register. It\ncan be cleared only by software. Writing ‘1’ has no effect.\n0: Alarm not detected\n1: Alarm detected\nBit 0SECF: Second flag\nThis bit is set by hardware when the 32-bit programmable prescaler overflows, thus\nincrementing the RTC counter. Hence this flag provides a periodic signal with a period\ncorresponding to the resolution programmed for the RTC counter (usually one second). An\ninterrupt is generated if SECIE=1 in the RTC_CRH register. It can be cleared only by\nsoftware. Writing ‘1’ has no effect.\n0: Second flag condition not met.\n1: Second flag condition met.\nReal-time clock (RTC)RM0008\n394/995 Doc ID 13902 Rev 9\nThe functions of the RTC are controlled by this control register. It is not possible to write to\nthe RTC_CR register while the peripheral is completing a previous write operation (flagged\nby RTOFF=0, see Section16.3.4 on page 390).\nNote:1Any flag remains pending until the appropriate RTC_CR request bit is reset by software,\nindicating that the interrupt request has been granted.\n2At reset the interrupts are disabled, no interrupt requests are pending and it is possible to\nwrite to the RTC registers.\n3The OWF, ALRF, SECF and RSF bits are not updated when the APB1 clock is not running.\n4The OWF, ALRF, SECF and RSF bits can only be set by hardware and only cleared by\n5If ALRF = 1 and ALRIE = 1, the RTC global interrupt is enabled. If EXTI Line 17 is also\nenabled through the EXTI Controller, both the RTC global interrupt and the RTC Alarm\ninterrupt are enabled.\n6If ALRF = 1, the RTC Alarm interrupt is enabled if EXTI Line 17 is enabled through the EXTI\nController in interrupt mode. When the EXTI Line 17 is enabled in event mode, a pulse is\ngenerated on this line (no RTC Alarm interrupt generation)."
  },
  {
    "start_page": 394,
    "end_page": 395,
    "page_range": "394-395",
    "section": "",
    "full_name": "RTC prescaler load register high (RTC_PRLH)",
    "short_name": "RTC_PRLH",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": "Write only (see Section16.3.4 on page 390)\nBits 15:4Reserved, forced by hardware to 0.\nBits 3:0PRL[19:16]: RTC prescaler reload value high\nThese bits are used to define the counter clock frequency according to the following formula:\n= f\nCaution:The zero value is not recommended. RTC interrupts and flags cannot be asserted\nRM0008Real-time clock (RTC)\nDoc ID 13902 Rev 9395/995"
  },
  {
    "start_page": 395,
    "end_page": 395,
    "page_range": "395",
    "section": "",
    "full_name": "RTC prescaler load register low (RTC_PRLL)",
    "short_name": "RTC_PRLL",
    "address_offset": "0x0C",
    "reset_value": "0x8000",
    "content": "Write only (see Section16.3.4 on page 390)\nNote:If the input clock frequency (f\n) is 32.768 kHz, write 7FFFh in this register to get a\nsignal period of 1 second."
  },
  {
    "start_page": 395,
    "end_page": 395,
    "page_range": "395",
    "section": "",
    "full_name": "RTC prescaler divider register high (RTC_DIVH)",
    "short_name": "RTC_DIVH",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 395,
    "end_page": 396,
    "page_range": "395-396",
    "section": "",
    "full_name": "RTC prescaler divider register low (RTC_DIVL)",
    "short_name": "RTC_DIVL",
    "address_offset": "0x14",
    "reset_value": "0x8000",
    "content": "Bits 15:0PRL[15:0]: RTC prescaler reload value low\nThese bits are used to define the counter clock frequency according to the following formula:\n= f\nBits 15:4Reserved\nBits 3:0RTC_DIV[19:16]: RTC clock divider high\nBits 15:0RTC_DIV[15:0]: RTC clock divider low\nReal-time clock (RTC)RM0008\n396/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 396,
    "end_page": 396,
    "page_range": "396",
    "section": "",
    "full_name": "RTC counter register high (RTC_CNTH)",
    "short_name": "RTC_CNTH",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 396,
    "end_page": 397,
    "page_range": "396-397",
    "section": "",
    "full_name": "RTC counter register low (RTC_CNTL)",
    "short_name": "RTC_CNTL",
    "address_offset": "0x1C",
    "reset_value": "0x0000",
    "content": "Bits 15:0RTC_CNT[31:16]: RTC counter high\nReading the RTC_CNTH register, the current value of the high part of the RTC Counter\nregister is returned. To write to this register it is necessary to enter configuration mode (see\nSection16.3.4: Configuring RTC registers on page390).\nBits 15:0RTC_CNT[15:0]: RTC counter low\nReading the RTC_CNTL register, the current value of the lower part of the RTC Counter\nregister is returned. To write to this register it is necessary to enter configuration mode (see\nSection16.3.4: Configuring RTC registers on page390).\nRM0008Real-time clock (RTC)\nDoc ID 13902 Rev 9397/995"
  },
  {
    "start_page": 397,
    "end_page": 397,
    "page_range": "397",
    "section": "",
    "full_name": "RTC alarm register high (RTC_ALRH)",
    "short_name": "RTC_ALRH",
    "address_offset": "0x20",
    "reset_value": "0xFFFF",
    "content": "Write only (see Section16.3.4 on page 390)"
  },
  {
    "start_page": 397,
    "end_page": 398,
    "page_range": "397-398",
    "section": "",
    "full_name": "RTC alarm register low (RTC_ALRL)",
    "short_name": "RTC_ALRL",
    "address_offset": "0x24",
    "reset_value": "0xFFFF",
    "content": "Write only (see Section16.3.4 on page 390)\nBits 15:0RTC_ALR[31:16]: RTC alarm high\nThe high part of the alarm time is written by software in this register. To write to this register\nit is necessary to enter configuration mode (see Section16.3.4: Configuring RTC registers\non page390).\nBits 15:0RTC_ALR[15:0]: RTC alarm low\nThe low part of the alarm time is written by software in this register. To write to this register it\nis necessary to enter configuration mode (see Section16.3.4: Configuring RTC registers on\nReal-time clock (RTC)RM0008\n398/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 401,
    "end_page": 401,
    "page_range": "401",
    "section": "17.4.1",
    "full_name": "Key register (IWDG_KR)",
    "short_name": "IWDG_KR",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": ""
  },
  {
    "start_page": 401,
    "end_page": 402,
    "page_range": "401-402",
    "section": "17.4.2",
    "full_name": "Prescaler register (IWDG_PR)",
    "short_name": "IWDG_PR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:16Reserved, read as 0.\nBits 15:0KEY[15:0]: Key value (write only, read 0000h)\nThese bits must be written by software at regular intervals with the key value AAAAh,\notherwise the watchdog generates a reset when the counter reaches 0.\nWriting the key value 5555h to enables access to the IWDG_PR and IWDG_RLR registers\n(see Section17.3.2)\nWriting the key value CCCCh starts the watchdog (except if the hardware watchdog option is\nBits 31:3Reserved, read as 0.\nBits 2:0PR[2:0]: Prescaler divider\nThese bits are write access protected seeSection17.3.2. They are written by software to\nselect the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in\norder to be able to change the prescaler divider.\n000: divider /4\n001: divider /8\n010: divider /16\n011: divider /32\n100: divider /64\n101: divider /128\n110: divider /256\n111: divider /256\nNote:Reading this register returns the prescaler value from the VDD voltage domain. This\nvalue may not be up to date/valid if a write operation to this register is ongoing. For this\nreason the value read from this register is valid only when the PVU bit in the IWDG_SR\nregister is reset.\nIndependent watchdog (IWDG)RM0008\n402/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 402,
    "end_page": 402,
    "page_range": "402",
    "section": "17.4.3",
    "full_name": "Reload register (IWDG_RLR)",
    "short_name": "IWDG_RLR",
    "address_offset": "0x08",
    "reset_value": "0x0000 0FFF",
    "content": ""
  },
  {
    "start_page": 402,
    "end_page": 403,
    "page_range": "402-403",
    "section": "17.4.4",
    "full_name": "Status register (IWDG_SR)",
    "short_name": "IWDG_SR",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": "Note:If several reload values or prescaler values are used by application, it is mandatory to wait\nuntil RVU bit is reset before changing the reload value and to wait until PVU bit is reset\nbefore changing the prescaler value. However, after updating the prescaler and/or the\nreload value it is not necessary to wait until RVU or PVU is reset before continuing code\nexecution (even in case of low-power mode entry, the write operation is taken into account\nand will complete)\nBits 31:12Reserved, read as 0.\nBits11:0RL[11:0]: Watchdog counter reload value\nThese bits are write access protected see Section17.3.2. They are written by software to\ndefine the value to be loaded in the watchdog counter each time the value AAAAh is written\nin the IWDG_KR register. The watchdog counter counts down from this value. The timeout\nperiod is a function of this value and the clock prescaler. Refer to Table 81.\nThe RVU bit in the IWDG_SR register must be reset in order to be able to change the reload\nNote:Reading this register returns the reload value from the VDD voltage domain. This value\nmay not be up to date/valid if a write operation to this register is ongoing on this\nregister. For this reason the value read from this register is valid only when the RVU bit\nin the IWDG_SR register is reset.\nBits 31:2Reserved\nBit 1RVU: Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset\nby hardware when the reload value update operation is completed in the V\nvoltage domain\n(takes up to 5 RC 40 kHz cycles).\nReload value can be updated only when RVU bit is reset.\nBit 0PVU: Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is\nreset by hardware when the prescaler update operation is completed in the V\ndomain (takes up to 5 RC 40 kHz cycles).\nPrescaler value can be updated only when PVU bit is reset.\nRM0008Independent watchdog (IWDG)\nDoc ID 13902 Rev 9403/995"
  },
  {
    "start_page": 407,
    "end_page": 407,
    "page_range": "407",
    "section": "18.6.1",
    "full_name": "Control register (WWDG_CR)",
    "short_name": "WWDG_CR",
    "address_offset": "0x00",
    "reset_value": "0x7F",
    "content": ""
  },
  {
    "start_page": 407,
    "end_page": 408,
    "page_range": "407-408",
    "section": "18.6.2",
    "full_name": "Configuration register (WWDG_CFR)",
    "short_name": "WWDG_CFR",
    "address_offset": "0x04",
    "reset_value": "0x7F",
    "content": "Bits 31:8Reserved\nBit 7WDGA: Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA=1, the\nwatchdog can generate a reset.\n0: Watchdog disabled\n1: Watchdog enabled\nBits 6:0T[6:0]: 7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter. It is decremented every (4096 x\n) PCLK1 cycles. A reset is produced when it rolls over from 40h to 3Fh (T6 becomes\nBit 31:10Reserved\nBit 9EWI: Early wakeup interrupt\nWhen set, an interrupt occurs whenever the counter reaches the value 40h. This interrupt is\nonly cleared by hardware after a reset.\nWindow watchdog (WWDG)RM0008\n408/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 408,
    "end_page": 408,
    "page_range": "408",
    "section": "18.6.3",
    "full_name": "Status register (WWDG_SR)",
    "short_name": "WWDG_SR",
    "address_offset": "0x08",
    "reset_value": "0x00",
    "content": ""
  },
  {
    "start_page": 436,
    "end_page": 438,
    "page_range": "436-438",
    "section": "",
    "full_name": "SRAM/NOR-Flash chip-select control registers 1..4 (FSMC_BCR1..4)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0x0000 30D",
    "content": "This register contains the control information of each memory bank, used for SRAMs, ROMs\nand asynchronous or burst NOR Flash memories.\nBit 19CBURSTRW: Write burst enable.\nFor Cellular RAM, the bit enables synchronous burst protocol during write operations. For Flash\nmemory access in burst mode, this bit enables/disables the wait state insertion via the NWAIT\nsignal. The enable bit for the synchronous burst protocol during read access is the BURSTEN bit in\nthe FSMC_BCRx register.\n0: Write operations are always performed in asynchronous mode\n1: Write operations are performed in synchronous mode.\nBit 15Reserved.\nBit 14EXTMOD: Extended mode enable.\nThis bit enables the FSMC to program inside the FSMC_BWTR register, so it allows different\ntimings for read and write.\n0: values inside FSMC_BWTR register are not taken into account (default after reset)\n1: values inside FSMC_BWTR register are taken into account\nBit 13WAITEN: Wait enable bit.\nFor Flash memory access in burst mode, this bit enables/disables wait-state insertion via the\nNWAIT signal:\n0: NWAIT signal is disabled (its level not taken into account, no wait state inserted after the\nprogrammed Flash latency period)\n1: NWAIT signal is enabled (its level is taken into account after the programmed Flash latency\nperiod to insert wait states if asserted) (default after reset)\nBit 12WREN: Write enable bit.\nThis bit indicates whether write operations are enabled/disabled in the bank by the FSMC:\n0: Write operations are disabled in the bank by the FSMC, an AHB error is reported,\n1: Write operations are enabled for the bank by the FSMC (default after reset).\nBit 11WAITCFG: Wait timing configuration.\nFor memory access in burst mode, the NWAIT signal indicates whether the data from the memory\nare valid or if a wait state must be inserted. This configuration bit determines if NWAIT is asserted\nby the memory one clock cycle before the wait state or during the wait state:\n0: NWAIT signal is active one data cycle before wait state (default after reset),\n1: NWAIT signal is active during wait state (not for Cellular RAM).\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9437/995\nBit 10WRAPMOD: Wrapped burst mode support.\nDefines whether the controller will or not split an AHB burst wrap access into two linear accesses.\nValid only when accessing memories in burst mode\n0: Direct wrapped burst is not enabled (default after reset),\n1: Direct wrapped burst is enabled.\nBit 9WAITPOL: Wait signal polarity bit.\nDefines the polarity of the wait signal from memory. Valid only when accessing the memory in burst\n0: NWAIT active low (default after reset),\n1: NWAIT active high.\nBit 8BURSTEN: Burst enable bit.\nEnables the burst access mode for the memory. Valid only with synchronous burst memories:\n0: Burst access mode disabled (default after reset)\n1: Burst access mode enable\nBit 7Reserved.\nBit 6FACCEN: Flash access enable\nEnables NOR Flash memory access operations.\n0: Corresponding NOR Flash memory access is disabled\n1: Corresponding NOR Flash memory access is enabled (default after reset)\nBits 5:4MWID: Memory databus width.\nDefines the external memory device width, valid for all type of memories.\n00: 8 bits,\n01: 16 bits (default after reset),\n10: reserved, do not use,\n11: reserved, do not use.\nBits 3:2MTYP: Memory type.\nDefines the type of external memory attached to the corresponding memory bank:\n00: SRAM, ROM (default after reset for Bank 2...4)\n01: PSRAM (Cellular RAM: CRAM)\n10: NOR Flash(default after reset for Bank 1)\n11: reserved\nBit 1MUXEN: Address/data multiplexing enable bit.\nWhen this bit is set, the address and data values are multiplexed on the databus, valid only with\nNOR and PSRAM memories:\n0: Address/Data nonmultiplexed\n1: Address/Data multiplexed on databus (default after reset)\nBit 0MBKEN: Memory bank enable bit.\nEnables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a\ndisabled bank causes an ERROR on AHB bus.\n0: Corresponding memory bank is disabled\n1: Corresponding memory bank is enabled\nFlexible static memory controller (FSMC)RM0008\n438/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 438,
    "end_page": 440,
    "page_range": "438-440",
    "section": "",
    "full_name": "SRAM/NOR-Flash chip-select timing registers 1..4 (FSMC_BTR1..4)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0x0FFF FFFF",
    "content": "This register contains the control information of each memory bank, used for SRAMs, ROMs\nand NOR Flash memories. If the EXTMOD bit is set in the FSMC_BCRx register, then this\nregister is partitioned for write and read access, that is, 2 registers are available: one to\nconfigure read accesses (this register) and one to configure write accesses (FSMC_BWTRx\nBits 29:28ACCMOD: Access mode\nSpecifies the asynchronous access modes as shown in the timing diagrams. These bits are\ntaken into account only when the EXTMOD bit in the FSMC_BCRx register is 1.\n00: access mode A\n01: access mode B\n10: access mode C\n11: access mode D\nBits 27:24DATLAT (see note below bit descriptions): Data latency (for synchronous burst NOR Flash)\nFor NOR Flash with synchronous burst mode enabled, defines the number of memory clock\ncycles (+2) to issue to the memory before getting the first data:\nThis timing parameter is not expressed in HCLK periods, but in Flash clock (CLK) periods. In\nasynchronous NOR Flash, SRAM or ROM accesses, this value is don’t care. In case of\nCRAM, this field must be set to 0\n0000: Data latency of 2 CLK clock cycles for first burst access\n1111: Data latency of 17 CLK clock cycles for first burst access (default value after reset)\nBits 23:20CLKDIV: Clock divide ratio (for CLK signal)\nDefines the period of CLK clock output signal, expressed in number of HCLK cycles:\n0000: Reserved\n0001: CLK period = 2 × HCLK periods\n0010: CLK period = 3 × HCLK periods\n1111: CLK period = 16 × HCLK periods (default value after reset)\nIn asynchronous NOR Flash, SRAM or ROM accesses, this value is don’t care.\nBits 19:16BUSTURN: Bus turnaround phase duration\nThese bits are written by software to introduce the bus turnaround delay after a read access\n(only from multiplexed NOR Flash memory) to avoid bus contention if the controller needs to\ndrive addresses on the databus for the next side-by-side transaction. BUSTURN can be set\nto the minimum if the memory system does not include multiplexed memories or if the\nslowest memory does not take more than 6 HCLK clock cycles to put the databus in Hi-Z\n0000: BUSTURN phase duration = 1 × HCLK clock cycle\n1111: BUSTURN phase duration = 16 × HCLK clock cycles (default value after reset)\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9439/995\nNote:PSRAMs (CRAMs) have a variable latency due to internal refresh. Therefore these\nmemories issue the NWAIT signal during the whole latency phase to prolong the latency as\nWith PSRAMs (CRAMs) the filed DATLAT must be set to 0, so that the FSMC exits its\nlatency phase soon and starts sampling NWAIT from memory, then starts to read or write\nwhen the memory is ready.\nThis method can be used also with the latest generation of synchronous Flash memories\nthat issue the NWAIT signal, unlike older Flash memories (check the datasheet of the\nspecific Flash memory being used).\nBits 15:8DATAST: Data-phase duration\nThese bits are written by software to define the duration of the data phase (refer to\nFigure162 to Figure172), used in SRAMs, ROMs and asynchronous multiplexed NOR Flash\n00000000: Reserved\n00000001: DATAST phase duration = 2 × HCLK clock cycles\n00000010: DATAST phase duration = 3 × HCLK clock cycles\n11111111: DATAST phase duration = 256 × HCLK clock cycles (default value after reset)\nFor each memory type and access mode data-phase duration, please refer to the respective\nfigure (Figure162 to Figure172).\nExample: Mode1, read access, DATAST=1: Data-phase duration= DATAST+3 = 4 HCLK\nclock cycles.\nBits 7:4ADDHLD: Address-hold phase duration\nThese bits are written by software to define the duration of the address hold phase (refer to\nFigure170 to Figure172), used in mode D and multiplexed accesses:\n0000: Reserved\n0001: ADDHLD phase duration = 2 × HCLK clock cycle\n0010: ADDHLD phase duration = 3 × HCLK clock cycle\n1111: ADDHLD phase duration = 16 × HCLK clock cycles (default value after reset)\nFor  each access mode address-hold phase duration, please refer to the respective figure\n(Figure170 to Figure172).\nExample: ModeD, read access, ADDHLD=1: Address-hold phase duration = ADDHLD + 1 =2\nHCLK clock cycles.\nNote:In synchronous accesses, this value is not used, the address hold phase is always 1\nmemory clock period duration.\nBits 3:0ADDSET: Address setup phase duration\nThese bits are written by software to define the duration of the address setup phase (refer to\nFigure162 to Figure172), used in SRAMs, ROMs and asynchronous NOR Flash:\n0000: ADDSET phase duration = 1 × HCLK clock cycle\n1111: ADDSET phase duration = 16 × HCLK clock cycles (default value after reset)\nFor each access mode address setup phase duration, please refer to the respective figure\n(refer to Figure162 to Figure172).\nExample: Mode2, read access, ADDSET=1: Address setup phase duration = ADDSET + 1 =\n2 HCLK clock cycles.\nNote:In synchronous accesses, this value is not used, the address hold phase is always 1\nmemory clock period duration.\nFlexible static memory controller (FSMC)RM0008\n440/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 440,
    "end_page": 448,
    "page_range": "440-448",
    "section": "",
    "full_name": "SRAM/NOR-Flash write timing registers 1..4 (FSMC_BWTR1..4)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0x0FFF FFFF",
    "content": "This register contains the control information of each memory bank, used for SRAMs, ROMs\nand NOR Flash memories. When the EXTMOD bit is set in the FSMC_BCRx register, then\nthis register is active for write access.\nBits 29:28ACCMOD: Access mode.\nSpecifies the asynchronous access modes as shown in the next timing diagrams.These bits are\ntaken into account only when the EXTMOD bit in the FSMC_BCRx register is 1.\n00: access mode A\n01: access mode B\n10: access mode C\n11: access mode D\nBits 27:24DATLAT: Data latency (for synchronous burst NOR Flash).\nFor NOR Flash with Synchronous burst mode enabled, defines the number of memory clock cycles\n(+2) to issue to the memory before getting the first data:\n0000: (0x0) Data latency of 2 CLK clock cycles for first burst access\n1111: (0xF) Data latency of 17 CLK clock cycles for first burst access (default value after reset)\nNote: This timing parameter is not expressed in HCLK periods, but in Flash clock (CLK) periods\nNote: In asynchronous NOR Flash, SRAM or ROM accesses, this value is don’t care.\nNote: In case of CRAM, this field must be set to 0\nBits 23:20CLKDIV: Clock divide ratio (for CLK signal).\nDefines the period of CLK clock output signal, expressed in number of HCLK cycles:\n0000: Reserved\n0001 CLK period = 2 × HCLK periods\n0010 CLK period = 3 × HCLK periods\n1111: CLK period = 16 × HCLK periods (default value after reset)\nIn asynchronous NOR Flash, SRAM or ROM accesses, this value is don’t care.\nBits 19:16Reserved\nBits 15:8DATAST: Data-phase duration.\nThese bits are written by software to define the duration of the data phase (refer to Figure162 to\nFigure172), used in SRAMs, ROMs and asynchronous multiplexed NOR Flash accesses:\n00000000: Reserved\n00000001: DATAST phase duration = 2 × HCLK clock cycles\n00000010: DATAST phase duration = 3 × HCLK clock cycles\n11111111: DATAST phase duration = 16 × HCLK clock cycles (default value after reset)\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9441/995\n19.6 NAND Flash/PC Card controller\nThe FSMC generates the appropriate signal timings to drive the following types of device:\n●NAND Flash\n●16-bit PC Card compatible devices\nThe NAND/PC Card controller can control three external banks. Bank 2 and bank 3 support\nNAND Flash devices. Bank 4 supports PC Card devices.\nEach bank is configured by means of dedicated registers (Section19.6.7). The\nprogrammable memory parameters include access timings (shown in Table113) and ECC\nBits 7:4ADDHLD: Address-hold phase duration.\nThese bits are written by software to define the duration of the address hold phase (refer to\nFigure170 to Figure172), used in SRAMs, ROMs and asynchronous multiplexed NOR Flash\n0000: Reserved\n0001: ADDHLD phase duration = 2 × HCLK clock cycle\n0010: ADDHLD phase duration = 3 × HCLK clock cycle\n1111: ADDHLD phase duration = 16 × HCLK clock cycles (default value after reset)\nNote: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always\n1 Flash clock period duration.\nBits 3:0ADDSET: Address setup phase duration.\nThese bits are written by software to define the duration of the address setup phase in HCLK\ncycles (refer to Figure170 to Figure172), used in SRAMs, ROMs and asynchronous multiplexed\nNOR Flash:\n0000: ADDSET phase duration = 1 × HCLK clock cycle\n1111: ADDSET phase duration = 16 × HCLK clock cycles (default value after reset)\nNote: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always\n1 Flash clock period duration.\nFlexible static memory controller (FSMC)RM0008\n442/995 Doc ID 13902 Rev 9\n19.6.1 External memory interface signals\nThe following tables list the signals that are typically used to interface NAND Flash and PC\nCaution:When using a PC Card or a CompactFlash in I/O mode, the NIOS16 input pin must remain\nat ground level during the whole operation, otherwise the FSMC may not operate properly.\nThis means that the NIOS16 input pin must not be connected to the card, but directly to\nground (only 16-bit accesses are allowed).\nNote:Prefix “N”. specifies the associated signal as active low.\n8-bit NAND Flash\nThere is no theoretical capacity limitation as the FSMC can manage as many address\ncycles as needed.\nTable 113.Programmable NAND/PC Card access parameters\nParameterFunctionAccess modeUnitMin. Max.\nMemory setup\nNumber of clock cycles (HCLK)\nto set up the address before the\ncommand assertion\nAHB clock cycle\n1 256\nMemory wait\nMinimum duration (HCLK clock\ncycles) of the command assertion\nAHB clock cycle\nMemory hold\nNumber of clock cycles (HCLK)\nto hold the address (and the data\nin case of a write access) after\nthe command de-assertion\nAHB clock cycle\n1 255\ndatabus high-Z\nNumber of clock cycles (HCLK)\nduring which the databus is kept\nin high-Z state after the start of a\nwrite access\nAHB clock cycle\n0 255\nTable 114.8-bit NAND Flash\nFSMC signal nameI/O Function\nA[17] O NAND Flash address latch enable (ALE) signal\nA[16] O NAND Flash command latch enable (CLE) signal\nD[7:0] I/O 8-bit multiplexed, bidirectional address/data bus\nNCE[x]OChip select, x = 2, 3\nNOE(= NRE)O Output enable (memory signal name: read enable, NRE)\nNWEO Write enable\nNWAIT/INT[3:2]I NAND Flash ready/busy input signal to the FSMC\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9443/995\n16-bit NAND Flash\nThere is no theoretical capacity limitation as the FSMC can manage as many address\ncycles as needed.\nTable 115.16-bit NAND Flash\nFSMC signal name I/O Function\nA[17]O NAND Flash address latch enable (ALE) signal\nA[16] O NAND Flash command latch enable (CLE) signal\nD[15:0] I/O 16-bit multiplexed, bidirectional address/data bus\nNCE[x]OChip select, x = 2, 3\nNOE(= NRE)O Output enable (memory signal name: read enable, NRE)\nNWEO Write enable\nNWAIT/INT[3:2]I NAND Flash ready/busy input signal to the FSMC\nTable 116.16-bit PC Card\nFSMC signal nameI/OFunction\nA[10:0]OAddress bus\nNIOS16IData transfer width in I/O space (16-bit transfer only)\nNIORDOOutput enable for I/O space\nNIOWROWrite enable for I/O space\nNREGORegister signal indicating if access is in Common or Attribute space\nD[15:0]I/OBidirectional databus\nNCE4_1OChip select 1\nNCE4_2OChip select 2 (indicates if access is 16-bit or 8-bit)\nNOEOOutput enable\nNWEOWrite enable\nPC Card wait input signal to the FSMC (memory signal name\nPC Card interrupt to the FSMC (only for PC Cards that can generate\nan interrupt)\nCDIPC Card presence detection\nFlexible static memory controller (FSMC)RM0008\n444/995 Doc ID 13902 Rev 9\n19.6.2 NAND Flash / PC Card supported memories and transactions\nTable117 below shows the supported devices, access modes and transactions.\nTransactions not allowed (or not supported) by the NAND Flash / PC Card controller appear\nin gray.\n19.6.3 Timing diagrams for NAND, ATA and PC Card\nEach PC Card/CompactFlash and NAND Flash memory bank is managed through a set of\n●Control register: FSMC_PCRx\n●Interrupt status register: FSMC_SRx\n●ECC register: FSMC_ECCRx\n●Timing register for Common memory space: FSMC_PMEMx\n●Timing register for Attribute memory space: FSMC_PATTx\n●Timing register for I/O space: FSMC_PIOx\nEach timing configuration register contains three parameters used to define number of\nHCLK cycles for the three phases of any PC Card/CompactFlash or NAND Flash access,\nplus one parameter that defines the timing for starting driving the databus in the case of a\nwrite. Figure175 shows the timing parameter definitions for common memory accesses,\nknowing that Attribute and I/O (only for PC Card) memory space access timings are similar.\nTable 117.Supported memories and transactions\nDeviceMode R/W\ndata size\ndata size\nnot allowed\nNAND 8-bit\nAsynchronousR 8 8 Y\nAsynchronousW 8 8 Y\nAsynchronous R 16 8 Y Split into 2 FSMC accesses\nAsynchronous W 16 8 Y Split into 2 FSMC accesses\nAsynchronous R 32 8 Y Split into 4 FSMC accesses\nAsynchronous W 32 8 Y Split into 4 FSMC accesses\nNAND 16-bit\nAsynchronousR 8 16 Y\nAsynchronous W 8 16 N\nAsynchronousR 16 16 Y\nAsynchronousW 16 16 Y\nAsynchronous R 32 16 Y Split into 2 FSMC accesses\nAsynchronous W 32 16 Y Split into 2 FSMC accesses\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9445/995\nFigure 175.NAND/PC Card controller timing for common memory access\n1.NOE remains high (inactive) during write access. NWE remains high (inactive) during read access.\n2.NCEx goes low as soon as NAND access is requested and remains low until a different memory bank is accessed.\n19.6.4 NAND Flash operations\nThe command latch enable (CLE) and address latch enable (ALE) signals of the NAND\nFlash device are driven by some address signals of the FSMC controller. This means that to\nsend a command or an address to the NAND Flash memory, the CPU has to perform a write\nto a certain address in its memory space.\nA typical page read operation from the NAND Flash device is as follows:\n1.Program and enable the corresponding memory bank by configuring the FSMC_PCRx\nand FSMC_PMEMx (and for some devices, FSMC_PATTx, see Section19.6.5: NAND\nFlash pre-wait functionality on page446) registers according to the characteristics of\nthe NAND Flash (PWID bits for the databus width of the NAND Flash, PTYP = 1,\nPWAITEN = 1, PBKEN = 1, see section Common memory space timing register 2..4\n(FSMC_PMEM2..4) on page450 for timing configuration).\n2. The CPU performs a byte write in the common memory space, with data byte equal to\none Flash command byte (for example 0x00 for Samsung NAND Flash devices). The\nCLE input of the NAND Flash is active during the write strobe (low pulse on NWE), thus\nthe written byte is interpreted as a command by the NAND Flash. Once the command\nis latched by the NAND Flash device, it does not need to be written for the following\npage read operations.\n3. The CPU can send the start address (STARTAD) for a read operation by writing four\nbytes (or three for smaller capacity devices), STARTAD[7:0], then STARTAD[16:9],\nSTARTAD[24:17] and finally STARTAD[25] for 64 Mb x 8 bit NAND Flash) in the\ncommon memory or attribute space. The ALE input of the NAND Flash device is active\nduring the write strobe (low pulse on NWE), thus the written bytes are interpreted as\nMEMxSET + 1MEMxWAIT + 1MEMxHOLD + 1\nMEMxHIZ + 1\nFlexible static memory controller (FSMC)RM0008\n446/995 Doc ID 13902 Rev 9\nthe start address for read operations. Using the attribute memory space makes it\npossible to use a different timing configuration of the FSMC, which can be used to\nimplement the prewait functionality needed by some NAND Flash memories (see\ndetails in Section19.6.5: NAND Flash pre-wait functionality on page446).\n4. The controller waits for the NAND Flash to be ready (R/NB signal high) to become\nactive, before starting a new access (to same or another memory bank). While waiting,\nthe controller maintains the NCE signal active (low).\n5. The CPU can then perform byte read operations in the common memory space to read\nthe NAND Flash page (data field + Spare field) byte by byte.\n6. The next NAND Flash page can be read without any CPU command or address write\noperation, in three different ways:\n–by simply performing the operation described in step 5\n–a new random address can be accessed by restarting the operation at step 3\n–a new command can be sent to the NAND Flash device by restarting at step 2\n19.6.5 NAND Flash pre-wait functionality\nSome NAND Flash devices require that, after writing the last part of the address, the\ncontroller wait for the R/NB signal to go low as shown in Figure176.\nFigure 176.Access to non ‘CE don’t care’ NAND-Flash\n1.CPU wrote byte 0x00 at address 0x7001 0000.\n2.CPU wrote byte A7~A0 at address 0x7002 0000.\n3.CPU wrote byte A16~A9 at address 0x7002 0000.\n4.CPU wrote byte A24~A17 at address 0x7002 0000.\n5.CPU wrote byte A25 at address 0x7802 0000: FSMC performs a write access using FSMC_PATT2 timing\ndefinition, where ATTHOLD  7 (providing that (7+1) × HCLK = 112 ns > t\nmax). This guarantees that\nNCE remains low until R/NB goes low and high again (only requested for NAND Flash memories where\nNCE is not don’t care).\nNCE must stay low\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9447/995\nWhen this functionality is needed, it can be guaranteed by programming the MEMHOLD\nvalue to meet the t\ntiming, however any CPU read or write access to the NAND Flash\nthen has the hold delay of (MEMHOLD + 1) HCLK cycles inserted from the rising edge of\nthe NWE signal to the next access.\nTo overcome this timing constraint, the attribute memory space can be used by\nprogramming its timing register with an ATTHOLD value that meets the t\ntiming, and\nleaving the MEMHOLD value at its minimum. Then, the CPU must use the common memory\nspace for all NAND Flash read and write accesses, except when writing the last address\nbyte to the NAND Flash device, where the CPU must write to the attribute memory space.\n19.6.6 Error correction code computation ECC (NAND Flash)\nThe FSMC PC-Card controller includes two error correction code computation hardware\nblocks, one per memory bank. They are used to reduce the host CPU workload when\nprocessing the error correction code by software in the system.\nThese two registers are identical and associated with bank 2 and bank 3, respectively. As a\nconsequence, no hardware ECC computation is available for memories connected to bank\nThe error correction code (ECC) algorithm implemented in the FSMC can perform 1-bit error\ncorrection and 2-bit error detection per 256, 512, 1024, 2048, 4096 or 8192 bytes read\nfrom or written to NAND Flash.\nThe ECC modules monitor the NAND Flash databus and read/write signals (NCE and NWE)\neach time the NAND Flash memory bank is active.\nThe functional operations are:\n●When access to NAND Flash is made to bank 2 or bank 3, the data present on the\nD[15:0] bus is latched and used for ECC computation.\n●When access to NAND Flash occurs at any other address, the ECC logic is idle, and\ndoes not perform any operation. Thus, write operations for defining commands or\naddresses to NAND Flash are not taken into account for ECC computation.\nOnce the desired number of bytes has been read from/written to the NAND Flash by the\nhost CPU, the FSMC_ECCR2/3 registers must be read in order to retrieve the computed\nvalue. Once read, they should be cleared by resetting the ECCEN bit to zero. To compute a\nnew data block, the ECCEN bit must be set to one in the FSMC_PCR2/3 registers.\nFlexible static memory controller (FSMC)RM0008\n448/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 448,
    "end_page": 449,
    "page_range": "448-449",
    "section": "",
    "full_name": "PC Card/NAND Flash control registers 2..4 (FSMC_PCR2..4)",
    "short_name": "",
    "address_offset": "0xA0000000",
    "reset_value": "0x0000 0018",
    "content": "Bits 19:17ECCPS: ECC page size.\nDefines the page size for the extended ECC:\n000: 256 bytes\n001: 512 bytes\n010: 1024 bytes\n011: 2048 bytes\n100: 4096 bytes\n101: 8192 bytes\nBits 16:13TAR: ALE to RE delay.\nSets time from ALE low to RE low in number of AHB clock cycles (HCLK).\nTime is: t_ar = (TAR + SET + 4) × THCLK where THCLK is the HCLK clock period\n0000: 1 HCLK cycle (default)\n1111: 16 HCLK cycles\nNote:SET is MEMSET or ATTSET according to the addressed space.\nBits 12:9TCLR: CLE to RE delay.\nSets time from CLE low to RE low in number of AHB clock cycles (HCLK).\nTime is t_clr = (TCLR + SET + 4) × THCLK where THCLK is the HCLK clock period\n0000: 1 HCLK cycle (default)\n1111: 16 HCLK cycles\nNote:SET is MEMSET or ATTSET according to the addressed space.\nBits 8:7Reserved.\nBits 6ECCEN: ECC computation logic enable bit\n0: ECC logic is disabled and reset (default after reset),\n1: ECC logic is enabled.\nBits 5:4PWID: Databus width.\nDefines the external memory device width.\n00: 8 bits (default after reset)\n01: 16 bits (mandatory for PC Card)\n10: reserved, do not use\n11: reserved, do not use\nBit 3PTYP: Memory type.\nDefines the type of device attached to the corresponding memory bank:\n0: PC Card, CompactFlash, CF+ or PCMCIA\n1: NAND Flash (default after reset)\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9449/995"
  },
  {
    "start_page": 449,
    "end_page": 450,
    "page_range": "449-450",
    "section": "",
    "full_name": "FIFO status and interrupt register 2..4 (FSMC_SR2..4)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0x0000 0040",
    "content": "This register contains information about FIFO status and interrupt. The FSMC has a FIFO\nthat is used when writing to memories to store up to16 words of data from the AHB.\nThis is used to quickly write to the AHB and free it for transactions to peripherals other than\nthe FSMC, while the FSMC is draining its FIFO into the memory. This register has one of its\nbits that indicates the status of the FIFO, for ECC purposes.\nThe ECC is calculated while the data are written to the memory, so in order to read the\ncorrect ECC the software must wait until the FIFO is empty.\nBit 2PBKEN: PC Card/NAND Flash memory bank enable bit.\nEnables the memory bank. Accessing a disabled memory bank causes an ERROR on AHB\n0: Corresponding memory bank is disabled (default after reset)\n1: Corresponding memory bank is enabled\nBit 1PWAITEN: Wait feature enable bit.\nEnables the Wait feature for the PC Card/NAND Flash memory bank:\n0: disabled\n1: enabled\nNote:For a PC Card, when the wait feature is enabled, the MEMWAITx/ATTWAITx/IOWAITx\nbits must be programmed to a value higher than t\n+ 4, where\nis the maximum time taken by NWAIT to go low once NOE is low.\nBit 0Reserved.\nBit 6FEMPT: FIFO empty.\nRead-only bit that provides the status of the FIFO\n0: FIFO not empty\n1: FIFO empty\nBit 5IFEN: Interrupt falling edge detection enable bit\n0: Interrupt falling edge detection request disabled\n1: Interrupt falling edge detection request enabled\nBit 4ILEN: Interrupt high-level detection enable bit\n0: Interrupt high-level detection request disabled\n1: Interrupt high-level detection request enabled\nBit 3IREN: Interrupt rising edge detection enable bit\n0: Interrupt rising edge detection request disabled\n1: Interrupt rising edge detection request enabled\nFlexible static memory controller (FSMC)RM0008\n450/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 451,
    "end_page": 452,
    "page_range": "451-452",
    "section": "",
    "full_name": "Attribute memory space timing registers 2..4 (FSMC_PATT2..4)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0xFCFC FCFC",
    "content": "Each FSMC_PATTx (x = 2..4) read/write register contains the timing information for PC\nCard/CompactFlash or NAND Flash memory bank x. It is used for 8-bit accesses to the\nattribute memory space of the PC Card/CompactFlash (every AHB transaction is split up\ninto a sequence of 8-bit transactions), or to access the NAND Flash for the last address\nwrite access if the timing must differ from that of previous accesses (for Ready/Busy\nmanagement, refer to Section19.6.5: NAND Flash pre-wait functionality).\nBits 7:0MEMSETx: Common memory x setup time\nDefines the number of HCLK (+1 for PC Card, +2 for NAND) clock cycles to set up the\naddress before the command assertion (NWE, NOE), for PC Card/NAND Flash read or write\naccess to common memory space on socket x:\n00000000: 1 HCLK cycle (for PC Card) / HCLK cycles (for NAND Flash)\n11111111: 256 HCLK cycles (for PC Card) / 257 HCLK cycles (for NAND Flash) - (default\nvalue after reset)\nBits 31:24ATTHIZx: Attribute memory x databus HiZ time\nDefines the number of HCLK clock cycles during which the databus is kept in HiZ after the\nstart of a PC CARD/NAND Flash write access to attribute memory space on socket x. Only\nvalid for write transaction:\n00000000: 0 HCLK cycle\n11111111: 255 HCLK cycles (default value after reset)\nBits 23:16ATTHOLDx: Attribute memory x hold time\nDefines the number of HCLK clock cycles to hold address (and data for write access) after\nthe command deassertion (NWE, NOE), for PC Card/NAND Flash read or write access to\nattribute memory space on socket x\n00000000: reserved\n00000001: 1 HCLK cycle\n11111111: 255 HCLK cycles (default value after reset)\nBits 15:8ATTWAITx: Attribute memory x wait time\nDefines the minimum number of HCLK (+1) clock cycles to assert the command (NWE,\nNOE), for PC Card/NAND Flash read or write access to attribute memory space on socket x.\nThe duration for command assertion is extended if the wait signal (NWAIT) is active (low) at\nthe end of the programmed value of HCLK:\n00000000: reserved\n00000001: 2 HCLK cycles (+ wait cycle introduced by deassertion of NWAIT)\n11111111: 256 HCLK cycles (+ wait cycle introduced by the card deasserting NWAIT)\n(default value after reset)\nFlexible static memory controller (FSMC)RM0008\n452/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 452,
    "end_page": 453,
    "page_range": "452-453",
    "section": "",
    "full_name": "I/O space timing register 4 (FSMC_PIO4)",
    "short_name": "FSMC_PIO4",
    "address_offset": "0xA000",
    "reset_value": "0xFCFCFCFC",
    "content": "The FSMC_PIO4 read/write registers contain the timing information used to gain access to\nthe I/O space of the 16-bit PC Card/CompactFlash.\nBits 7:0ATTSETx: Attribute memory x setup time\nDefines the number of HCLK (+1) clock cycles to set up address before the command\nassertion (NWE, NOE), for PC CARD/NAND Flash read or write access to attribute memory\nspace on socket x:\n00000000: 1 HCLK cycle\n11111111: 256 HCLK cycles (default value after reset)\nBits 31:24IOHIZx: I/O x databus HiZ time\nDefines the number of HCLK clock cycles during which the databus is kept in HiZ after the\nstart of a PC Card write access to I/O space on socket x. Only valid for write transaction:\n00000000: 0 HCLK cycle\n1111 1111: 255 HCLK cycles (default value after reset)\nBits 23:16IOHOLDx: I/O x hold time\nDefines the number of HCLK clock cycles to hold address (and data for write access) after\nthe command deassertion (NWE, NOE), for PC Card read or write access to I/O space on\nsocket x:\n00000000: reserved\n00000001: 1 HCLK cycle\n11111111: 255 HCLK cycles (default value after reset)\nBits 15:8IOWAITx: I/O x wait time\nDefines the minimum number of HCLK (+1) clock cycles to assert the command (SMNWE,\nSMNOE), for PC Card read or write access to I/O space on socket x. The duration for\ncommand assertion is extended if the wait signal (NWAIT) is active (low) at the end of the\nprogrammed value of HCLK:\n00000000: reserved, do not use this value\n0000 0001: 2 HCLK cycles (+ wait cycle introduced by deassertion of NWAIT)\n1111 1111: 256 HCLK cycles (+ wait cycle introduced by the Card deasserting NWAIT)\n(default value after reset)\nBits 7:0IOSETx: I/O x setup time\nDefines the number of HCLK (+1) clock cycles to set up the address before the command\nassertion (NWE, NOE), for PC Card read or write access to I/O space on socket x:\n00000000: 1 HCLK cycle\n1111 1111: 256 HCLK cycles (default value after reset)\nRM0008Flexible static memory controller (FSMC)\nDoc ID 13902 Rev 9453/995"
  },
  {
    "start_page": 453,
    "end_page": 454,
    "page_range": "453-454",
    "section": "",
    "full_name": "ECC result registers 2/3 (FSMC_ECCR2/3)",
    "short_name": "",
    "address_offset": "0xA000",
    "reset_value": "0x0000 0000",
    "content": "These registers contain the current error correction code value computed by the ECC\ncomputation modules of the FSMC controller (one module per NAND Flash memory bank).\nWhen the CPU reads the data from a NAND Flash memory page at the correct address\n(refer to Section19.6.6: Error correction code computation ECC (NAND Flash)), the data\nread from or written to the NAND Flash are processed automatically by ECC computation\nmodule. At the end of X bytes read (according to the ECCPS field in the FSMC_PCRx\nregisters), the CPU must read the computed ECC value from the FSMC_ECCx registers,\nand then verify whether these computed parity data are the same as the parity value\nrecorded in the spare area, to determine whether a page is valid, and, to correct it if\napplicable. The FSMC_ECCRx registers should be cleared after being read by setting the\nECCEN bit to zero. For computing a new data block, the ECCEN bit must be set to one.\nBits 31:0ECCx: ECC result\nThis field provides the value computed by the ECC computation logic. Table118 hereafter\ndescribes the contents of these bit fields.\nTable 118.ECC result relevant bits\nECCPS[2:0]Page size in bytesECC bits\nFlexible static memory controller (FSMC)RM0008\n454/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 497,
    "end_page": 497,
    "page_range": "497",
    "section": "20.9.1",
    "full_name": "SDIO power control register (SDIO_POWER)",
    "short_name": "SDIO_POWER",
    "address_offset": "0x00",
    "reset_value": "0x0000 0000",
    "content": "Note:After a data write, data cannot be written to this register for seven HCLK clock periods."
  },
  {
    "start_page": 497,
    "end_page": 498,
    "page_range": "497-498",
    "section": "20.9.2",
    "full_name": "SDI clock control register (SDIO_CLKCR)",
    "short_name": "SDIO_CLKCR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_CLKCR register controls the SDIO_CK output clock.\nBits 31:2Reserved, always read as 0.\n[1:0]PWRCTRL: Power supply control bits.\nThese bits are used to define the current functional state of the card clock:\n00: Power-off: the clock to card is stopped.\n01: Reserved\n10: Reserved power-up\n11: Power-on: the card is clocked.\nBits 31:15Reserved, always read as 0.\nBit 14HWFC_EN: HW Flow Control enable\n0b: HW Flow Control is disabled\n1b: HW Flow Control is enabled\nWhen HW Flow Control is enabled, the meaning of the TXFIFOE and RXFIFOF interrupt\nsignals, please see SDIO Status register definition in Section20.9.11.\nBit 13NEGEDGE:SDIO_CK dephasing selection bit\n0b: SDIO_CK generated on the rising edge of the master clock SDIOCLK\n1b: SDIO_CK generated on the falling edge of the master clock SDIOCLK\nBits 12:11WIDBUS: Wide bus mode enable bit\n00: Default bus mode: SDIO_D0 used\n01: 4-wide bus mode: SDIO_D[3:0] used\n10: 8-wide bus mode: SDIO_D[7:0] used\nSecure digital input/output interface (SDIO)RM0008\n498/995 Doc ID 13902 Rev 9\nNote:1While the SD/SDIO card or MultiMediaCard is in identification mode, the SDIO_CK\nfrequency must be less than 400 kHz.\n2The clock frequency can be changed to the maximum card bus frequency when relative\ncard addresses are assigned to all cards.\n3After a data write, data cannot be written to this register for seven HCLK clock periods.\nSDIO_CK can also be stopped during the read wait interval for SD I/O cards: in this case the\nSDIO_CLKCR register does not control SDIO_CK."
  },
  {
    "start_page": 498,
    "end_page": 499,
    "page_range": "498-499",
    "section": "20.9.3",
    "full_name": "SDIO argument register (SDIO_ARG)",
    "short_name": "SDIO_ARG",
    "address_offset": "0x08",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_ARG register contains a 32-bit command argument, which is sent to a card as\npart of a command message.\nBit 10BYPASS: Clock divider bypass enable bit\n0: Disable bypass: SDIOCLK is divided according to the CLKDIV value before driving the\nSDIO_CK output signal.\n1: Enable bypass: SDIOCLK directly drives the SDIO_CK output signal.\nBit 9PWRSAV: Power saving configuration bit\nFor power saving, the SDIO_CK clock output can be disabled when the bus is idle by setting\n0: SDIO_CK clock is always enabled\n1: SDIO_CK is only enabled when the bus is active\nBit 8CLKEN: Clock enable bit\n0: SDIO_CK is disabled\n1: SDIO_CK is enabled\nBits 7:0CLKDIV: Clock divide factor\nThis field defines the divide factor between the input clock (SDIOCLK) and the output clock\n(SDIO_CK): SDIO_CK frequency = SDIOCLK / [CLKDIV + 2].\nBits 31:0CMDARG: Command argument\nCommand argument sent to a card as part of a command message. If a command contains\nan argument, it must be loaded into this register before writing a command to the command\nRM0008Secure digital input/output interface (SDIO)\nDoc ID 13902 Rev 9499/995"
  },
  {
    "start_page": 499,
    "end_page": 500,
    "page_range": "499-500",
    "section": "20.9.4",
    "full_name": "SDIO command register (SDIO_CMD)",
    "short_name": "SDIO_CMD",
    "address_offset": "0x0C",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_CMD register contains the command index and command type bits. The\ncommand index is sent to a card as part of a command message. The command type bits\ncontrol the command path state machine (CPSM).\nNote:1After a data write, data cannot be written to this register for seven HCLK clock periods.\n2MultiMediaCards can send two kinds of response: short responses, 48 bits long, or long\nresponses,136 bits long. SD card and SD I/O card can send only short responses, the\nBits 31:15Reserved, always read as 0.\nBit 14ATACMD: CE-ATA command\nIf ATACMD is set, the CPSM transfers CMD61.\nBit 13nIEN: not Interrupt Enable\nif this bit is 0, interrupts in the CE-ATA device are enabled.\nBit 12ENCMDcompl: Enable CMD completion\nIf this bit is set, the command completion signal is enabled.\nBit 11SDIOSuspend: SD I/O suspend command\nIf this bit is set, the command to be sent is a suspend command (to be used only with SDIO\nBit 10CPSMEN: Command path state machine (CPSM) Enable bit\nIf this bit is set, the CPSM is enabled.\nBit 9WAITPEND: CPSM Waits for ends of data transfer (CmdPend internal signal).\nIf this bit is set, the CPSM waits for the end of data transfer before it starts sending a\nBit 8WAITINT: CPSM waits for interrupt request\nIf this bit is set, the CPSM disables command timeout and waits for an interrupt request.\nBits 7:6WAITRESP: Wait for response bits\nThey are used to configure whether the CPSM is to wait for a response, and if yes, which\nkind of response.\n00: No response, expect CMDSENT flag\n01: Short response, expect CMDREND or CCRCFAIL flag\n10: No response, expect CMDSENT flag\n11: Long response, expect CMDREND or CCRCFAIL flag\nBit 5:0CMDINDEX: Command index\nThe command index is sent to the card as part of a command message.\nSecure digital input/output interface (SDIO)RM0008\n500/995 Doc ID 13902 Rev 9\nargument can vary according to the type of response: the software will distinguish the type\nof response according to the sent command. CE-ATA devices send only short responses."
  },
  {
    "start_page": 500,
    "end_page": 500,
    "page_range": "500",
    "section": "20.9.5",
    "full_name": "SDIO command response register (SDIO_RESPCMD)",
    "short_name": "SDIO_RESPCMD",
    "address_offset": "0x10",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_RESPCMD register contains the command index field of the last command\nresponse received. If the command response transmission does not contain the command\nindex field (long or OCR response), the RESPCMD field is unknown, although it must\ncontain 111111b (the value of the reserved field from the response)."
  },
  {
    "start_page": 501,
    "end_page": 501,
    "page_range": "501",
    "section": "20.9.7",
    "full_name": "SDIO data timer register (SDIO_DTIMER)",
    "short_name": "SDIO_DTIMER",
    "address_offset": "0x24",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_DTIMER register contains the data timeout period, in card bus clock periods.\nA counter loads the value from the SDIO_DTIMER register, and starts decrementing when\nthe data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0\nwhile the DPSM is in either of these states, the timeout status flag is set.\nNote:A data transfer must be written to the data timer register and the data length register before\nbeing written to the data control register."
  },
  {
    "start_page": 501,
    "end_page": 502,
    "page_range": "501-502",
    "section": "20.9.8",
    "full_name": "SDIO data length register (SDIO_DLEN)",
    "short_name": "SDIO_DLEN",
    "address_offset": "0x28",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_DLEN register contains the number of data bytes to be transferred. The value is\nloaded into the data counter when data transfer starts.\nNote:For a block data transfer, the value in the data length register must be a multiple of the block\nsize (see SDIO_DCTRL). A data transfer must be written to the data timer register and the\ndata length register before being written to the data control register.\nBits 31:0DATATIME: Data timeout period\nData timeout period expressed in card bus clock periods.\nBits 31:25Reserved, always read as 0.\nBits 24:0DATALENGTH: Data length value\nNumber of data bytes to be transferred.\nSecure digital input/output interface (SDIO)RM0008\n502/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 502,
    "end_page": 503,
    "page_range": "502-503",
    "section": "20.9.9",
    "full_name": "SDIO data control register (SDIO_DCTRL)",
    "short_name": "SDIO_DCTRL",
    "address_offset": "0x2C",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_DCTRL register control the data path state machine (DPSM).\nBits 31:12Reserved, always read as 0.\nBit 11SDIOEN: SD I/O enable functions\nIf this bit is set, the DPSM performs an SD I/O-card-specific operation.\nBit 10RWMOD: Read wait mode\n0: Read Wait control stopping SDIO_CK\n1: Read Wait control using SDIO_D2\nBit 9RWSTOP: Read wait stop\n0: Read wait in progress if RWSTART bit is set\n1: Enable for read wait stop if RWSTART bit is set\nBit 8RWSTART: Read wait start\nIf this bit is set, read wait operation starts.\nBits 7:4DBLOCKSIZE: Data block size\nDefine the data block length when the block data transfer mode is selected:\n0000: (0 decimal) lock length = 2\n= 1 byte\n0001: (1 decimal) lock length = 2\n= 2 bytes\n0010: (2 decimal) lock length = 2\n= 4 bytes\n0011: (3 decimal) lock length = 2\n= 8 bytes\n0100: (4 decimal) lock length = 2\n= 16 bytes\n0101: (5 decimal) lock length = 2\n= 32 bytes\n0110: (6 decimal) lock length = 2\n= 64 bytes\n0111: (7 decimal) lock length = 2\n= 128 bytes\n1000: (8 decimal) lock length = 2\n= 256 bytes\n1001: (9 decimal) lock length = 2\n= 512 bytes\n1010: (10 decimal) lock length = 2\n= 1024 bytes\n1011: (11 decimal) lock length = 2\n= 2048 bytes\n1100: (12 decimal) lock length = 2\n= 4096 bytes\n1101: (13 decimal) lock length = 2\n= 8192 bytes\n1110: (14 decimal) lock length = 2\n= 16384 bytes\n1111: (15 decimal) reserved\nBit 3DMAEN: DMA enable bit\n0: DMA disabled.\n1: DMA enabled.\nRM0008Secure digital input/output interface (SDIO)\nDoc ID 13902 Rev 9503/995\nNote:After a data write, data cannot be written to this register for seven HCLK clock periods."
  },
  {
    "start_page": 503,
    "end_page": 504,
    "page_range": "503-504",
    "section": "20.9.10",
    "full_name": "SDIO data counter register (SDIO_DCOUNT)",
    "short_name": "SDIO_DCOUNT",
    "address_offset": "0x30",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_DCOUNT register loads the value from the data length register (see\nSDIO_DLEN) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As\ndata is transferred, the counter decrements the value until it reaches 0. The DPSM then\nmoves to the Idle state and the data status end flag, DATAEND, is set.\nNote:This register should be read only when the data transfer is complete.\nBit 2DTMODE: Data transfer mode selection 1: Stream or SDIO multibyte data transfer.\n0: Block data transfer.\n1: Stream data transfer.\nBit 1DTDIR: Data transfer direction selection\n0: From controller to card.\n1: From card to controller.\n[0]DTEN: Data transfer enabled bit\nData transfer starts if 1b is written to the DTEN bit. Depending on the direction bit, DTDIR,\nthe DPSM moves to the Wait_S, Wait_R state or Readwait if RW Start is set immediately at\nthe beginning of the transfer. It is not necessary to clear the enable bit after the end of a data\ntransfer but the SDIO_DCTRL must be updated to enable a new data transfer\nBits 31:25Reserved, always read as 0.\nBits 24:0DATACOUNT: Data count value\nWhen this bit is read, the number of remaining data bytes to be transferred is returned. Write\nhas no effect.\nSecure digital input/output interface (SDIO)RM0008\n504/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 504,
    "end_page": 505,
    "page_range": "504-505",
    "section": "20.9.11",
    "full_name": "SDIO status register (SDIO_STA)",
    "short_name": "SDIO_STA",
    "address_offset": "0x34",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_STA register is a read-only register. It contains two types of flag:\n●Static flags (bits [23:22,10:0]): these bits remain asserted until they are cleared by\nwriting to the SDIO Interrupt Clear register (see SDIO_ICR)\n●Dynamic flags (bits [21:11]): these bits change state depending on the state of the\nunderlying logic (for example, FIFO full and empty flags are asserted and deasserted\nas data while written to the FIFO)\nBits 31:24Reserved, always read as 0.\nBit 23CEATAEND: CE-ATA command completion signal received for CMD61\nBit 22SDIOIT: SDIO interrupt received\nBit 21RXDAVL: Data available in receive FIFO\nBit 20TXDAVL: Data available in transmit FIFO\nBit 19RXFIFOE: Receive FIFO empty\nBit 18TXFIFOE: Transmit FIFO empty\nWhen HW Flow Control is enabled, TXFIFOE signals becomes activated when the FIFO\ncontains 2 words.\nBit 17RXFIFOF: Receive FIFO full\nWhen HW Flow Control is enabled, RXFIFOF signals becomes activated 2 words before the\nFIFO is full.\nBit 16TXFIFOF: Transmit FIFO full\nBit 15RXFIFOHF: Receive FIFO half full: there are at least 8 words in the FIFO\nBit 14TXFIFOHE: Transmit FIFO half empty: at least 8 words can be written into the FIFO\nBit 13RXACT: Data receive in progress\nBit 12TXACT: Data transmit in progress\nBit 11CMDACT: Command transfer in progress\nBit 10DBCKEND: Data block sent/received (CRC check passed)\nBit 9STBITERR: Start bit not detected on all data signals in wide bus mode\nBit 8DATAEND: Data end (data counter, SDIDCOUNT, is zero)\nBit 7CMDSENT: Command sent (no response required)\nBit 6CMDREND: Command response received (CRC check passed)\nBit 5RXOVERR: Received FIFO overrun error\nRM0008Secure digital input/output interface (SDIO)\nDoc ID 13902 Rev 9505/995"
  },
  {
    "start_page": 505,
    "end_page": 507,
    "page_range": "505-507",
    "section": "20.9.12",
    "full_name": "SDIO interrupt clear register (SDIO_ICR)",
    "short_name": "SDIO_ICR",
    "address_offset": "0x38",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_ICR register is a write-only register. Writing a bit with 1b clears the\ncorresponding bit in the SDIO_STA Status register.\nBit 4TXUNDERR: Transmit FIFO underrun error\nBit 3DTIMEOUT: Data timeout\nBit 2CTIMEOUT: Command response timeout\nThe Command TimeOut period has a fixed value of 64 SDIO_CK clock periods.\nBit 1DCRCFAIL: Data block sent/received (CRC check failed)\nBit 0CCRCFAIL: Command response received (CRC check failed)\nBits 31:24Reserved, always read as 0.\nBit 23CEATAENDC: CEATAEND flag clear bit\nSet by software to clear the CEATAEND flag.\n0: CEATAEND not cleared\n1: CEATAEND cleared\nBit 22SDIOITC: SDIOIT flag clear bit\nSet by software to clear the SDIOIT flag.\n0: SDIOIT not cleared\n1: SDIOIT cleared\nBits 21:11Reserved, always read as 0.\nBit 10DBCKENDC: DBCKEND flag clear bit\nSet by software to clear the DBCKEND flag.\n0: DBCKEND not cleared\n1: DBCKEND cleared\nBit 9STBITERRC: STBITERR flag clear bit\nSet by software to clear the STBITERR flag.\n0: STBITERR not cleared\n1: STBITERR cleared\nBit 8DATAENDC: DATAEND flag clear bit\nSet by software to clear the DATAEND flag.\n0: DATAEND not cleared\n1: DATAEND cleared\nSecure digital input/output interface (SDIO)RM0008\n506/995 Doc ID 13902 Rev 9\nBit 7CMDSENTC: CMDSENT flag clear bit\nSet by software to clear the CMDSENT flag.\n0: CMDSENT not cleared\n1: CMDSENT cleared\nBit 6CMDRENDC: CMDREND flag clear bit\nSet by software to clear the CMDREND flag.\n0: CMDREND not cleared\n1: CMDREND cleared\nBit 5RXOVERRC: RXOVERR flag clear bit\nSet by software to clear the RXOVERR flag.\n0: RXOVERR not cleared\n1: RXOVERR cleared\nBit 4TXUNDERRC: TXUNDERR flag clear bit\nSet by software to clear TXUNDERR flag.\n0: TXUNDERR not cleared\n1: TXUNDERR cleared\nBit 3DTIMEOUTC: DTIMEOUT flag clear bit\nSet by software to clear the DTIMEOUT flag.\n0: DTIMEOUT not cleared\n1: DTIMEOUT cleared\nBit 2CTIMEOUTC: CTIMEOUT flag clear bit\nSet by software to clear the CTIMEOUT flag.\n0: CTIMEOUT not cleared\n1: CTIMEOUT cleared\nBit 1DCRCFAILC: DCRCFAIL flag clear bit\nSet by software to clear the DCRCFAIL flag.\n0: DCRCFAIL not cleared\n1: DCRCFAIL cleared\nBit 0CCRCFAILC: CCRCFAIL flag clear bit\nSet by software to clear the CCRCFAIL flag.\n0: CCRCFAIL not cleared\n1: CCRCFAIL cleared\nRM0008Secure digital input/output interface (SDIO)\nDoc ID 13902 Rev 9507/995"
  },
  {
    "start_page": 507,
    "end_page": 509,
    "page_range": "507-509",
    "section": "20.9.13",
    "full_name": "SDIO mask register (SDIO_MASK)",
    "short_name": "SDIO_MASK",
    "address_offset": "0x3C",
    "reset_value": "0x0000 0000",
    "content": "The interrupt mask register determines which status flags generate an interrupt request by\nsetting the corresponding bit to 1b.\nBits 31:24Reserved, always read as 0.\nBit 23CEATAENDIE: CE-ATA command completion signal received interrupt enable\nSet and cleared by software to enable/disable the interrupt generated when receiving the\nCE-ATA command completion signal.\n0: CE-ATA command completion signal received interrupt disabled\n1: CE-ATA command completion signal received interrupt enabled\nBit 22SDIOITIE: SDIO mode interrupt received interrupt enable\nSet and cleared by software to enable/disable the interrupt generated when receiving the\nSDIO mode interrupt.\n0: SDIO Mode Interrupt Received interrupt disabled\n1: SDIO Mode Interrupt Received interrupt enabled\nBit 21RXDAVLIE: Data available in Rx FIFO interrupt enable\nSet and cleared by software to enable/disable the interrupt generated by the presence of\ndata available in Rx FIFO.\n0: Data available in Rx FIFO interrupt disabled\n1: Data available in Rx FIFO interrupt enabled\nBit 20TXDAVLIE: Data available in Tx FIFO interrupt enable\nSet and cleared by software to enable/disable the interrupt generated by the presence of\ndata available in Tx FIFO.\n0: Data available in Tx FIFO interrupt disabled\n1: Data available in Tx FIFO interrupt enabled\nBit 19RXFIFOEIE: Rx FIFO empty interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Rx FIFO empty.\n0: Rx FIFO empty interrupt disabled\n1: Rx FIFO empty interrupt enabled\nBit 18TXFIFOEIE: Tx FIFO empty interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Tx FIFO empty.\n0: Tx FIFO empty interrupt disabled\n1: Tx FIFO empty interrupt enabled\nBit 17RXFIFOFIE: Rx FIFO full interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Rx FIFO full.\n0: Rx FIFO full interrupt disabled\n1: Rx FIFO full interrupt enabled\nSecure digital input/output interface (SDIO)RM0008\n508/995 Doc ID 13902 Rev 9\nBit 16TXFIFOFIE: Tx FIFO full interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Tx FIFO full.\n0: Tx FIFO full interrupt disabled\n1: Tx FIFO full interrupt enabled\nBit 15RXFIFOHFIE: Rx FIFO half full interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Rx FIFO half full.\n0: Rx FIFO half full interrupt disabled\n1: Rx FIFO half full interrupt enabled\nBit 14TXFIFOHEIE: Tx FIFO half empty interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.\n0: Tx FIFO half empty interrupt disabled\n1: Tx FIFO half empty interrupt enabled\nBit 13RXACTIE: Data receive acting interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data being received (data\nreceive acting).\n0: Data receive acting interrupt disabled\n1: Data receive acting interrupt enabled\nBit 12TXACTIE: Data transmit acting interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data being transferred\n(data transmit acting).\n0: Data transmit acting interrupt disabled\n1: Data transmit acting interrupt enabled\nBit 11CMDACTIE: Command acting interrupt enable\nSet and cleared by software to enable/disable interrupt caused by a command being\ntransferred (command acting).\n0: Command acting interrupt disabled\n1: Command acting interrupt enabled\nBit 10DBCKENDIE: Data block end interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data block end.\n0: Data block end interrupt disabled\n1: Data block end interrupt enabled\nBit 9STBITERRIE: Start bit error interrupt enable\nSet and cleared by software to enable/disable interrupt caused by start bit error.\n0: Start bit error interrupt disabled\n1: Start bit error interrupt enabled\nBit 8DATAENDIE: Data end interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data end.\n0: Data end interrupt disabled\n1: Data end interrupt enabled\nBit 7CMDSENTIE: Command sent interrupt enable\nSet and cleared by software to enable/disable interrupt caused by sending command.\n0: Command sent interrupt disabled\n1: Command sent interrupt enabled\nRM0008Secure digital input/output interface (SDIO)\nDoc ID 13902 Rev 9509/995"
  },
  {
    "start_page": 509,
    "end_page": 510,
    "page_range": "509-510",
    "section": "20.9.14",
    "full_name": "SDIO FIFO counter register (SDIO_FIFOCNT)",
    "short_name": "SDIO_FIFOCNT",
    "address_offset": "0x48",
    "reset_value": "0x0000 0000",
    "content": "The SDIO_FIFOCNT register contains the remaining number of words to be written to or\nread from the FIFO. The FIFO counter loads the value from the data length register (see\nSDIO_DLEN) when the data transfer enable bit, DTEN, is set in the data control register\n(SDIO_DCTRL register) and the DPSM is at the Idle state. If the data length is not word-\naligned (multiple of 4), the remaining 1 to 3 bytes are regarded as a word.\nBit 6CMDRENDIE: Command response received interrupt enable\nSet and cleared by software to enable/disable interrupt caused by receiving command\n0: Command response received interrupt disabled\n1: command Response Received interrupt enabled\nBit 5RXOVERRIE: Rx FIFO overrun error interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.\n0: Rx FIFO overrun error interrupt disabled\n1: Rx FIFO overrun error interrupt enabled\nBit 4TXUNDERRIE: Tx FIFO underrun error interrupt enable\nSet and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.\n0: Tx FIFO underrun error interrupt disabled\n1: Tx FIFO underrun error interrupt enabled\nBit 3DTIMEOUTIE: Data timeout interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data timeout.\n0: Data timeout interrupt disabled\n1: Data timeout interrupt enabled\nBit 2CTIMEOUTIE: Command timeout interrupt enable\nSet and cleared by software to enable/disable interrupt caused by command timeout.\n0: Command timeout interrupt disabled\n1: Command timeout interrupt enabled\nBit 1DCRCFAILIE: Data CRC fail interrupt enable\nSet and cleared by software to enable/disable interrupt caused by data CRC failure.\n0: Data CRC fail interrupt disabled\n1: Data CRC fail interrupt enabled\nBit 0CCRCFAILIE: Command CRC fail interrupt enable\nSet and cleared by software to enable/disable interrupt caused by command CRC failure.\n0: Command CRC fail interrupt disabled\n1: Command CRC fail interrupt enabled\nBits 31:24Reserved, always read as 0.\nBits 23:0FIFOCOUNT: Remaining number of words to be written to or read from the FIFO.\nSecure digital input/output interface (SDIO)RM0008\n510/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 510,
    "end_page": 510,
    "page_range": "510",
    "section": "20.9.15",
    "full_name": "SDIO data FIFO register (SDIO_FIFO)",
    "short_name": "SDIO_FIFO",
    "address_offset": "0x80",
    "reset_value": "0x0000 0000",
    "content": "The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs\ncontain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store\nmultiple operands to read from/write to the FIFO."
  },
  {
    "start_page": 526,
    "end_page": 528,
    "page_range": "526-528",
    "section": "",
    "full_name": "USB control register (USB_CNTR)",
    "short_name": "USB_CNTR",
    "address_offset": "0x40",
    "reset_value": "0x0003",
    "content": "Bit 15CTRM: Correct transfer interrupt mask\n0: Correct Transfer (CTR) Interrupt disabled.\n1: CTR Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 14PMAOVRM: Packet memory area over / underrun interrupt mask\n0: PMAOVR Interrupt disabled.\n1: PMAOVR Interrupt enabled, an interrupt request is generated when the corresponding bit\nin the USB_ISTR register is set.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9527/995\nBit 13ERRM: Error interrupt mask\n0: ERR Interrupt disabled.\n1: ERR Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 12WKUPM: Wakeup interrupt mask\n0: WKUP Interrupt disabled.\n1: WKUP Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 11SUSPM: Suspend mode interrupt mask\n0: Suspend Mode Request (SUSP) Interrupt disabled.\n1: SUSP Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 10RESETM: USB reset interrupt mask\n0: RESET Interrupt disabled.\n1: RESET Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 9SOFM: Start of frame interrupt mask\n0: SOF Interrupt disabled.\n1: SOF Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBit 8ESOFM: Expected start of frame interrupt mask\n0: Expected Start of Frame (ESOF) Interrupt disabled.\n1: ESOF Interrupt enabled, an interrupt request is generated when the corresponding bit in\nthe USB_ISTR register is set.\nBits 7:5Reserved.\nBit 4RESUME: Resume request\nThe microcontroller can set this bit to send a Resume signal to the host. It must be\nactivated, according to USB specifications, for no less than 1mS and no more than 15mS\nafter which the Host PC is ready to drive the resume sequence up to its end.\nBit 3FSUSP: Force suspend\nSoftware must set this bit when the SUSP interrupt is received, which is issued when no\ntraffic is received by the USB peripheral for 3 mS.\n0: No effect.\n1: Enter suspend mode. Clocks and static power dissipation in the analog transceiver are\nleft unaffected. If suspend power consumption is a requirement (bus-powered device), the\napplication software should set the LP_MODE bit after FSUSP as explained below.\nBit 2LP_MODE: Low-power mode\nThis mode is used when the suspend-mode power constraints require that all static power\ndissipation is avoided, except the one required to supply the external pull-up resistor. This\ncondition should be entered when the application is ready to stop all system clocks, or\nreduce their frequency in order to meet the power consumption requirements of the USB\nsuspend condition. The USB activity during the suspend mode (WKUP event)\nasynchronously resets this bit (it can also be reset by software).\n0: No Low-power mode.\n1: Enter Low-power mode.\nUniversal serial bus full-speed device interface (USB)RM0008\n528/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 528,
    "end_page": 531,
    "page_range": "528-531",
    "section": "",
    "full_name": "USB interrupt status register (USB_ISTR)",
    "short_name": "USB_ISTR",
    "address_offset": "0x44",
    "reset_value": "0x0000 0000",
    "content": "This register contains the status of all the interrupt sources allowing application software to\ndetermine, which events caused an interrupt request.\nThe upper part of this register contains single bits, each of them representing a specific\nevent. These bits are set by the hardware when the related event occurs; if the\ncorresponding bit in the USB_CNTR register is set, a generic interrupt request is generated.\nThe interrupt routine, examining each bit, will perform all necessary actions, and finally it will\nclear the serviced bits. If any of them is not cleared, the interrupt is considered to be still\npending, and the interrupt line will be kept high again. If several bits are set simultaneously,\nonly a single interrupt will be generated.\nEndpoint transaction completion can be handled in a different way to reduce interrupt\nresponse latency. The CTR bit is set by the hardware as soon as an endpoint successfully\ncompletes a transaction, generating a generic interrupt request if the corresponding bit in\nUSB_CNTR is set. An endpoint dedicated interrupt condition is activated independently\nfrom the CTRM bit in the USB_CNTR register. Both interrupt conditions remain active until\nsoftware clears the pending bit in the corresponding USB_EPnR register (the CTR bit is\nactually a read only bit). For endpoint-related interrupts, the software can use the Direction\nof Transaction (DIR) and EP_ID read-only bits to identify, which endpoint made the last\ninterrupt request and called the corresponding interrupt service routine.\nThe user can choose the relative priority of simultaneously pending USB_ISTR events by\nspecifying the order in which software checks USB_ISTR bits in an interrupt service routine.\nOnly the bits related to events, which are serviced, are cleared. At the end of the service\nroutine, another interrupt will be requested, to service the remaining conditions.\nTo avoid spurious clearing of some bits, it is recommended to clear them with a load\ninstruction where all bits which must not be altered are written with 1, and all bits to be\ncleared are written with ‘0’ (these bits can only be cleared by software). Read-modify-write\ncycles should be avoided because between the read and the write operations another bit\nBit 1PDWN: Power down\nThis bit is used to completely switch off all USB-related analog parts if it is required to\ncompletely disable the USB peripheral for any reason. When this bit is set, the USB\nperipheral is disconnected from the transceivers and it cannot be used.\n0: Exit Power Down.\n1: Enter Power down mode.\nBit 0FRES: Force USB Reset\n0: Clear USB reset.\n1: Force a reset of the USB peripheral, exactly like a RESET signalling on the USB. The\nUSB peripheral is held in RESET state until software clears this bit. A “USB-RESET”\ninterrupt is generated, if enabled.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9529/995\ncould be set by the hardware and the next write will clear it before the microprocessor has\nthe time to serve the event.\nThe following describes each bit in detail:\nBit 15CTR: Correct transfer\nThis bit is set by the hardware to indicate that an endpoint has successfully completed a\ntransaction; using DIR and EP_ID bits software can determine which endpoint requested the\ninterrupt. This bit is read-only.\nBit 14PMAOVR: Packet memory area over / underrun\nThis bit is set if the microcontroller has not been able to respond in time to an USB memory\nrequest. The USB peripheral handles this event in the following way: During reception an\nACK handshake packet is not sent, during transmission a bit-stuff error is forced on the\ntransmitted stream; in both cases the host will retry the transaction. The PMAOVR interrupt\nshould never occur during normal operations. Since the failed transaction is retried by the\nhost, the application software has the chance to speed-up device operations during this\ninterrupt handling, to be ready for the next transaction retry; however this does not happen\nduring Isochronous transfers (no isochronous transaction is anyway retried) leading to a loss\nof data in this case. This bit is read/write but only ‘0’ can be written and writing ‘1’ has no\nBit 13ERR: Error\nThis flag is set whenever one of the errors listed below has occurred:\nNANS: No ANSwer. The timeout for a host response has expired.\nCRC: Cyclic Redundancy Check error. One of the received CRCs, either in the token or in\nthe data, was wrong.\nBST: Bit Stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or\nFVIO: Framing format Violation. A non-standard frame was received (EOP not in the right\nplace, wrong token sequence, etc.).\nThe USB software can usually ignore errors, since the USB peripheral and the PC host\nmanage retransmission in case of errors in a fully transparent way. This interrupt can be\nuseful during the software development phase, or to monitor the quality of transmission over\nthe USB bus, to flag possible problems to the user (e.g. loose connector, too noisy\nenvironment, broken conductor in the USB cable and so on). This bit is read/write but only ‘0’\ncan be written and writing ‘1’ has no effect.\nBit 12WKUP: Wakeup\nThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that\nwakes up the USB peripheral. This event asynchronously clears the LP_MODE bit in the\nCTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of\nthe device (e.g. wakeup unit) about the start of the resume process. This bit is read/write but\nonly ‘0’ can be written and writing ‘1’ has no effect.\nBit 11SUSP: Suspend mode request\nThis bit is set by the hardware when no traffic has been received for 3mS, indicating a\nsuspend mode request from the USB bus. The suspend condition check is enabled\nimmediately after any USB reset and it is disabled by the hardware when the suspend mode\nis active (FSUSP=1) until the end of resume sequence. This bit is read/write but only ‘0’ can\nbe written and writing ‘1’ has no effect.\nUniversal serial bus full-speed device interface (USB)RM0008\n530/995 Doc ID 13902 Rev 9\nBit 10RESET: USB reset request\nSet when the USB peripheral detects an active USB RESET signal at its inputs. The USB\nperipheral, in response to a RESET, just resets its internal protocol state machine,\ngenerating an interrupt if RESETM enable bit in the USB_CNTR register is set. Reception\nand transmission are disabled until the RESET bit is cleared. All configuration registers do\nnot reset: the microcontroller must explicitly clear these registers (this is to ensure that the\nRESET interrupt can be safely delivered, and any transaction immediately followed by a\nRESET can be completed). The function address and endpoint registers are reset by an\nUSB reset event.\nThis bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect.\nBit 9SOF: Start of frame\nThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives\nthrough the USB bus. The interrupt service routine may monitor the SOF events to have a\n1mS synchronization event to the USB host and to safely read the USB_FNR register which\nis updated at the SOF packet reception (this could be useful for isochronous applications).\nThis bit is read/write but only ‘0’ can be written and writing ‘1’ has no effect.\nBit 8ESOF: Expected start of frame\nThis bit is set by the hardware when an SOF packet is expected but not received. The host\nsends an SOF packet each mS, but if the hub does not receive it properly, the Suspend\nTimer issues this interrupt. If three consecutive ESOF interrupts are generated (i.e. three\nSOF packets are lost) without any traffic occurring in between, a SUSP interrupt is\ngenerated. This bit is set even when the missing SOF packets occur while the Suspend\nTimer is not yet locked. This bit is read/write but only ‘0’ can be written and writing ‘1’ has no\nBits 7:5Reserved.\nBit 4DIR: Direction of transaction\nThis bit is written by the hardware according to the direction of the successful transaction,\nwhich generated the interrupt request.\nIf DIR bit=0, CTR_TX bit is set in the USB_EPnR register related to the interrupting endpoint.\nThe interrupting transaction is of IN type (data transmitted by the USB peripheral to the host\nIf DIR bit=1, CTR_RX bit or both CTR_TX/CTR_RX are set in the USB_EPnR register\nrelated to the interrupting endpoint. The interrupting transaction is of OUT type (data\nreceived by the USB peripheral from the host PC) or two pending transactions are waiting to\nbe processed.\nThis information can be used by the application software to access the USB_EPnR bits\nrelated to the triggering transaction since it represents the direction having the interrupt\npending. This bit is read-only.\nBits 3:0EP_ID[3:0]: Endpoint Identifier\nThese bits are written by the hardware according to the endpoint number, which generated\nthe interrupt request. If several endpoint transactions are pending, the hardware writes the\nendpoint identifier related to the endpoint having the highest priority defined in the following\nway: Two endpoint sets are defined, in order of priority: Isochronous and double-buffered\nbulk endpoints are considered first and then the other endpoints are examined. If more than\none endpoint from the same set is requesting an interrupt, the EP_ID bits in USB_ISTR\nregister are assigned according to the lowest requesting endpoint register, EP0R having the\nhighest priority followed by EP1R and so on. The application software can assign a register\nto each endpoint according to this priority scheme, so as to order the concurring endpoint\nrequests in a suitable way. These bits are read only.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9531/995"
  },
  {
    "start_page": 531,
    "end_page": 532,
    "page_range": "531-532",
    "section": "",
    "full_name": "USB frame number register (USB_FNR)",
    "short_name": "USB_FNR",
    "address_offset": "0x48",
    "reset_value": "0x0",
    "content": "USB device address (USB_DADDR)\nAddress offset: 0x4C\nReset value: 0x0000\nBit 15RXDP: Receive data + line status\nThis bit can be used to observe the status of received data plus upstream port data line. It\ncan be used during end-of-suspend routines to help determining the wakeup event.\nBit 14RXDM: Receive data - line status\nThis bit can be used to observe the status of received data minus upstream port data line. It\ncan be used during end-of-suspend routines to help determining the wakeup event.\nBit 13LCK: Locked\nThis bit is set by the hardware when at least two consecutive SOF packets have been\nreceived after the end of an USB reset condition or after the end of an USB resume\nsequence. Once locked, the frame timer remains in this state until an USB reset or USB\nsuspend event occurs.\nBits 12:11LSOF[1:0]: Lost SOF\nThese bits are written by the hardware when an ESOF interrupt is generated, counting the\nnumber of consecutive SOF packets lost. At the reception of an SOF packet, these bits are\nBits 10:0FN[10:0]: Frame number\nThis bit field contains the 11-bits frame number contained in the last received SOF packet.\nThe frame number is incremented for every frame sent by the host and it is useful for\nIsochronous transfers. This bit field is updated on the generation of an SOF interrupt.\nBits 15:8Reserved\nBit 7EF: Enable function\nThis bit is set by the software to enable the USB device. The address of this device is\ncontained in the following ADD[6:0] bits. If this bit is at ‘0’ no transactions are handled,\nirrespective of the settings of USB_EPnR registers.\nUniversal serial bus full-speed device interface (USB)RM0008\n532/995 Doc ID 13902 Rev 9\nBuffer table address (USB_BTABLE)\nAddress offset: 0x50\nReset value: 0x0000"
  },
  {
    "start_page": 532,
    "end_page": 540,
    "page_range": "532-540",
    "section": "",
    "full_name": "USB endpoint n register (USB_EPnR), n=[0..7]",
    "short_name": "",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "They are also reset when an USB reset is received from the USB bus or forced through bit\nFRES in the CTLR register, except the CTR_RX and CTR_TX bits, which are kept\nunchanged to avoid missing a correct packet notification immediately followed by an USB\nreset event. Each endpoint has its USB_EPnR register where n is the endpoint identifier.\nBits 6:0ADD[6:0]: Device address\nThese bits contain the USB function address assigned by the host PC during the\nenumeration process. Both this field and the Endpoint Address (EA) field in the associated\nUSB_EPnR register must match with the information contained in a USB token in order to\nhandle a transaction to the required endpoint.\nBits 15:3BTABLE[15:3]: Buffer table\nThese bits contain the start address of the buffer allocation table inside the dedicated packet\nmemory. This table describes each endpoint buffer location and size and it must be aligned\nto an 8 byte boundary (the 3 least significant bits are always ‘0’). At the beginning of every\ntransaction addressed to this device, the USP peripheral reads the element of this table\nrelated to the addressed endpoint, to get its buffer start location and the buffer size (Refer to\nStructure and usage of packet buffers on page516).\nBits 2:0Reserved, forced by hardware to 0.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9533/995\nRead-modify-write cycles on these registers should be avoided because between the read\nand the write operations some bits could be set by the hardware and the next write would\nmodify them before the CPU has the time to detect the change. For this purpose, all bits\naffected by this problem have an ‘invariant’ value that must be used whenever their\nmodification is not required. It is recommended to modify these registers with a load\ninstruction where all the bits, which can be modified only by the hardware, are written with\ntheir ‘invariant’ value.\nBit 15CTR_RX: Correct Transfer for reception\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed\non this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register\nis set accordingly, a generic interrupt condition is generated together with the endpoint\nrelated interrupt condition, which is always activated. The type of occurred transaction, OUT\nor SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is\nactually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written, writing 1 has no effect.\nBit 14DTOG_RX: Data Toggle, for reception transfers\nIf the endpoint is not Isochronous, this bit contains the expected value of the data toggle bit\n(0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit,\nwhen the ACK handshake is sent to the USB host, following a data packet reception having\na matching data PID value; if the endpoint is defined as a control one, hardware clears this\nbit at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint is using the double-buffering feature this bit is used to support packet buffer\nswapping too (Refer to Section21.4.3: Double-buffered endpoints).\nIf the endpoint is Isochronous, this bit is used only to support packet buffer swapping since\nno data toggling is used for this sort of endpoints and only DATA0 packet are transmitted\n(Refer to Section21.4.4: Isochronous transfers). Hardware toggles this bit just after the end\nof data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the\nendpoint is not a control one) or to force specific data toggle/packet buffer usage. When the\napplication software writes ‘0’, the value of DTOG_RX remains unchanged, while writing ‘1’\nmakes the bit value toggle. This bit is read/write but it can be only toggled by writing 1.\nBits 13:12STAT_RX [1:0]: Status bits, for reception transfers\nThese bits contain information about the endpoint status, which are listed in Table156:\nReception status encoding on page535.These bits can be toggled by software to initialize\ntheir value. When the application software writes ‘0’, the value remains unchanged, while\nwriting ‘1’ makes the bit value toggle. Hardware sets the STAT_RX bits to NAK when a\ncorrect transfer has occurred (CTR_RX=1) corresponding to a OUT or SETUP (control only)\ntransaction addressed to this endpoint, so the software has the time to elaborate the\nreceived data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control\nthe status based upon buffer availability condition (Refer to Section21.4.3: Double-buffered\nIf the endpoint is defined as Isochronous, its status can be only “VALID” or “DISABLED”, so\nthat the hardware cannot change the status of the endpoint after a successful transaction. If\nthe software sets the STAT_RX bits to ‘STALL’ or ‘NAK’ for an Isochronous endpoint, the\nUSB peripheral behavior is not defined. These bits are read/write but they can be only\ntoggled by writing ‘1’.\nUniversal serial bus full-speed device interface (USB)RM0008\n534/995 Doc ID 13902 Rev 9\nBit 11SETUP: Setup transaction completed\nThis bit is read-only and it is set by the hardware when the last completed transaction is a\nSETUP. This bit changes its value only for control endpoints. It must be examined, in the\ncase of a successful receive transaction (CTR_RX event), to determine the type of\ntransaction occurred. To protect the interrupt service routine from the changes in SETUP\nbits due to next incoming tokens, this bit is kept frozen while CTR_RX bit is at 1; its state\nchanges when CTR_RX is at 0. This bit is read-only.\nBits 10:9EP_TYPE[1:0]: Endpoint type\nThese bits configure the behavior of this endpoint as described in Table157: Endpoint type\nencoding on page535. Endpoint 0 must always be a control endpoint and each USB\nfunction must have at least one control endpoint which has address 0, but there may be\nother control endpoints if required. Only control endpoints handle SETUP transactions,\nwhich are ignored by endpoints of other kinds. SETUP transactions cannot be answered\nwith NAK or STALL. If a control endpoint is defined as NAK, the USB peripheral will not\nanswer, simulating a receive error, in the receive direction when a SETUP transaction is\nreceived. If the control endpoint is defined as STALL in the receive direction, then the\nSETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt.\nThe reception of OUT transactions is handled in the normal way, even if the endpoint is a\ncontrol one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special\nfeature available using the EP_KIND configuration bit.\nThe usage of Isochronous endpoints is explained in Section21.4.4: Isochronous transfers\nBit 8EP_KIND: Endpoint kind\nThe meaning of this bit depends on the endpoint type configured by the EP_TYPE bits.\nTable158 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk\nendpoint. The usage of double-buffered bulk endpoints is explained in Section21.4.3:\nDouble-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is\nexpected: in this case all OUT transactions containing more than zero data bytes are\nanswered ‘STALL’ instead of ‘ACK’. This bit may be used to improve the robustness of the\napplication to protocol errors during control transfers and its usage is intended for control\nendpoints only. When STATUS_OUT is reset, OUT transactions can have any number of\nbytes, as required.\nBit 7CTR_TX: Correct Transfer for transmission\nThis bit is set by the hardware when an IN transaction is successfully completed on this\nendpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is\nset accordingly, a generic interrupt condition is generated together with the endpoint related\ninterrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is\nactually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only ‘0’ can be written.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9535/995\nBit 6DTOG_TX: Data Toggle, for transmission transfers\nIf the endpoint is non-isochronous, this bit contains the required value of the data toggle bit\n(0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit\nwhen the ACK handshake is received from the USB host, following a data packet\ntransmission. If the endpoint is defined as a control one, hardware sets this bit to 1 at the\nreception of a SETUP PID addressed to this endpoint.\nIf the endpoint is using the double buffer feature, this bit is used to support packet buffer\nswapping too (Refer to Section21.4.3: Double-buffered endpoints)\nIf the endpoint is Isochronous, this bit is used to support packet buffer swapping since no\ndata toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer\nto Section21.4.4: Isochronous transfers). Hardware toggles this bit just after the end of data\npacket transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the\nendpoint is not a control one) or to force a specific data toggle/packet buffer usage. When\nthe application software writes ‘0’, the value of DTOG_TX remains unchanged, while writing\n‘1’ makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1.\nBits 5:4STAT_TX [1:0]: Status bits, for transmission transfers\nThese bits contain the information about the endpoint status, listed in Table159. These bits\ncan be toggled by the software to initialize their value. When the application software writes\n‘0’, the value remains unchanged, while writing ‘1’ makes the bit value toggle. Hardware\nsets the STAT_TX bits to NAK, when a correct transfer has occurred (CTR_TX=1)\ncorresponding to a IN or SETUP (control only) transaction addressed to this endpoint. It\nthen waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls\nthe status based on buffer availability condition (Refer to Section21.4.3: Double-buffered\nIf the endpoint is defined as Isochronous, its status can only be “VALID” or “DISABLED”.\nTherefore, the hardware cannot change the status of the endpoint after a successful\ntransaction. If the software sets the STAT_TX bits to ‘STALL’ or ‘NAK’ for an Isochronous\nendpoint, the USB peripheral behavior is not defined. These bits are read/write but they can\nbe only toggled by writing ‘1’.\nBits 3:0EA[3:0]: Endpoint address\nSoftware must write in this field the 4-bit address used to identify the transactions directed\nto this endpoint. A value must be written before enabling the corresponding endpoint.\nTable 156.Reception status encoding\n00DISABLED: all reception requests addressed to this endpoint are ignored.\nSTALL: the endpoint is stalled and all reception requests result in a STALL\n10NAK: the endpoint is naked and all reception requests result in a NAK handshake.\n11VALID: this endpoint is enabled for reception.\nTable 157.Endpoint type encoding\nUniversal serial bus full-speed device interface (USB)RM0008\n536/995 Doc ID 13902 Rev 9\n21.5.3 Buffer descriptor table\nAlthough the buffer descriptor table is located inside the packet buffer memory, its entries\ncan be considered as additional registers used to configure the location and size of the\npacket buffers used to exchange data between the USB macro cell and the STM32F10xxx.\nDue to the common APB bridge limitation on word addressability, all packet memory\nlocations are accessed by the APB using 32-bit aligned addresses, instead of the actual\nmemory location addresses utilized by the USB peripheral for the USB_BTABLE register\nand buffer description table locations.\nIn the following pages two location addresses are reported: the one to be used by\napplication software while accessing the packet memory, and the local one relative to USB\nPeripheral access. To obtain the correct STM32F10xxx memory address value to be used in\nthe application software while accessing the packet memory, the actual memory location\naddress must be multiplied by two. The first packet memory location is located at\n0x40006000. The buffer descriptor table entry associated with the USB_EPnR registers is\ndescribed below.\nA thorough explanation of packet buffers and the buffer descriptor table usage can be found\nin Structure and usage of packet buffers on page516.\nTable 158.Endpoint kind meaning\nEP_TYPE[1:0]EP_KIND Meaning\n10ISONot used\n11INTERRUPTNot used\nTable 159.Transmission status encoding\n00DISABLED: all transmission requests addressed to this endpoint are ignored.\nSTALL: the endpoint is stalled and all transmission requests result in a STALL\nNAK: the endpoint is naked and all transmission requests result in a NAK\n11VALID: this endpoint is enabled for transmission.\nTable 157.Endpoint type encoding (continued)\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9537/995\nTransmission buffer address n (USB_ADDRn_TX)\nAddress offset: [USB_BTABLE] + n*16\nUSB local address: [USB_BTABLE] + n*8\nTransmission byte count n (USB_COUNTn_TX)\nAddress offset: [USB_BTABLE] + n*16 + 4\nUSB local Address: [USB_BTABLE] + n*8 + 2\nNote:Double-buffered and Isochronous IN Endpoints have two USB_COUNTn_TX\nregisters: named USB_COUNTn_TX_1 and USB_COUNTn_TX_0 with the\nfollowing content.\nBits 15:1ADDRn_TX[15:1]: Transmission buffer address\nThese bits point to the starting address of the packet buffer containing data to be transmitted\nby the endpoint associated with the USB_EPnR register at the next IN token addressed to it.\nBit 0Must always be written as ‘0’ since packet memory is word-wide and all packet buffers must be\nBits 15:10These bits are not used since packet size is limited by USB specifications to 1023 bytes. Their\nvalue is not considered by the USB peripheral.\nBits 9:0COUNTn_TX[9:0]: Transmission byte count\nThese bits contain the number of bytes to be transmitted by the endpoint associated with the\nUSB_EPnR register at the next IN token addressed to it.\nUniversal serial bus full-speed device interface (USB)RM0008\n538/995 Doc ID 13902 Rev 9\nReception buffer address n (USB_ADDRn_RX)\nAddress offset: [USB_BTABLE] + n*16 + 8\nUSB local Address: [USB_BTABLE] + n*8 + 4\nReception byte count n (USB_COUNTn_RX)\nAddress offset: [USB_BTABLE] + n*16 + 12\nUSB local Address: [USB_BTABLE] + n*8 + 6\nThis table location is used to store two different values, both required during packet\nreception. The most significant bits contains the definition of allocated buffer size, to allow\nbuffer overflow detection, while the least significant part of this location is written back by the\nUSB peripheral at the end of reception to give the actual number of received bytes. Due to\nthe restrictions on the number of available bits, buffer size is represented using the number\nof allocated memory blocks, where block size can be selected to choose the trade-off\nbetween fine-granularity/small-buffer and coarse-granularity/large-buffer. The size of\nallocated buffer is a part of the endpoint descriptor and it is normally defined during the\nenumeration process according to its maxPacketSize parameter value (See “Universal\nSerial Bus Specification”).\nBits 15:1ADDRn_RX[15:1]: Reception buffer address\nThese bits point to the starting address of the packet buffer, which will contain the data\nreceived by the endpoint associated with the USB_EPnR register at the next OUT/SETUP\ntoken addressed to it.\nBit 0This bit must always be written as ‘0’ since packet memory is word-wide and all packet buffers\nmust be word-aligned.\nRM0008Universal serial bus full-speed device interface (USB)\nDoc ID 13902 Rev 9539/995\nNote:Double-buffered and Isochronous IN Endpoints have two USB_COUNTn_TX\nregisters: named USB_COUNTn_TX_1 and USB_COUNTn_TX_0 with the\nfollowing content.\nBit 15BL_SIZE: BLock size\nThis bit selects the size of memory block used to define the allocated buffer area.\n–If BL_SIZE=0, the memory block is 2 byte large, which is the minimum block allowed in a\nword-wide memory. With this block size the allocated buffer size ranges from 2 to 62 bytes.\n–If BL_SIZE=1, the memory block is 32 byte large, which allows to reach the maximum\npacket length defined by USB specifications. With this block size the allocated buffer size\nranges from 32 to 1024 bytes, which is the longest packet size allowed by USB standard\nBits 14:10NUM_BLOCK[4:0]: Number of blocks\nThese bits define the number of memory blocks allocated to this packet buffer. The actual\namount of allocated memory depends on the BL_SIZE value as illustrated in Table160.\nBits 9:0COUNTn_RX[9:0]: Reception byte count\nThese bits contain the number of bytes received by the endpoint associated with the\nUSB_EPnR register during the last OUT/SETUP transaction addressed to it.\nTable 160.Definition of allocated buffer memory\nValue of\nMemory allocated\nwhen BL_SIZE=0\nMemory allocated\nwhen BL_SIZE=1\n0 (‘00000’)Not allowed32 bytes\n1 (‘00001’)2 bytes64 bytes\n2 (‘00010’)4 bytes96 bytes\n3 (‘00011’)6 bytes128 bytes\n15 (‘01111’)30 bytes512 bytes\n16 (‘10000’)32 bytesN/A\n17 (‘10001’)34 bytesN/A\n18 (‘10010’)36 bytesN/A\n30 (‘11110’)60 bytesN/A\n31 (‘11111’)62 bytesN/A\nUniversal serial bus full-speed device interface (USB)RM0008\n540/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 562,
    "end_page": 564,
    "page_range": "562-564",
    "section": "",
    "full_name": "CAN master control register (CAN_MCR)",
    "short_name": "CAN_MCR",
    "address_offset": "0x00",
    "reset_value": "0x0001 0002",
    "content": "Bits 31:17Reserved, forced by hardware to 0.\nBit 16DBF: Debug freeze\n0: CAN working during debug\n1: CAN reception/transmission frozen during debug. Reception FIFOs can still be\naccessed/controlled normally.\nBit 15RESET: bxCAN software master reset\n0: Normal operation.\n1: Force a master reset of the bxCAN -> Sleep mode activated after reset (FMP bits and\nCAN_MCR register are initialized to the reset values). This bit is automatically reset to 0.\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9563/995\nBits 14:8Reserved, forced by hardware to 0.\nBit 7TTCM: Time triggered communication mode\n0: Time Triggered Communication mode disabled.\n1: Time Triggered Communication mode enabled\nNote:For more information on Time Triggered Communication mode, please refer to\nSection22.7.2: Time triggered communication mode.\nBit 6ABOM: Automatic bus-off management\nThis bit controls the behavior of the CAN hardware on leaving the Bus-Off state.\n0: The Bus-Off state is left on software request, once 128 occurrences of 11 recessive bits\nhave been monitored and the software has first set and cleared the INRQ bit of the\nCAN_MCR register.\n1: The Bus-Off state is left automatically by hardware once 128 occurrences of 11 recessive\nbits have been monitored.\nFor detailed information on the Bus-Off state please refer to Section22.7.6: Error\nBit 5AWUM: Automatic wakeup mode\nThis bit controls the behavior of the CAN hardware on message reception during Sleep\n0: The Sleep mode is left on software request by clearing the SLEEP bit of the CAN_MCR\n1: The Sleep mode is left automatically by hardware on CAN message detection.\nThe SLEEP bit of the CAN_MCR register and the SLAK bit of the CAN_MSR register are\ncleared by hardware.\nBit 4NART: No automatic retransmission\n0: The CAN hardware will automatically retransmit the message until it has been\nsuccessfully transmitted according to the CAN standard.\n1: A message will be transmitted only once, independently of the transmission result\n(successful, error or arbitration lost).\nBit 3RFLM: Receive FIFO locked mode\n0: Receive FIFO not locked on overrun. Once a receive FIFO is full the next incoming\nmessage will overwrite the previous one.\n1: Receive FIFO locked against overrun. Once a receive FIFO is full the next incoming\nmessage will be discarded.\nBit 2TXFP: Transmit FIFO priority\nThis bit controls the transmission order when several mailboxes are pending at the same\n0: Priority driven by the identifier of the message\n1: Priority driven by the request order (chronologically)\nBit 1SLEEP: Sleep mode request\nThis bit is set by software to request the CAN hardware to enter the Sleep mode. Sleep\nmode will be entered as soon as the current CAN activity (transmission or reception of a\nCAN frame) has been completed.\nThis bit is cleared by software to exit Sleep mode.\nThis bit is cleared by hardware when the AWUM bit is set and a SOF bit is detected on the\nCAN Rx signal.\nThis bit is set after reset - CAN starts in Sleep mode.\nController area network (bxCAN)RM0008\n564/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 564,
    "end_page": 565,
    "page_range": "564-565",
    "section": "",
    "full_name": "CAN master status register (CAN_MSR)",
    "short_name": "CAN_MSR",
    "address_offset": "0x04",
    "reset_value": "0x0000 0C02",
    "content": "Bit 0INRQ: Initialization request\nThe software clears this bit to switch the hardware into normal mode. Once 11 consecutive\nrecessive bits have been monitored on the Rx signal the CAN hardware is synchronized and\nready for transmission and reception. Hardware signals this event by clearing the INAK bit in\nthe CAN_MSR register.\nSoftware sets this bit to request the CAN hardware to enter initialization mode. Once\nsoftware has set the INRQ bit, the CAN hardware waits until the current CAN activity\n(transmission or reception) is completed before entering the initialization mode. Hardware\nsignals this event by setting the INAK bit in the CAN_MSR register.\nBits 31:12Reserved, forced by hardware to 0.\nBit 11RX: CAN Rx signal\nMonitors the actual value of the CAN_RX Pin.\nBit 10SAMP: Last sample point\nThe value of RX on the last sample point (current received bit value).\nBit 9RXM: Receive mode\nThe CAN hardware is currently receiver.\nBit 8TXM: Transmit mode\nThe CAN hardware is currently transmitter.\nBits 7:5Reserved, forced by hardware to 0.\nBit 4SLAKI: Sleep acknowledge interrupt\nWhen SLKIE=1, this bit is set by hardware to signal that the bxCAN has entered Sleep\nMode. When set, this bit generates a status change interrupt if the SLKIE bit in the\nCAN_IER register is set.\nThis bit is cleared by software or by hardware, when SLAK is cleared.\nNote:When SLKIE=0, no polling on SLAKI is possible. In this case the SLAK bit can be\nBit 3WKUI: Wakeup interrupt\nThis bit is set by hardware to signal that a SOF bit has been detected while the CAN\nhardware was in Sleep mode. Setting this bit generates a status change interrupt if the\nWKUIE bit in the CAN_IER register is set.\nThis bit is cleared by software.\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9565/995"
  },
  {
    "start_page": 565,
    "end_page": 567,
    "page_range": "565-567",
    "section": "",
    "full_name": "CAN transmit status register (CAN_TSR)",
    "short_name": "CAN_TSR",
    "address_offset": "0x08",
    "reset_value": "0x1C00 0000",
    "content": "Bit 2ERRI: Error interrupt\nThis bit is set by hardware when a bit of the CAN_ESR has been set on error detection and\nthe corresponding interrupt in the CAN_IER is enabled. Setting this bit generates a status\nchange interrupt if the ERRIE bit in the CAN_IER register is set.\nThis bit is cleared by software.\nBit 1SLAK: Sleep acknowledge\nThis bit is set by hardware and indicates to the software that the CAN hardware is now in\nSleep mode. This bit acknowledges the Sleep mode request from the software (set SLEEP\nbit in CAN_MCR register).\nThis bit is cleared by hardware when the CAN hardware has left Sleep mode (to be\nsynchronized on the CAN bus). To be synchronized the hardware has to monitor a\nsequence of 11 consecutive recessive bits on the CAN RX signal.\nNote:The process of leaving Sleep mode is triggered when the SLEEP bit in the CAN_MCR\nregister is cleared. Please refer to the AWUM bit of the CAN_MCR register description\nfor detailed information for clearing SLEEP bit\nBit 0INAK: Initialization acknowledge\nThis bit is set by hardware and indicates to the software that the CAN hardware is now in\ninitialization mode. This bit acknowledges the initialization request from the software (set\nINRQ bit in CAN_MCR register).\nThis bit is cleared by hardware when the CAN hardware has left the initialization mode (to\nbe synchronized on the CAN bus). To be synchronized the hardware has to monitor a\nsequence of 11 consecutive recessive bits on the CAN RX signal.\nBit 31LOW2: Lowest priority flag for mailbox 2\nThis bit is set by hardware when more than one mailbox are pending for transmission and\nmailbox 2 has the lowest priority.\nBit 30LOW1: Lowest priority flag for mailbox 1\nThis bit is set by hardware when more than one mailbox are pending for transmission and\nmailbox 1 has the lowest priority.\nBit 29LOW0: Lowest priority flag for mailbox 0\nThis bit is set by hardware when more than one mailbox are pending for transmission and\nmailbox 0 has the lowest priority.\nNote:The LOW[2:0] bits are set to zero when only one mailbox is pending.\nBit 28TME2: Transmit mailbox 2 empty\nThis bit is set by hardware when no transmit request is pending for mailbox 2.\nController area network (bxCAN)RM0008\n566/995 Doc ID 13902 Rev 9\nBit 27TME1: Transmit mailbox 1 empty\nThis bit is set by hardware when no transmit request is pending for mailbox 1.\nBit 26TME0: Transmit mailbox 0 empty\nThis bit is set by hardware when no transmit request is pending for mailbox 0.\nBits 25:24CODE[1:0]: Mailbox code\nIn case at least one transmit mailbox is free, the code value is equal to the number of the\nnext transmit mailbox free.\nIn case all transmit mailboxes are pending, the code value is equal to the number of the\ntransmit mailbox with the lowest priority.\nBit 23ABRQ2: Abort request for mailbox 2\nSet by software to abort the transmission request for the corresponding mailbox.\nCleared by hardware when the mailbox becomes empty.\nSetting this bit has no effect when the mailbox is not pending for transmission.\nBits 22:20Reserved, forced by hardware to 0.\nBit 19TERR2: Transmission error of mailbox 2\nThis bit is set when the previous TX failed due to an error.\nBit 18ALST2: Arbitration lost for mailbox 2\nThis bit is set when the previous TX failed due to an arbitration lost.\nBit 17TXOK2: Transmission OK of mailbox 2\nThe hardware updates this bit after each transmission attempt.\n0: The previous transmission failed\n1: The previous transmission was successful\nThis bit is set by hardware when the transmission request on mailbox 2 has been completed\nsuccessfully. Please refer to Figure198.\nBit 16RQCP2: Request completed mailbox2\nSet by hardware when the last request (transmit or abort) has been performed.\nCleared by software writing a “1” or by hardware on transmission request (TXRQ2 set in\nCAN_TMID2R register).\nClearing this bit clears all the status bits (TXOK2, ALST2 and TERR2) for Mailbox 2.\nBit 15ABRQ1: Abort request for mailbox 1\nSet by software to abort the transmission request for the corresponding mailbox.\nCleared by hardware when the mailbox becomes empty.\nSetting this bit has no effect when the mailbox is not pending for transmission.\nBits 14:12Reserved, forced by hardware to 0.\nBit 11TERR1: Transmission error of mailbox1\nThis bit is set when the previous TX failed due to an error.\nBit 10ALST1: Arbitration lost for mailbox1\nThis bit is set when the previous TX failed due to an arbitration lost.\nBit 9TXOK1: Transmission OK of mailbox1\nThe hardware updates this bit after each transmission attempt.\n0: The previous transmission failed\n1: The previous transmission was successful\nThis bit is set by hardware when the transmission request on mailbox 1 has been completed\nsuccessfully. Please refer to Figure198\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9567/995"
  },
  {
    "start_page": 567,
    "end_page": 568,
    "page_range": "567-568",
    "section": "",
    "full_name": "CAN receive FIFO 0 register (CAN_RF0R)",
    "short_name": "CAN_RF0R",
    "address_offset": "0x0C",
    "reset_value": "0x00",
    "content": "Bit 8RQCP1: Request completed mailbox1\nSet by hardware when the last request (transmit or abort) has been performed.\nCleared by software writing a “1” or by hardware on transmission request (TXRQ1 set in\nCAN_TI1R register).\nClearing this bit clears all the status bits (TXOK1, ALST1 and TERR1) for Mailbox 1.\nBit 7ABRQ0: Abort request for mailbox0\nSet by software to abort the transmission request for the corresponding mailbox.\nCleared by hardware when the mailbox becomes empty.\nSetting this bit has no effect when the mailbox is not pending for transmission.\nBits 6:4Reserved, forced by hardware to 0.\nBit 3TERR0: Transmission error of mailbox0\nThis bit is set when the previous TX failed due to an error.\nBit 2ALST0: Arbitration lost for mailbox0\nThis bit is set when the previous TX failed due to an arbitration lost.\nBit 1TXOK0: Transmission OK of mailbox0\nThe hardware updates this bit after each transmission attempt.\n0: The previous transmission failed\n1: The previous transmission was successful\nThis bit is set by hardware when the transmission request on mailbox 1 has been completed\nsuccessfully. Please refer to Figure198\nBit 0RQCP0: Request completed mailbox0\nSet by hardware when the last request (transmit or abort) has been performed.\nCleared by software writing a “1” or by hardware on transmission request (TXRQ0 set in\nCAN_TI0R register).\nClearing this bit clears all the status bits (TXOK0, ALST0 and TERR0) for Mailbox 0.\nBit 31:6Reserved, forced by hardware to 0.\nBit 5RFOM0: Release FIFO 0 output mailbox\nSet by software to release the output mailbox of the FIFO. The output mailbox can only be\nreleased when at least one message is pending in the FIFO. Setting this bit when the FIFO\nis empty has no effect. If at least two messages are pending in the FIFO, the software has to\nrelease the output mailbox to access the next message.\nCleared by hardware when the output mailbox has been released.\nController area network (bxCAN)RM0008\n568/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 568,
    "end_page": 569,
    "page_range": "568-569",
    "section": "",
    "full_name": "CAN receive FIFO 1 register (CAN_RF1R)",
    "short_name": "CAN_RF1R",
    "address_offset": "0x10",
    "reset_value": "0x00",
    "content": "Bit 4FOVR0: FIFO 0 overrun\nThis bit is set by hardware when a new message has been received and passed the filter\nwhile the FIFO was full.\nThis bit is cleared by software.\nBit 3FULL0: FIFO 0 full\nSet by hardware when three messages are stored in the FIFO.\nThis bit is cleared by software.\nBit 2Reserved, forced by hardware to 0.\nBits 1:0FMP0[1:0]: FIFO 0 message pending\nThese bits indicate how many messages are pending in the receive FIFO.\nFMP is increased each time the hardware stores a new message in to the FIFO. FMP is\ndecreased each time the software releases the output mailbox by setting the RFOM0 bit.\nBits 31:6Reserved, forced by hardware to 0.\nBit 5RFOM1: Release FIFO 1 output mailbox\nSet by software to release the output mailbox of the FIFO. The output mailbox can only be\nreleased when at least one message is pending in the FIFO. Setting this bit when the FIFO\nis empty has no effect. If at least two messages are pending in the FIFO, the software has to\nrelease the output mailbox to access the next message.\nCleared by hardware when the output mailbox has been released.\nBit 4FOVR1: FIFO 1 overrun\nThis bit is set by hardware when a new message has been received and passed the filter\nwhile the FIFO was full.\nThis bit is cleared by software.\nBit 3FULL1: FIFO 1 full\nSet by hardware when three messages are stored in the FIFO.\nThis bit is cleared by software.\nBit 2Reserved, forced by hardware to 0.\nBits 1:0FMP1[1:0]: FIFO 1 message pending\nThese bits indicate how many messages are pending in the receive FIFO1.\nFMP1 is increased each time the hardware stores a new message in to the FIFO1. FMP is\ndecreased each time the software releases the output mailbox by setting the RFOM1 bit.\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9569/995"
  },
  {
    "start_page": 569,
    "end_page": 570,
    "page_range": "569-570",
    "section": "",
    "full_name": "CAN interrupt enable register (CAN_IER)",
    "short_name": "CAN_IER",
    "address_offset": "0x14",
    "reset_value": "0x00",
    "content": "Bits 31:18Reserved, forced by hardware to 0.\nBit 17SLKIE: Sleep interrupt enable\n0: No interrupt when SLAKI bit is set.\n1: Interrupt generated when SLAKI bit is set.\nBit 16WKUIE: Wakeup interrupt enable\n0: No interrupt when WKUI is set.\n1: Interrupt generated when WKUI bit is set.\nBit 15ERRIE: Error interrupt enable\n0: No interrupt will be generated when an error condition is pending in the CAN_ESR.\n1: An interrupt will be generation when an error condition is pending in the CAN_ESR.\nBits 14:12Reserved, forced by hardware to 0.\nBit 11LECIE: Last error code interrupt enable\n0: ERRI bit will not be set when the error code in LEC[2:0] is set by hardware on error\n1: ERRI bit will be set when the error code in LEC[2:0] is set by hardware on error detection.\nBit 10BOFIE: Bus-off interrupt enable\n0: ERRI bit will not be set when BOFF is set.\n1: ERRI bit will be set when BOFF is set.\nBit 9EPVIE: Error passive interrupt enable\n0: ERRI bit will not be set when EPVF is set.\n1: ERRI bit will be set when EPVF is set.\nBit 8EWGIE: Error warning interrupt enable\n0: ERRI bit will not be set when EWGF is set.\n1: ERRI bit will be set when EWGF is set.\nBit 7Reserved, forced by hardware to 0.\nBit 6FOVIE1: FIFO overrun interrupt enable\n0: No interrupt when FOVR is set.\n1: Interrupt generation when FOVR is set.\nBit 5FFIE1: FIFO full interrupt enable\n0: No interrupt when FULL bit is set.\n1: Interrupt generated when FULL bit is set.\nController area network (bxCAN)RM0008\n570/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 570,
    "end_page": 571,
    "page_range": "570-571",
    "section": "",
    "full_name": "CAN error status register (CAN_ESR)",
    "short_name": "CAN_ESR",
    "address_offset": "0x18",
    "reset_value": "0x00",
    "content": "Bit 4FMPIE1: FIFO message pending interrupt enable\n0: No interrupt generated when state of FMP[1:0] bits are not 00b.\n1: Interrupt generated when state of FMP[1:0] bits are not 00b.\nBit 3FOVIE0: FIFO overrun interrupt enable\n0: No interrupt when FOVR bit is set.\n1: Interrupt generated when FOVR bit is set.\nBit 2FFIE0: FIFO full interrupt enable\n0: No interrupt when FULL bit is set.\n1: Interrupt generated when FULL bit is set.\nBit 1FMPIE0: FIFO message pending interrupt enable\n0: No interrupt generated when state of FMP[1:0] bits are not 00b.\n1: Interrupt generated when state of FMP[1:0] bits are not 00b.\nBit 0TMEIE: Transmit mailbox empty interrupt enable\n0: No interrupt when RQCPx bit is set.\n1: Interrupt generated when RQCPx bit is set.\nNote:Refer to Section22.8: bxCAN interrupts.\nBits 31:24REC[7:0]: Receive error counter\nThe implementing part of the fault confinement mechanism of the CAN protocol. In case of\nan error during reception, this counter is incremented by 1 or by 8 depending on the error\ncondition as defined by the CAN standard. After every successful reception the counter is\ndecremented by 1 or reset to 120 if its value was higher than 128. When the counter value\nexceeds 127, the CAN controller enters the error passive state.\nBits 23:16TEC[7:0]: Least significant byte of the 9-bit transmit error counter\nThe implementing part of the fault confinement mechanism of the CAN protocol.\nBits 15:7Reserved, forced by hardware to 0.\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9571/995"
  },
  {
    "start_page": 571,
    "end_page": 572,
    "page_range": "571-572",
    "section": "",
    "full_name": "CAN bit timing register (CAN_BTR)",
    "short_name": "CAN_BTR",
    "address_offset": "0x1C",
    "reset_value": "0x0123 0000",
    "content": "Note:This register can only be accessed by the software when the CAN hardware is in\ninitialization mode.\nBits 6:4LEC[2:0]: Last error code\nThis field is set by hardware and holds a code which indicates the error condition of the last\nerror detected on the CAN bus. If a message has been transferred (reception or\ntransmission) without error, this field will be cleared to ‘0’.\nCode 7 is unused and may be written by the hardware to check for an update\n000: No Error\n001: Stuff Error\n010: Form Error\n011: Acknowledgment Error\n100: Bit recessive Error\n101: Bit dominant Error\n110: CRC Error\n111: Set by software\nBit 3Reserved, forced by hardware to 0.\nBit 2BOFF: Bus-off flag\nThis bit is set by hardware when it enters the bus-off state. The bus-off state is entered on\nTEC overflow, greater than 255, refer to Section22.7.6 on page 558.\nBit 1EPVF: Error passive flag\nThis bit is set by hardware when the Error Passive limit has been reached (Receive Error\nCounter or Transmit Error Counter>127).\nBit 0EWGF: Error warning flag\nThis bit is set by hardware when the warning limit has been reached\n(Receive Error Counter or Transmit Error Counter96).\nBit 31SILM: Silent mode (debug)\n0: Normal operation\n1: Silent Mode\nBit 30LBKM: Loop back mode (debug)\n0: Loop Back Mode disabled\n1: Loop Back Mode enabled\nBits 29:26Reserved, forced by hardware to 0.\nController area network (bxCAN)RM0008\n572/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 579,
    "end_page": 580,
    "page_range": "579-580",
    "section": "",
    "full_name": "CAN filter master register (CAN_FMR)",
    "short_name": "CAN_FMR",
    "address_offset": "0x200",
    "reset_value": "0x2A1C 0E01",
    "content": "Note:All bits of this register are set and cleared by software.\nBits 15:8DATA5[7:0]: Data Byte 5\nData byte 1 of the message.\nBits 7:0DATA4[7:0]: Data Byte 4\nData byte 0 of the message.\nBits 31:14Reserved, forced to reset value\nBits 13:8CAN2SB[5:0]: CAN2 start bank\nThese bits are set and cleared by software. They define the start bank for the CAN2\ninterface (Slave) in the range 1 to 27.\nNote:These bits are available in connectivity line devices only and are reserved otherwise.\nBits 7:1Reserved, forced to reset value\nBit 0FINIT: Filter init mode\nInitialization mode for filter banks\n0: Active filters mode.\n1: Initialization mode for the filters.\nController area network (bxCAN)RM0008\n580/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 580,
    "end_page": 580,
    "page_range": "580",
    "section": "",
    "full_name": "CAN filter mode register (CAN_FM1R)",
    "short_name": "CAN_FM1R",
    "address_offset": "0x204",
    "reset_value": "0x00",
    "content": "Note:This register can be written only when the filter initialization mode is set (FINIT=1) in the\nCAN_FMR register.\nNote:Please refer to Figure200: Filter bank scale configuration - register organization on"
  },
  {
    "start_page": 580,
    "end_page": 581,
    "page_range": "580-581",
    "section": "",
    "full_name": "CAN filter scale register (CAN_FS1R)",
    "short_name": "CAN_FS1R",
    "address_offset": "0x20C",
    "reset_value": "0x00",
    "content": "Note:This register can be written only when the filter initialization mode is set (FINIT=1) in the\nCAN_FMR register.\nNote:Please refer to Figure200: Filter bank scale configuration - register organization on\nBits 31:28Reserved. Forced to 0 by hardware.\nBits 27:0FBMx: Filter mode\nMode of the registers of Filter x.\n0: Two 32-bit registers of filter bank x are in Identifier Mask mode.\n1: Two 32-bit registers of filter bank x are in Identifier List mode.\nNote:Bits 27:14 are available in connectivity line devices only and are reserved otherwise.\nBits 31:28Reserved, forced by hardware to 0.\nBits 27:0FSCx: Filter scale configuration\nThese bits define the scale configuration of Filters 13-0.\n0: Dual 16-bit scale configuration\n1: Single 32-bit scale configuration\nNote:Bits 27:14 are available in connectivity line devices only and are reserved otherwise.\nRM0008Controller area network (bxCAN)\nDoc ID 13902 Rev 9581/995"
  },
  {
    "start_page": 581,
    "end_page": 581,
    "page_range": "581",
    "section": "",
    "full_name": "CAN filter FIFO assignment register (CAN_FFA1R)",
    "short_name": "CAN_FFA1R",
    "address_offset": "0x214",
    "reset_value": "0x00",
    "content": "Note:This register can be written only when the filter initialization mode is set (FINIT=1) in the\nCAN_FMR register."
  },
  {
    "start_page": 581,
    "end_page": 582,
    "page_range": "581-582",
    "section": "",
    "full_name": "CAN filter activation register (CAN_FA1R)",
    "short_name": "CAN_FA1R",
    "address_offset": "0x21C",
    "reset_value": "0x00",
    "content": "Bits 31:28Reserved, forced by hardware to 0.\nBits 27:0FFAx: Filter FIFO assignment for filter x\nThe message passing through this filter will be stored in the specified FIFO.\n0: Filter assigned to FIFO 0\n1: Filter assigned to FIFO 1\nNote:Bits 27:14 are available in connectivity line devices only and are reserved otherwise.\nBits 31:28Reserved, forced by hardware to 0.\nBits 27:0FACTx: Filter active\nThe software sets this bit to activate Filter x. To modify the Filter x registers (CAN_FxR[0:7]),\nthe FACTx bit must be cleared or the FINIT bit of the CAN_FMR register must be set.\n0: Filter x is not active\n1: Filter x is active\nNote:Bits 27:14 are available in connectivity line devices only and are reserved otherwise.\nController area network (bxCAN)RM0008\n582/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 614,
    "end_page": 616,
    "page_range": "614-616",
    "section": "23.5.1",
    "full_name": "SPI control register 1 (SPI_CR1) (not used in I",
    "short_name": "SPI_CR1",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "S mode)\nSPEBR [2:0]MSTRCPOLCPHA\nBit 15BIDIMODE: Bidirectional data mode enable\n0: 2-line unidirectional data mode selected\n1: 1-line bidirectional data mode selected\nNote:Not used in I\nS mode\nBit 14BIDIOE: Output enable in bidirectional mode\nThis bit combined with the BIDImode bit selects the direction of transfer in bidirectional\n0: Output disabled (receive-only mode)\n1: Output enabled (transmit-only mode)\nNote:In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.\nNot used in I\nS mode\nBit 13CRCEN: Hardware CRC calculation enable\n0: CRC calculation disabled\n1: CRC calculation Enabled\nNote:This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation\nNot used in I\nS mode\nBit 12CRCNEXT: Transmit CRC next\n0: Next transmit value is from Tx buffer\n1: Next transmit value is from Tx CRC register\nNote:This bit has to be written as soon as the last data is written into the SPI_DR register.\nNot used in I\nS mode\nBit 11DFF: Data frame format\n0: 8-bit data frame format is selected for transmission/reception\n1: 16-bit data frame format is selected for transmission/reception\nNote:This bit should be written only when SPI is disabled (SPE = ‘0’) for correct operation\nNot used in I\nS mode\nRM0008Serial peripheral interface (SPI)\nDoc ID 13902 Rev 9615/995\nBit 10RXONLY: Receive only\nThis bit combined with the BIDImode bit selects the direction of transfer in 2-line\nunidirectional mode. This bit is also useful in a multislave system in which this particular\nslave is not accessed, the output from the accessed slave is not corrupted.\n0: Full duplex (Transmit and receive)\n1: Output disabled (Receive-only mode)\nNote:Not used in I\nS mode\nBit 9SSM: Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\n0: Software slave management disabled\n1: Software slave management enabled\nNote:Not used in I\nS mode\nBit 8SSI: Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the\nNSS pin and the I/O value of the NSS pin is ignored.\nNote:Not used in I\nS mode\nBit 7LSBFIRST: Frame format\n0: MSB transmitted first\n1: LSB transmitted first\nNote:Notes: This bit should not be changed when communication is ongoing.\nNot used in I\nS mode\nBit 6SPE: SPI enable\n0: Peripheral disabled\n1: Peripheral enabled\nNote:Not used in I\nS mode\nBits 5:3BR[2:0]: Baud rate control\n000: f\n001: f\n010: f\n011: f\n100: f\n101: f\n110: f\n111: f\nNote:These bits should not be changed when communication is ongoing.\nNot used in I\nS mode\nSerial peripheral interface (SPI)RM0008\n616/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 616,
    "end_page": 617,
    "page_range": "616-617",
    "section": "23.5.2",
    "full_name": "SPI control register 2 (SPI_CR2)",
    "short_name": "SPI_CR2",
    "address_offset": "0x04",
    "reset_value": "0x0000",
    "content": "Bit 2MSTR: Master selection\n0: Slave configuration\n1: Master configuration\nNote:This bit should not be changed when communication is ongoing.\nNot used in I\nS mode\nBit1CPOL: Clock polarity\n0: CK to 0 when idle\n1: CK to 1 when idle\nNote:This bit should not be changed when communication is ongoing.\nNot used in I\nS mode\nBit 0CPHA: Clock phase\n0: The first clock transition is the first data capture edge\n1: The second clock transition is the first data capture edge\nNote:This bit should not be changed when communication is ongoing.\nNot used in I\nS mode\nBits 15:8Reserved. Forced to 0 by hardware.\nBit 7TXEIE: Tx buffer empty interrupt enable\n0: TXE interrupt masked\n1: TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.\nNote:To function correctly, the TXEIE and TXDMAEN bits should not be set at the same time.\nBit 6RXNEIE: RX buffer not empty interrupt enable\n0: RXNE interrupt masked\n1: RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is set.\nNote:To function correctly, the RXNEIE and RXDMAEN bits should not be set at the same time.\nBit 5ERRIE: Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR,\nMODF in SPI mode and UDR, OVR in I\nS mode).\n0: Error interrupt is masked\n1: Error interrupt is enabled.\nBits 4:3Reserved. Forced to 0 by hardware.\nRM0008Serial peripheral interface (SPI)\nDoc ID 13902 Rev 9617/995"
  },
  {
    "start_page": 618,
    "end_page": 619,
    "page_range": "618-619",
    "section": "23.5.4",
    "full_name": "SPI data register (SPI_DR)",
    "short_name": "SPI_DR",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bit 3UDR: Underrun flag\n0: No underrun occurred\n1: Underrun occurred\nThis flag is set by hardware and reset by a software sequence. Refer to Section23.4.7 on page 613\nfor the software sequence.\nNote:Not used in SPI mode\nBit 2CHSIDE: Channel side\n0: Channel Left has to be transmitted or has been received\n1: Channel Right has to be transmitted or has been received\nNote:Not used for the SPI mode\nNo meaning in PCM mode\nBit 1TXE: Transmit buffer empty\n0: Tx buffer not empty\n1: Tx buffer empty\nBit 0RXNE: Receive buffer not empty\n0: Rx buffer empty\n1: Rx buffer not empty\nBits 15:0DR[15:0]: Data register\nData received or to be transmitted.\nThe data register is split into 2 buffers - one for writing (Transmit Buffer) and another one for reading\n(Receive buffer). A write to the data register will write into the Tx buffer and a read from the data\nregister will return the value held in the Rx buffer.\nNotes for the SPI mode:\nDepending on the data frame format selection bit (DFF in SPI_CR1 register), the data sent or\nreceived is either 8-bit or 16-bit. This selection has to be made before enabling the SPI to\nensure correct operation.\nFor an 8-bit data frame, the buffers are 8-bit and only the LSB of the register (SPI_DR[7:0]) is\nused for transmission/reception. When in reception mode, the MSB of the register\n(SPI_DR[15:8]) is forced to 0.\nFor a 16-bit data frame, the buffers are 16-bit and the entire register, SPI_DR[15:0] is used for\nRM0008Serial peripheral interface (SPI)\nDoc ID 13902 Rev 9619/995"
  },
  {
    "start_page": 619,
    "end_page": 619,
    "page_range": "619",
    "section": "23.5.5",
    "full_name": "SPI CRC polynomial register (SPI_CRCPR) (not used in I",
    "short_name": "SPI_CRCPR",
    "address_offset": "0x10",
    "reset_value": "0x0007",
    "content": ""
  },
  {
    "start_page": 619,
    "end_page": 620,
    "page_range": "619-620",
    "section": "23.5.6",
    "full_name": "SPI Rx CRC register (SPI_RXCRCR) (not used in I",
    "short_name": "SPI_RXCRCR",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "S mode)\nBits 15:0CRCPOLY[15:0]: CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0007h) is the reset value of this register. Another polynomial can be\nconfigured as required.\nNote:Not used for the I\nS mode.\nBits 15:0RXCRC[15:0]: Rx CRC register\nWhen CRC calculation is enabled, the RxCRC[15:0] bits contain the computed CRC value of the\nsubsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is\nwritten to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR\nOnly the 8 LSB bits are considered when the data frame format is set to be 8-bit data (DFF bit of\nSPI_CR1 is cleared). CRC calculation is done based on CRC8.\nThe entire 16-bits of this register are considered when a 16-bit data frame format is selected (DFF\nbit of the SPI_CR1 register is set). CRC calculation is done based on CRC16 - CCITT standard.\nNote:A read to this register when the BSY Flag is set could return an incorrect value.\nNot used for the I\nS mode.\nSerial peripheral interface (SPI)RM0008\n620/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 620,
    "end_page": 620,
    "page_range": "620",
    "section": "23.5.7",
    "full_name": "SPI Tx CRC register (SPI_TXCRCR) (not used in I",
    "short_name": "SPI_TXCRCR",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": "S mode)\n23.5.8 SPI_I"
  },
  {
    "start_page": 641,
    "end_page": 643,
    "page_range": "641-643",
    "section": "24.6.1",
    "full_name": "Control register 1 (I2C_CR1)",
    "short_name": "I2C_CR1",
    "address_offset": "0x00",
    "reset_value": "0x0000",
    "content": "Bit 15SWRST: Software reset\nWhen set, the I2C is under reset state. Before resetting this bit, make sure the I2C lines are\nreleased and the bus is free.\n0: I\nC Peripheral not under reset\n1: I\nC Peripheral under reset state\nNote:This bit can be used in case the BUSY bit is set to ‘1’ when no stop condition has been\ndetected on the bus.\nBit 14Reserved, forced by hardware to 0.\nBit 13ALERT: SMBus alert\nThis bit is set and cleared by software, and cleared by hardware when PE=0.\n0: Releases SMBAlert pin high. Alert Response Address Header followed by NACK.\n1: Drives SMBAlert pin low. Alert Response Address Header followed by ACK.\nBit 12PEC: Packet error checking\nThis bit is set and cleared by software, and cleared by hardware when PEC is transferred or\nby a START or Stop condition or when PE=0.\n0: No PEC transfer\n1: PEC transfer (in Tx or Rx mode)\nNote:PEC calculation is corrupted by an arbitration loss.\nBit 11POS: Acknowledge/PEC Position (for data reception)\nThis bit is set and cleared by software and cleared by hardware when PE=0.\n0: ACK bit controls the (N)ACK of the current byte being received in the shift register. The\nPEC bit indicates that current byte in shift register is a PEC.\n1: ACK bit controls the (N)ACK of the next byte which will be received in the shift register.\nThe PEC bit indicates that the next byte in the shift register is a PEC\nNote:The POS bit must be used only in 2-byte reception configuration and must be\nconfigured before data reception starts.\nTo NACK the 2nd byte, the ACK bit must be cleared after ADDR is cleared.\nTo check the 2nd byte as PEC, the PEC bit must be set during the ADDR stretch event\nafter configuring the POS bit.\nInter-integrated circuit (I\nC) interfaceRM0008\n642/995 Doc ID 13902 Rev 9\nBit 10ACK: Acknowledge enable\nThis bit is set and cleared by software and cleared by hardware when PE=0.\n0: No acknowledge returned\n1: Acknowledge returned after a byte is received (matched address or data)\nBit 9STOP: Stop generation\nThe bit is set and cleared by software, cleared by hardware when a Stop condition is\ndetected, set by hardware when a timeout error is detected.\nIn Master Mode:\n0: No Stop generation.\n1: Stop generation after the current byte transfer or after the current Start condition is sent.\nIn Slave mode:\n0: No Stop generation.\n1: Release the SCL and SDA lines after the current byte transfer.\nNote:When the STOP, START or PEC bit is set, the software must not perform any write\naccess to I2C_CR1 before this bit is cleared by hardware. Otherwise there is a risk of\nsetting a second STOP, START or PEC request.\nBit 8START: Start generation\nThis bit is set and cleared by software and cleared by hardware when start is sent or PE=0.\nIn Master Mode:\n0: No Start generation\n1: Repeated start generation\nIn Slave mode:\n0: No Start generation\n1: Start generation when the bus is free\nBit 7NOSTRETCH: Clock stretching disable (Slave mode)\nThis bit is used to disable clock stretching in slave mode when ADDR or BTF flag is set, until\nit is reset by software.\n0: Clock stretching enabled\n1: Clock stretching disabled\nBit 6ENGC: General call enable\n0: General call disabled. Address 00h is NACKed.\n1: General call enabled. Address 00h is ACKed.\nBit 5ENPEC: PEC enable\n0: PEC calculation disabled\n1: PEC calculation enabled\nBit 4ENARP: ARP enable\n0: ARP disable\n1: ARP enable\nSMBus Device default address recognized if SMBTYPE=0\nSMBus Host address recognized if SMBTYPE=1\nBit 3SMBTYPE: SMBus type\n0: SMBus Device\n1: SMBus Host\nBit 2Reserved, forced by hardware to 0.\nBit 1SMBUS: SMBus mode\n0: I\nC mode\n1: SMBus mode\nRM0008Inter-integrated circuit (I\nC) interface\nDoc ID 13902 Rev 9643/995"
  },
  {
    "start_page": 643,
    "end_page": 644,
    "page_range": "643-644",
    "section": "24.6.2",
    "full_name": "Control register 2 (I2C_CR2)",
    "short_name": "I2C_CR2",
    "address_offset": "0x04",
    "reset_value": "0x0000",
    "content": "Bit 0PE: Peripheral enable\n0: Peripheral disable\n1: Peripheral enable: the corresponding I/Os are selected as alternate functions depending\non SMBus bit.\nNote:If this bit is reset while a communication is on going, the peripheral is disabled at the\nend of the current communication, when back to IDLE state.\nAll bit resets due to PE=0 occur at the end of the communication.\nIn master mode, this bit must not be reset before the end of the communication.\nBits 15:13Reserved, forced by hardware to 0.\nBit 12LAST: DMA last transfer\n0: Next DMA EOT is not the last transfer\n1: Next DMA EOT is the last transfer\nNote:This bit is used in master receiver mode to permit the generation of a NACK on the last\nreceived data.\nBit 11DMAEN: DMA requests enable\n0: DMA requests disabled\n1: DMA request enabled when TxE=1 or RxNE =1\nBit 10ITBUFEN: Buffer interrupt enable\n0: TxE = 1 or RxNE = 1 does not generate any interrupt.\n1:TxE = 1 or RxNE = 1 generates Event Interrupt (whatever the state of DMAEN)\nBit 9ITEVTEN: Event interrupt enable\n0: Event interrupt disabled\n1: Event interrupt enabled\nThis interrupt is generated when:\n–SB = 1 (Master)\n–ADDR = 1 (Master/Slave)\n–ADD10= 1 (Master)\n–STOPF = 1 (Slave)\n–BTF = 1 with no TxE or RxNE event\n–TxE event to 1 if ITBUFEN = 1\n–RxNE event to 1if ITBUFEN = 1\nInter-integrated circuit (I\nC) interfaceRM0008\n644/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 645,
    "end_page": 645,
    "page_range": "645",
    "section": "24.6.4",
    "full_name": "Own address register 2 (I2C_OAR2)",
    "short_name": "I2C_OAR2",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": ""
  },
  {
    "start_page": 645,
    "end_page": 646,
    "page_range": "645-646",
    "section": "24.6.5",
    "full_name": "Data register (I2C_DR)",
    "short_name": "I2C_DR",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": "Bits 15:8Reserved, forced by hardware to 0.\nBits 7:1ADD2[7:1]: Interface address\nbits 7:1 of address in dual addressing mode\nBit 0ENDUAL: Dual addressing mode enable\n0: Only OAR1 is recognized in 7-bit addressing mode\n1: Both OAR1 and OAR2 are recognized in 7-bit addressing mode\nBits 15:8Reserved, forced by hardware to 0.\nBits 7:0DR[7:0] 8-bit data register\nByte received or to be transmitted to the bus.\n–Transmitter mode: Byte transmission starts automatically when a byte is written in the DR\nregister. A continuous transmit stream can be maintained if the next data to be\ntransmitted is put in DR once the transmission is started (TxE=1)\n–Receiver mode: Received byte is copied into DR (RxNE=1). A continuous transmit stream\ncan be maintained if DR is read before the next data byte is received (RxNE=1).\nNote:In slave mode, the address is not copied into DR.\nNote:Write collision is not managed (DR can be written if TxE=0).\nNote:If an ARLO event occurs on ACK pulse, the received byte is not copied into DR and so\ncannot be read.\nInter-integrated circuit (I\nC) interfaceRM0008\n646/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 646,
    "end_page": 649,
    "page_range": "646-649",
    "section": "24.6.6",
    "full_name": "Status register 1 (I2C_SR1)",
    "short_name": "I2C_SR1",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "Bit 15SMBALERT: SMBus alert\nIn SMBus host mode:\n0: no SMBAlert\n1: SMBAlert event occurred on pin\nIn SMBus slave mode:\n0: no SMBAlert response address header\n1: SMBAlert response address header to SMBAlert LOW received\n–Cleared by software writing 0, or by hardware when PE=0.\nBit 14TIMEOUT: Timeout or Tlow error\n0: No timeout error\n1: SCL remained LOW for 25 ms (Timeout)\nMaster cumulative clock low extend time more than 10 ms (Tlow:mext)\nSlave cumulative clock low extend time more than 25 ms (Tlow:sext)\n–When set in slave mode: slave resets the communication and lines are released by\n–When set in master mode: Stop condition sent by hardware\n–Cleared by software writing 0, or by hardware when PE=0.\nBit 13Reserved, forced by hardware to 0.\nBit 12PECERR: PEC Error in reception\n0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)\n1: PEC error: receiver returns NACK after PEC reception (whatever ACK)\n–Cleared by software writing 0, or by hardware when PE=0.\nBit 11OVR: Overrun/Underrun\n0: No overrun/underrun\n1: Overrun or underrun\n–Set by hardware in slave mode when NOSTRETCH=1 and:\n–In reception when a new byte is received (including ACK pulse) and the DR register has\nnot been read yet. New received byte is lost.\n–In transmission when a new byte should be sent and the DR register has not been written\nyet. The same byte is sent twice.\n–Cleared by software writing 0, or by hardware when PE=0.\nNote:If the DR write occurs very close to SCL rising edge, the sent data is unspecified and a\nhold timing error occurs\nRM0008Inter-integrated circuit (I\nC) interface\nDoc ID 13902 Rev 9647/995\nBit 10AF: Acknowledge failure\n0: No acknowledge failure\n1: Acknowledge failure\n–Set by hardware when no acknowledge is returned.\n–Cleared by software writing 0, or by hardware when PE=0.\nBit 9ARLO: Arbitration lost (master mode)\n0: No Arbitration Lost detected\n1: Arbitration Lost detected\nSet by hardware when the interface loses the arbitration of the bus to another master\n–Cleared by software writing 0, or by hardware when PE=0.\nAfter an ARLO event the interface switches back automatically to Slave mode (M/SL=0).\nNote:In SMBUS, the arbitration on the data in slave mode occurs only during the data\nphase, or the acknowledge transmission (not on the address acknowledge).\nBit 8BERR: Bus error\n0: No misplaced Start or Stop condition\n1: Misplaced Start or Stop condition\n–Set by hardware when the interface detects a misplaced Start or Stop condition\n–Cleared by software writing 0, or by hardware when PE=0.\nBit 7TxE: Data register empty (transmitters)\n0: Data register not empty\n1: Data register empty\n–Set when DR is empty in transmission. TxE is not set during address phase.\n–Cleared by software writing to the DR register or by hardware after a start or a stop\ncondition or when PE=0.\nTxE is not set if either a NACK is received, or if next byte to be transmitted is PEC (PEC=1)\nNote:TxE is not cleared by writing the first data being transmitted, or by writing data when\nBTF is set, as in both cases the data register is still empty.\nBit 6RxNE: Data register not empty (receivers)\n0: Data register empty\n1: Data register not empty\n–Set when data register is not empty in receiver mode. RxNE is not set during address\n–Cleared by software reading or writing the DR register or by hardware when PE=0.\nRxNE is not set in case of ARLO event.\nNote:RxNE is not cleared by reading data when BTF is set, as the data register is still full.\nBit 5Reserved, forced by hardware to 0.\nBit 4STOPF: Stop detection (slave mode)\n0: No Stop condition detected\n1: Stop condition detected\n–Set by hardware when a Stop condition is detected on the bus by the slave after an\nacknowledge (if ACK=1).\n–Cleared by software reading the SR1 register followed by a write in the CR1 register, or by\nhardware when PE=0\nNote:The STOPF bit is not set after a NACK reception\nInter-integrated circuit (I\nC) interfaceRM0008\n648/995 Doc ID 13902 Rev 9\nBit 3ADD10: 10-bit header sent (Master mode)\n0: No ADD10 event occurred.\n1: Master has sent first address byte (header).\n–Set by hardware when the master has sent the first byte in 10-bit address mode.\n–Cleared by software reading the SR1 register followed by a write in the DR register of the\nsecond address byte, or by hardware when PE=0.\nNote:ADD10 bit is not set after a NACK reception\nBit 2BTF: Byte transfer finished\n0: Data byte transfer not done\n1: Data byte transfer succeeded\n–Set by hardware when NOSTRETCH=0 and:\n–In reception when a new byte is received (including ACK pulse) and DR has not been\nread yet (RxNE=1).\n–In transmission when a new byte should be sent and DR has not been written yet\n–Cleared by software reading SR1 followed by either a read or write in the DR register or\nby hardware after a start or a stop condition in transmission or when PE=0.\nNote:The BTF bit is not set after a NACK reception\nThe BTF bit is not set if next byte to be transmitted is the PEC (TRA=1 in I2C_SR2\nregister and PEC=1 in I2C_CR1 register)\nBit 1ADDR: Address sent (master mode)/matched (slave mode)\nThis bit is cleared by software reading SR1 register followed reading SR2, or by hardware\nwhen PE=0.\nAddress matched (Slave)\n0: Address mismatched or not received.\n1: Received address matched.\n–Set by hardware as soon as the received slave address matched with the OAR registers\ncontent or a general call or a SMBus Device Default Address or SMBus Host or SMBus\nAlert is recognized. (when enabled depending on configuration).\nAddress sent (Master)\n0: No end of address transmission\n1: End of address transmission\n–For 10-bit addressing, the bit is set after the ACK of the 2nd byte.\n–For 7-bit addressing, the bit is set after the ACK of the byte.\nNote:ADDR is not set after a NACK reception\nBit 0SB: Start bit (Master mode)\n0: No Start condition\n1: Start condition generated.\n–Set when a Start condition generated.\n–Cleared by software by reading the SR1 register followed by writing the DR register, or by\nhardware when PE=0\nRM0008Inter-integrated circuit (I\nC) interface\nDoc ID 13902 Rev 9649/995"
  },
  {
    "start_page": 649,
    "end_page": 650,
    "page_range": "649-650",
    "section": "24.6.7",
    "full_name": "Status register 2 (I2C_SR2)",
    "short_name": "I2C_SR2",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": "Bits 15:8PEC[7:0] Packet error checking register\nThis register contains the internal PEC when ENPEC=1.\nBit 7DUALF: Dual flag (Slave mode)\n0: Received address matched with OAR1\n1: Received address matched with OAR2\n–Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.\nBit 6SMBHOST: SMBus host header (Slave mode)\n0: No SMBus Host address\n1: SMBus Host address received when SMBTYPE=1 and ENARP=1.\n–Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.\nBit 5SMBDEFAULT: SMBus device default address (Slave mode)\n0: No SMBus Device Default address\n1: SMBus Device Default address received when ENARP=1\n–Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.\nBit 4GENCALL: General call address (Slave mode)\n0: No General Call\n1: General Call Address received when ENGC=1\n–Cleared by hardware after a Stop condition or repeated Start condition, or when PE=0.\nBit 3Reserved, forced by hardware to 0.\nInter-integrated circuit (I\nC) interfaceRM0008\n650/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 650,
    "end_page": 651,
    "page_range": "650-651",
    "section": "24.6.8",
    "full_name": "Clock control register (I2C_CCR)",
    "short_name": "I2C_CCR",
    "address_offset": "0x1C",
    "reset_value": "0x0000",
    "content": "is the multiple of 10 MHz required to generate the Fast clock at 400 kHz.\n2The CCR register must be configured only when the I2C is disabled (PE = 0).\nBit 2TRA: Transmitter/receiver\n0: Data bytes received\n1: Data bytes transmitted\nThis bit is set depending on the R/W bit of the address byte, at the end of total address\nIt is also cleared by hardware after detection of Stop condition (STOPF=1), repeated Start\ncondition, loss of bus arbitration (ARLO=1), or when PE=0.\nBit 1BUSY: Bus busy\n0: No communication on the bus\n1: Communication ongoing on the bus\n–Set by hardware on detection of SDA or SCL low\n–cleared by hardware on detection of a Stop condition.\nIt indicates a communication in progress on the bus. This information is still updated when\nthe interface is disabled (PE=0).\nBit 0MSL: Master/slave\n0: Slave Mode\n1: Master Mode\n–Set by hardware as soon as the interface is in Master mode (SB=1).\n–Cleared by hardware after detecting a Stop condition on the bus or a loss of arbitration\n(ARLO=1), or by hardware when PE=0.\nBit 15F/S: I2C master mode selection\n0: Standard Mode I2C\n1: Fast Mode I2C\nBit 14DUTY: Fast mode duty cycle\n0: Fast Mode t\n= 2\n1: Fast Mode t\n= 16/9 (see CCR)\nBits 13:12Reserved, forced by hardware to 0.\nRM0008Inter-integrated circuit (I\nC) interface\nDoc ID 13902 Rev 9651/995"
  },
  {
    "start_page": 651,
    "end_page": 652,
    "page_range": "651-652",
    "section": "24.6.9",
    "full_name": "TRISE register (I2C_TRISE)",
    "short_name": "I2C_TRISE",
    "address_offset": "0x20",
    "reset_value": "0x0002",
    "content": "Bits 11:0CCR[11:0]: Clock control register in Fast/Standard mode (Master mode)\nControls the SCL clock in master mode.\nStandard mode or SMBus:\n= CCR * T\n= CCR * T\nFast mode:\nIf DUTY = 0:\n= CCR * T\n= 2 * CCR * T\nIf DUTY = 1: (to reach 400 kHz)\n= 9 * CCR * T\n= 16 * CCR * T\nFor instance: in standard mode, to generate a 100 kHz SCL frequency:\nIf FREQR = 08, T\n= 125 ns so CCR must be programmed with 0x28\n(0x28 <=> 40d x 125 ns = 5000 ns.)\nNote:1. The minimum allowed value is 0x04, except in FAST DUTY mode where the\nminimum allowed value is 0x01\n2. t\nincludes the SCLH rising edge\n3. t\nincludes the SCLH falling edge\n4. These timings are without filters.\n5. The CCR register must be configured only when the I\nC is disabled (PE = 0).\n6. f\n= a multiple of 10 MHz is required to generate the fast clock at 400 kHz.\nBits 15:6Reserved, forced by hardware to 0.\nBits 5:0TRISE[5:0]: Maximum rise time in Fast/Standard mode (Master mode)\nThese bits must be programmed with the maximum SCL rise time given in the I\nC bus\nspecification, incremented by 1.\nFor instance: in standard mode, the maximum allowed SCL rise time is 1000 ns.\nIf, in the I2C_CR2 register, the value of FREQ[5:0] bits is equal to 0x08 and T\n= 125 ns\ntherefore the TRISE[5:0] bits must be programmed with 09h.\n(1000 ns / 125 ns = 8 + 1)\nThe filter value can also be added to TRISE[5:0].\nIf the result is not an integer, TRISE[5:0] must be programmed with the integer part, in order\nto respect the t\nNote:TRISE[5:0] must be configured only when the I2C is disabled (PE = 0).\nInter-integrated circuit (I\nC) interfaceRM0008\n652/995 Doc ID 13902 Rev 9\n24.6.10 I"
  },
  {
    "start_page": 683,
    "end_page": 685,
    "page_range": "683-685",
    "section": "25.6.1",
    "full_name": "Status register (USART_SR)",
    "short_name": "USART_SR",
    "address_offset": "0x00",
    "reset_value": "0x00C0",
    "content": "Bits 31:10Reserved, forced by hardware to 0.\nBit 9CTS: CTS flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared\nby software (by writing it to 0). An interrupt is generated if CTSIE=1 in the USART_CR3\n0: No change occurred on the nCTS status line\n1: A change occurred on the nCTS status line\nNote:This bit is not available for UART4 & UART5.\nBit 8LBD: LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software (by\nwriting it to 0). An interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n0: LIN Break not detected\n1: LIN break detected\nNote:An interrupt is generated when LBD=1 if LBDIE=1\nBit 7TXE: Transmit data register empty\nThis bit is set by hardware when the content of the TDR register has been transferred into\nthe shift register. An interrupt is generated if the TXEIE bit =1 in the USART_CR1 register. It\nis cleared by a write to the USART_DR register.\n0: Data is not transferred to the shift register\n1: Data is transferred to the shift register)\nNote:This bit is used during single buffer transmission.\nBit 6TC: Transmission complete\nThis bit is set by hardware if the transmission of a frame containing data is complete and if\nTXE is set. An interrupt is generated if TCIE=1 in the USART_CR1 register. It is cleared by a\nsoftware sequence (a read from the USART_SR register followed by a write to the\nUSART_DR register). The TC bit can also be cleared by writing a '0' to it. This clearing\nsequence is recommended only for multibuffer communication.\n0: Transmission is not complete\n1: Transmission is complete\nUniversal synchronous asynchronous receiver transmitter (USART)RM0008\n684/995 Doc ID 13902 Rev 9\nBit 5RXNE: Read data register not empty\nThis bit is set by hardware when the content of the RDR shift register has been transferred\nto the USART_DR register. An interrupt is generated if RXNEIE=1 in the USART_CR1\nregister. It is cleared by a read to the USART_DR register. The RXNE flag can also be\ncleared by writing a zero to it. This clearing sequence is recommended only for multibuffer\n0: Data is not received\n1: Received data is ready to be read.\nBit 4IDLE: IDLE line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if the\nIDLEIE=1 in the USART_CR1 register. It is cleared by a software sequence (an read to the\nUSART_SR register followed by a read to the USART_DR register).\n0: No Idle Line is detected\n1: Idle Line is detected\nNote:The IDLE bit will not be set again until the RXNE bit has been set itself (i.e. a new idle\nline occurs).\nBit 3ORE: Overrun error\nThis bit is set by hardware when the word currently being received in the shift register is\nready to be transferred into the RDR register while RXNE=1. An interrupt is generated if\nRXNEIE=1 in the USART_CR1 register. It is cleared by a software sequence (an read to the\nUSART_SR register followed by a read to the USART_DR register).\n0: No Overrun error\n1: Overrun error is detected\nNote:When this bit is set, the RDR register content will not be lost but the shift register will be\noverwritten. An interrupt is generated on ORE flag in case of Multi Buffer\ncommunication if the EIE bit is set.\nBit 2NE: Noise error flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by a\nsoftware sequence (an read to the USART_SR register followed by a read to the\nUSART_DR register).\n0: No noise is detected\n1: Noise is detected\nNote:This bit does not generate interrupt as it appears at the same time as the RXNE bit\nwhich itself generates an interrupting interrupt is generated on NE flag in case of Multi\nBuffer communication if the EIE bit is set.\nBit 1FE: Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character\nis detected. It is cleared by a software sequence (an read to the USART_SR register\nfollowed by a read to the USART_DR register).\n0: No Framing error is detected\n1: Framing error or break character is detected\nNote:This bit does not generate interrupt as it appears at the same time as the RXNE bit\nwhich itself generates an interrupt. If the word currently being transferred causes both\nframe error and overrun error, it will be transferred and only the ORE bit will be set.\nAn interrupt is generated on FE flag in case of Multi Buffer communication if the EIE bit\nis set.\nRM0008Universal synchronous asynchronous receiver transmitter (USART)\nDoc ID 13902 Rev 9685/995"
  },
  {
    "start_page": 686,
    "end_page": 686,
    "page_range": "686",
    "section": "25.6.3",
    "full_name": "Baud rate register (USART_BRR)",
    "short_name": "USART_BRR",
    "address_offset": "0x08",
    "reset_value": "0x0000",
    "content": "Note:The baud counters stop counting if the TE or RE bits are disabled respectively."
  },
  {
    "start_page": 686,
    "end_page": 688,
    "page_range": "686-688",
    "section": "25.6.4",
    "full_name": "Control register 1 (USART_CR1)",
    "short_name": "USART_CR1",
    "address_offset": "0x0C",
    "reset_value": "0x0000",
    "content": "Bits 31:16Reserved, forced by hardware to 0.\nBits 15:4DIV_Mantissa[11:0]: mantissa of USARTDIV\nThese 12 bits define the mantissa of the USART Divider (USARTDIV)\nBits 3:0DIV_Fraction[3:0]: fraction of USARTDIV\nThese 4 bits define the fraction of the USART Divider (USARTDIV)\nBits 31:14Reserved, forced by hardware to 0.\nBit 13UE: USART enable\nWhen this bit is cleared the USART prescalers and outputs are stopped and the end of the\nbyte transfer in order to reduce power consumption. This bit is set and cleared by software.\n0: USART prescaler and outputs disabled\n1: USART enabled\nBit 12M: Word length\nThis bit determines the word length. It is set or cleared by software.\n0: 1 Start bit, 8 Data bits, n Stop bit\n1: 1 Start bit, 9 Data bits, n Stop bit\nNote:The M bit must not be modified during a data transfer (both transmission and\nRM0008Universal synchronous asynchronous receiver transmitter (USART)\nDoc ID 13902 Rev 9687/995\nBit 11WAKE: Wakeup method\nThis bit determines the USART wakeup method, it is set or cleared by software.\n0: Idle Line\n1: Address Mark\nBit 10PCE: Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity\ncontrol is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit\nif M=0) and parity is checked on the received data. This bit is set and cleared by software.\nOnce it is set, PCE is active after the current byte (in reception and in transmission).\n0: Parity control disabled\n1: Parity control enabled\nBit 9PS: Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE\nbit set). It is set and cleared by software. The parity will be selected after the current byte.\n0: Even parity\n1: Odd parity\nBit 8PEIE: PE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt is inhibited\n1: An USART interrupt is generated whenever PE=1 in the USART_SR register\nBit 7TXEIE: TXE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt is inhibited\n1: An USART interrupt is generated whenever TXE=1 in the USART_SR register\nBit 6TCIE: Transmission complete interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt is inhibited\n1: An USART interrupt is generated whenever TC=1 in the USART_SR register\nBit 5RXNEIE: RXNE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt is inhibited\n1: An USART interrupt is generated whenever ORE=1 or RXNE=1 in the USART_SR\nBit 4IDLEIE: IDLE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt is inhibited\n1: An USART interrupt is generated whenever IDLE=1 in the USART_SR register\nBit 3TE: Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\n0: Transmitter is disabled\n1: Transmitter is enabled\nNote:1: During transmission, a “0” pulse on the TE bit (“0” followed by “1”) sends a preamble\n(idle line) after the current word, except in smartcard mode.\n2: When TE is set there is a 1 bit-time delay before the transmission starts.\nUniversal synchronous asynchronous receiver transmitter (USART)RM0008\n688/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 688,
    "end_page": 690,
    "page_range": "688-690",
    "section": "25.6.5",
    "full_name": "Control register 2 (USART_CR2)",
    "short_name": "USART_CR2",
    "address_offset": "0x10",
    "reset_value": "0x0000",
    "content": "Bit 2RE: Receiver enable\nThis bit enables the receiver. It is set and cleared by software.\n0: Receiver is disabled\n1: Receiver is enabled and begins searching for a start bit\nBit 1RWU: Receiver wakeup\nThis bit determines if the USART is in mute mode or not. It is set and cleared by software\nand can be cleared by hardware when a wakeup sequence is recognized.\n0: Receiver in active mode\n1: Receiver in mute mode\nNote:1: Before selecting Mute mode (by setting the RWU bit) the USART must first receive a\ndata byte, otherwise it cannot function in Mute mode with wakeup by Idle line detection.\n2: In Address Mark Detection wakeup configuration (WAKE bit=1) the RWU bit cannot\nbe modified by software while the RXNE bit is set.\nBit 0SBK: Send break\nThis bit set is used to send break characters. It can be set and cleared by software. It should\nbe set by software, and will be reset by hardware during the stop bit of break.\n0: No break character is transmitted\n1: Break character will be transmitted\nBits 31:15Reserved, forced by hardware to 0.\nBit 14LINEN: LIN mode enable\nThis bit is set and cleared by software.\n0: LIN mode disabled\n1: LIN mode enabled\nThe LIN mode enables the capability to send LIN Synch Breaks (13 low bits) using the SBK\nbit in the USART_CR1 register, and to detect LIN Sync breaks.\nBits 13:12STOP: STOP bits\nThese bits are used for programming the stop bits.\n00: 1 Stop bit\n01: 0.5 Stop bit\n10: 2 Stop bits\n11: 1.5 Stop bit\nNote:The 0.5 Stop bit and 1.5 Stop bit are not available for UART4 & UART5.\nRM0008Universal synchronous asynchronous receiver transmitter (USART)\nDoc ID 13902 Rev 9689/995\nNote:These 3 bits (CPOL, CPHA, LBCL) should not be written while the transmitter is enabled.\nBit 11CLKEN: Clock enable\nThis bit allows the user to enable the SCLK pin.\n0: SCLK pin disabled\n1: SCLK pin enabled\nNote:This bit is not available for UART4 & UART5.\nBit 10CPOL: Clock polarity\nThis bit allows the user to select the polarity of the clock output on the SCLK pin in\nsynchronous mode. It works in conjunction with the CPHA bit to produce the desired\nclock/data relationship\n0: Steady low value on SCLK pin outside transmission window.\n1: Steady high value on SCLK pin outside transmission window.\nNote:This bit is not available for UART4 & UART5.\nBit 9CPHA: Clock phase\nThis bit allows the user to select the phase of the clock output on the SCLK pin in\nsynchronous mode. It works in conjunction with the CPOL bit to produce the desired\nclock/data relationship (see figures 249 to 250)\n0: The first clock transition is the first data capture edge.\n1: The second clock transition is the first data capture edge.\nNote:This bit is not available for UART4 & UART5.\nBit 8LBCL: Last bit clock pulse\nThis bit allows the user to select whether the clock pulse associated with the last data bit\ntransmitted (MSB) has to be output on the SCLK pin in synchronous mode.\n0: The clock pulse of the last data bit is not output to the SCLK pin\n1: The clock pulse of the last data bit is output to the SCLK pin\nNote:1: The last bit is the 8th or 9th data bit transmitted depending on the 8 or 9 bit format\nselected by the M bit in the USART_CR1 register.\n2: This bit is not available for UART4 & UART5.\nBit 7Reserved, forced by hardware to 0.\nBit 6LBDIE: LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\n0: Interrupt is inhibited\n1: An interrupt is generated whenever LBD=1 in the USART_SR register\nBit 5LBDL: lin break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\n0: 10 bit break detection\n1: 11 bit break detection\nBit 4Reserved, forced by hardware to 0.\nBits 3:0ADD[3:0]: Address of the USART node\nThis bit-field gives the address of the USART node.\nThis is used in multiprocessor communication during mute mode, for wake up with address\nmark detection.\nUniversal synchronous asynchronous receiver transmitter (USART)RM0008\n690/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 690,
    "end_page": 691,
    "page_range": "690-691",
    "section": "25.6.6",
    "full_name": "Control register 3 (USART_CR3)",
    "short_name": "USART_CR3",
    "address_offset": "0x14",
    "reset_value": "0x0000",
    "content": "Bits 31:11Reserved, forced by hardware to 0.\nBit 10CTSIE: CTS interrupt enable\n0: Interrupt is inhibited\n1: An interrupt is generated whenever CTS=1 in the USART_SR register\nNote:This bit is not available for UART4 & UART5.\nBit 9CTSE: CTS enable\n0: CTS hardware flow control disabled\n1: CTS mode enabled, data is only transmitted when the nCTS input is asserted (tied to 0).\nIf the nCTS input is deasserted while a data is being transmitted, then the transmission is\ncompleted before stopping. If a data is written into the data register while nCTS is asserted,\nthe transmission is postponed until nCTS is asserted.\nNote:This bit is not available for UART4 & UART5.\nBit 8RTSE: RTS enable\n0: RTS hardware flow control disabled\n1: RTS interrupt enabled, data is only requested when there is space in the receive buffer.\nThe transmission of data is expected to cease after the current character has been\ntransmitted. The nRTS output is asserted (tied to 0) when a data can be received.\nNote:This bit is not available for UART4 & UART5.\nBit 7DMAT: DMA enable transmitter\nThis bit is set/reset by software\n1: DMA mode is enabled for transmission\n0: DMA mode is disabled for transmission\nNote:This bit is not available for UART5.\nBit 6DMAR: DMA enable receiver\nThis bit is set/reset by software\n1: DMA mode is enabled for reception\n0: DMA mode is disabled for reception\nNote:This bit is not available for UART5.\nBit 5SCEN: Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\n0: Smartcard Mode disabled\n1: Smartcard Mode enabled\nNote:This bit is not available for UART4 & UART5.\nRM0008Universal synchronous asynchronous receiver transmitter (USART)\nDoc ID 13902 Rev 9691/995"
  },
  {
    "start_page": 691,
    "end_page": 693,
    "page_range": "691-693",
    "section": "25.6.7",
    "full_name": "Guard time and prescaler register (USART_GTPR)",
    "short_name": "USART_GTPR",
    "address_offset": "0x18",
    "reset_value": "0x0000",
    "content": "Bit 4NACK: Smartcard NACK enable\n0: NACK transmission in case of parity error is disabled\n1: NACK transmission during parity error is enabled\nNote:This bit is not available for UART4 & UART5.\nBit 3HDSEL: Half-duplex selection\nSelection of Single-wire Half-duplex mode\n0: Half duplex mode is not selected\n1: Half duplex mode is selected\nBit 2IRLP: IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\n0: Normal mode\n1: Low-power mode\nBit 1IREN: IrDA mode enable\nThis bit is set and cleared by software.\n0: IrDA disabled\n1: IrDA enabled\nBit 0EIE: Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing\nerror, overrun error or noise error (FE=1 or ORE=1 or NE=1 in the USART_SR register) in\ncase of Multi Buffer Communication (DMAR=1 in the USART_CR3 register).\n0: Interrupt is inhibited\n1: An interrupt is generated whenever DMAR=1 in the USART_CR3 register and FE=1 or\nORE=1 or NE=1 in the USART_SR register.\nBits 31:16Reserved, forced by hardware to 0.\nBits 15:8GT[7:0]: Guard time value\nThis bit-field gives the Guard time value in terms of number of baud clocks.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time\nNote:This bit is not available for UART4 & UART5.\nUniversal synchronous asynchronous receiver transmitter (USART)RM0008\n692/995 Doc ID 13902 Rev 9\nBits 7:0PSC[7:0]: Prescaler value\n–In IrDA Low-power mode:\nPSC[7:0] = IrDA Low-Power Baud Rate\nUsed for programming the prescaler for dividing the system clock to achieve the low-power\nThe source clock is divided by the value given in the register (8 significant bits):\n00000000: Reserved - do not program this value\n00000001: divides the source clock by 1\n00000010: divides the source clock by 2\n–In normal IrDA mode: PSC must be set to 00000001.\n–In smartcard mode:\nPSC[4:0]: Prescaler value\nUsed for programming the prescaler for dividing the system clock to provide the smartcard\nThe value given in the register (5 significant bits) is multiplied by 2 to give the division factor\nof the source clock frequency:\n00000: Reserved - do not program this value\n00001: divides the source clock by 2\n00010: divides the source clock by 4\n00011: divides the source clock by 6\nNote:1: Bits [7:5] have no effect if Smartcard mode is used.\n2: This bit is not available for UART4 & UART5.\nRM0008Universal synchronous asynchronous receiver transmitter (USART)\nDoc ID 13902 Rev 9693/995"
  },
  {
    "start_page": 722,
    "end_page": 724,
    "page_range": "722-724",
    "section": "",
    "full_name": "OTG_FS control and status register (OTG_FS_GOTGCTL)",
    "short_name": "OTG_FS_GOTGCTL",
    "address_offset": "0x000",
    "reset_value": "0x0000 0800",
    "content": "The OTG control and status register controls the behavior and reflects the status of the OTG\nfunction of the core.\nTable 184.Data FIFO (DFIFO) access register map\nFIFO access register sectionAddress rangeAccess\nDevice IN Endpoint 0/Host OUT Channel 0: DFIFO Write Access\nDevice OUT Endpoint 0/Host IN Channel 0: DFIFO Read Access\nDevice IN Endpoint 1/Host OUT Channel 1: DFIFO Write Access\nDevice OUT Endpoint 1/Host IN Channel 1: DFIFO Read Access\nDevice IN Endpoint x\n/Host OUT Channel x\n: DFIFO Write Access\nDevice OUT Endpoint x\n/Host IN Channel x\n: DFIFO Read Access\n1.Where x is 3 in device mode and 7 in host mode.\nTable 185.Power and clock gating control and status registers\nRegister nameAcronymOffset address: 0xE00–0xFFF\nPower and clock gating control registerPCGCR0xE00-0xE04\nBits 31:20Reserved\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9723/995\nBit 19BSVLD: B-session valid\nIndicates the Device mode transceiver status.\n0: B-session is not valid.\n1: B-session is valid.\nIn OTG mode, you can use this bit to determine if the device is connected or disconnected.\nNote:Only accessible in Device mode.\nBit 18ASVLD: A-session valid\nIndicates the Host mode transceiver status.\n0: A-session is not valid\n1: A-session is valid\nNote:Only accessible in Host mode.\nBit 17DBCT: Long/short debounce time\nIndicates the debounce time of a detected connection.\n0: Long debounce time, used for physical connections (100 ms + 2.5 µs)\n1: Short debounce time, used for soft connections (2.5 µs)\nNote:Only accessible in Host mode.\nBit 16CIDSTS: Connector ID status\nIndicates the connector ID status on a connect event.\n0: The OTG_FS controller is in A-Device mode\n1: The OTG_FS controller is in B-Device mode\nNote:Accessible in both Device and Host modes.\nBits 15:12Reserved\nBit 11DHNPEN: Device HNP enabled\nThe application sets this bit when it successfully receives a SetFeature.SetHNPEnable\ncommand from the connected USB host.\n0: HNP is not enabled in the application\n1: HNP is enabled in the application\nNote:Only accessible in Device mode.\nBit 10HSHNPEN: Host set HNP enable\nThe application sets this bit when it has successfully enabled HNP (using the\nSetFeature.SetHNPEnable command) on the connected device.\n0: Host Set HNP is not enabled\n1: Host Set HNP is enabled\nNote:Only accessible in Host mode.\nBit 9HNPRQ: HNP request\nThe application sets this bit to initiate an HNP request to the connected USB host. The\napplication can clear this bit by writing a 0 when the host negotiation success status change bit\nin the OTG interrupt register (HNSSCHG bit in OTG_FS_GOTGINT) is set. The core clears this\nbit when the HNSSCHG bit is cleared.\n0: No HNP request\n1: HNP request\nNote:Only accessible in Device mode.\nUSB on-the-go full-speed (OTG_FS)RM0008\n724/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 724,
    "end_page": 726,
    "page_range": "724-726",
    "section": "",
    "full_name": "OTG_FS interrupt register (OTG_FS_GOTGINT)",
    "short_name": "OTG_FS_GOTGINT",
    "address_offset": "0x04",
    "reset_value": "0x0000 0000",
    "content": "The application reads this register whenever there is an OTG interrupt and clears the bits in\nthis register to clear the OTG interrupt.\nBit 8HNGSCS: Host negotiation success\nThe core sets this bit when host negotiation is successful. The core clears this bit when the\nHNP Request (HNPRQ) bit in this register is set.\n0: Host negotiation failure\n1: Host negotiation success\nNote:Only accessible in Device mode.\nBits 7:2Reserved\nBit 1SRQ: Session request\nThe application sets this bit to initiate a session request on the USB. The application can clear\nthis bit by writing a 0 when the host negotiation success status change bit in the OTG Interrupt\nregister (HNSSCHG bit in OTG_FS_GOTGINT) is set. The core clears this bit when the\nHNSSCHG bit is cleared.\nIf you use the USB 1.1 full-speed serial transceiver interface to initiate the session request, the\napplication must wait until V\ndischarges to 0.2 V, after the B-Session Valid bit in this register\n(BSVLD bit in OTG_FS_GOTGCTL) is cleared. This discharge time varies between different\nPHYs and can be obtained from the PHY vendor.\n0: No session request\n1: Session request\nNote:Only accessible in Device mode.\nBit 0SRQSCS: Session request success\nThe core sets this bit when a session request initiation is successful.\n0: Session request failure\n1: Session request success\nNote:Only accessible in Device mode.\nBits 31:20Reserved.\nBit 19DBCDNE: Debounce done\nThe core sets this bit when the debounce is completed after the device connect. The\napplication can start driving USB reset after seeing this interrupt. This bit is only valid when the\nHNP Capable or SRP Capable bit is set in the Core USB Configuration register (HNPCAP bit or\nSRPCAP bit in OTG_FS_GUSBCFG, respectively).\nNote:Only accessible in Host mode.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9725/995\nBit 18ADTOCHG: A-device timeout change\nThe core sets this bit to indicate that the A-device has timed out while waiting for the B-device\nto connect.\nNote:Accessible in both Device and Host modes.\nBit 17HNGDET: Host negotiation detected\nThe core sets this bit when it detects a host negotiation request on the USB.\nNote:Accessible in both Device and Host modes.\nBits 16:10Reserved.\nBit 9HNSSCHG: Host negotiation success status change\nThe core sets this bit on the success or failure of a USB host negotiation request. The\napplication must read the host negotiation success bit of the OTG Control and Status register\n(HNGSCS in OTG_FS_GOTGCTL) to check for success or failure.\nNote:Accessible in both Device and Host modes.\nBits 7:3Reserved.\nBit 8SRSSCHG: Session request success status change\nThe core sets this bit on the success or failure of a session request. The application must read\nthe session request success bit in the OTG Control and status register (SRQSCS bit in\nOTG_FS_GOTGCTL) to check for success or failure.\nNote:Accessible in both Device and Host modes.\nBit 2SEDET: Session end detected\nThe core sets this bit to indicate that the level of the voltage on V\nis no longer valid for a B-\nPeripheral session when V\n< 0.8 V.\nBits 1:0Reserved.\nUSB on-the-go full-speed (OTG_FS)RM0008\n726/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 726,
    "end_page": 727,
    "page_range": "726-727",
    "section": "",
    "full_name": "OTG_FS AHB configuration register (OTG_FS_GAHBCFG)",
    "short_name": "OTG_FS_GAHBCFG",
    "address_offset": "0x008",
    "reset_value": "0x0000 0000",
    "content": "This register can be used to configure the core after power-on or a change in mode. This\nregister mainly contains AHB system-related configuration parameters. Do not change this\nregister after the initial programming. The application must program this register before\nstarting any transactions on either the AHB or the USB.\nBits 31:20Reserved.\nBit 8PTXFELVL: Periodic TxFIFO empty level\nIndicates when the periodic TxFIFO empty interrupt bit in the Core interrupt register (PTXFE bit\nin OTG_FS_GINTSTS) is triggered.\n0: PTXFE (in OTG_FS_GINTSTS) interrupt indicates that the Periodic TxFIFO is half empty\n1: PTXFE (in OTG_FS_GINTSTS) interrupt indicates that the Periodic TxFIFO is completely\nNote:Only accessible in Host mode.\nBit 7TXFELVL: TxFIFO empty level\nIn device mode, this bit indicates when IN endpoint Transmit FIFO empty interrupt (TXFE in\nOTG_FS_DIEPINTx.) is triggered.\n0: TXFE (in OTG_FS_DIEPINTx) interrupt indicates that the IN Endpoint TxFIFO is half\n1: TXFE (in OTG_FS_DIEPINTx) interrupt indicates that the IN Endpoint TxFIFO is\ncompletely empty\nNote:Only accessible in Device mode.\nBits 6:1Reserved.\nBit 0GINT: Global interrupt mask\nThe application uses this bit to mask? or unmask the interrupt line assertion to itself.\nIrrespective of this bit’s setting, the interrupt status registers are updated by the core.\n0: Mask the interrupt assertion to the application.\n1: Unmask the interrupt assertion to the application.\nNote:Accessible in both Device and Host modes.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9727/995"
  },
  {
    "start_page": 727,
    "end_page": 729,
    "page_range": "727-729",
    "section": "",
    "full_name": "OTG_FS USB configuration register (OTG_FS_GUSBCFG)",
    "short_name": "OTG_FS_GUSBCFG",
    "address_offset": "0x00C",
    "reset_value": "0x0000 0A00",
    "content": "This register can be used to configure the core after power-on or a changing to Host mode\nor Device mode. It contains USB and USB-PHY related configuration parameters. The\napplication must program this register before starting any transactions on either the AHB or\nthe USB. Do not make changes to this register after the initial programming.\nBits 31:20Reserved.\nBit 31CTXPKT: Corrupt Tx packet\nThis bit is for debug purposes only. Never set this bit to 1.\nNote:Accessible in both Device and Host modes.\nBit 30FDMOD: Force device mode\nWriting a 1 to this bit forces the core to device mode irrespective of the OTG_FS_ID input pin.\n0: Normal mode\n1: Force device mode\nAfter setting the force bit, the application must wait at least 25ms before the change takes\nNote:Accessible in both Device and Host modes.\nBit 29FHMOD: Force host mode\nWriting a 1 to this bit forces the core to host mode irrespective of the OTG_FS_ID input pin.\n0: Normal mode\n1: Force host mode\nAfter setting the force bit, the application must wait at least 25ms before the change takes\nNote:Accessible in both Device and Host modes.\nBits 28:15Reserved\nBit 14NPTXRWEN: Reserved non-periodic TxFIFO rewind enable\nIn Host mode, this bit should be set when only one channel is enabled. When this bit is set, the\ncore automatically retries an OUT transaction in case of NAK or timeout, without interrupting\nthe application.\nIn Device mode, this bit should be set only when one non-periodic IN endpoint is enabled at\nany point in time, as can happen in mass storage applications. When this bit is enabled, the\ncore can internally handle the timeout on non-periodic endpoints without application\nNote:Accessible in both Device and Host modes.\nUSB on-the-go full-speed (OTG_FS)RM0008\n728/995 Doc ID 13902 Rev 9\nBits 13:10TRDT: USB turnaround time\nSets the turnaround time in PHY clocks.\nSpecifies the response time for a MAC request to the Packet FIFO controller (PFC) to fetch\ndata from the DFIFO (SPRAM).\nThey must be programmed to:\n0101: When the MAC interface is 16-bit UTMIFS\n1001: When the MAC interface is 8-bit UTMIFS\nNote:Only accessible in Device mode.\nBit 9HNPCAP: HNP-capable\nThe application uses this bit to control the OTG_FS controller’s HNP capabilities.\n0: HNP capability is not enabled.\n1: HNP capability is enabled.\nNote:Accessible in both Device and Host modes.\nBit 8SRPCAP: SRP-capable\nThe application uses this bit to control the OTG_FS controller’s SRP capabilities. If the core\noperates as a non-SRP-capable\nB-device, it cannot request the connected A-device (host) to activate V\nand start a session.\n0: SRP capability is not enabled.\n1: SRP capability is enabled.\nNote:Accessible in both Device and Host modes.\nBits [7:3]Reserved\nBits [2:0]TOCAL: FS timeout calibration\nThe number of PHY clocks that the application programs in this field is added to the full-speed\ninterpacket timeout duration in the core to account for any additional delays introduced by the\nPHY. This can be required, because the delay introduced by the PHY in generating the line\nstate condition can vary from one PHY to another.\nThe USB standard timeout value for full-speed operation is 16 to 18 (inclusive) bit times. The\napplication must program this field based on the speed of enumeration. The number of bit\ntimes added per PHY clock is 0.25 bit times.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9729/995"
  },
  {
    "start_page": 729,
    "end_page": 731,
    "page_range": "729-731",
    "section": "",
    "full_name": "OTG_FS reset register (OTG_FS_GRSTCTL)",
    "short_name": "OTG_FS_GRSTCTL",
    "address_offset": "0x10",
    "reset_value": "0x2000 0000",
    "content": "The application uses this register to reset various hardware features inside the core.\nBit 31AHBIDL: AHB master idle\nIndicates that the AHB master state machine is in the Idle condition.\nNote:Accessible in both Device and Host modes.\nBits 30:11Reserved\nBits 10:6TXFNUM: TxFIFO number\nThis is the FIFO number that must be flushed using the TxFIFO Flush bit. This field must not be\nchanged until the core clears the TxFIFO Flush bit.\n–Non-periodic TxFIFO flush in Host mode\n–Tx FIFO 0 flush in Device mode\n–Periodic TxFIFO flush in Host mode\n–TXFIFO 1 flush in device mode\n●00010: TXFIFO 2 flush in device mode\n●00101: TXFIFO 15 flush in device mode\n●10000: Flush all the transmit FIFOs in device or host mode.\nNote:Accessible in both Device and Host modes.\nBit 5TXFFLSH: TxFIFO flush\nThis bit selectively flushes a single or all transmit FIFOs, but cannot do so if the core is in the\nmidst of a transaction.\nThe application must write this bit only after checking that the core is neither writing to the\nTxFIFO nor reading from the TxFIFO. Verify using these registers:\nRead—NAK Effective Interrupt ensures the core is not reading from the FIFO\nWrite—AHBIDL bit in OTG_FS_GRSTCTL ensures the core is not writing anything to the\nNote:Accessible in both Device and Host modes.\nBit 4RXFFLSH: RxFIFO flush\nThe application can flush the entire RxFIFO using this bit, but must first ensure that the core is\nnot in the middle of a transaction.\nThe application must only write to this bit after checking that the core is neither reading from the\nRxFIFO nor writing to the RxFIFO.\nThe application must wait until the bit is cleared before performing any other operations. This bit\nrequires 8 clocks (slowest of PHY or AHB clock) to clear.\nNote:Accessible in both Device and Host modes.\nUSB on-the-go full-speed (OTG_FS)RM0008\n730/995 Doc ID 13902 Rev 9\nBit 3Reserved\nBit 2FCRST: Host frame counter reset\nThe application writes this bit to reset the frame number counter inside the core. When the\nframe counter is reset, the subsequent SOF sent out by the core has a frame number of 0.\nNote:Only accessible in Host mode.\nBit 1HSRST: HCLK soft reset\nThe application uses this bit to flush the control logic in the AHB Clock domain. Only AHB Clock\nDomain pipelines are reset.\nFIFOs are not flushed with this bit.\nAll state machines in the AHB clock domain are reset to the Idle state after terminating the\ntransactions on the AHB, following the protocol.\nCSR control bits used by the AHB clock domain state machines are cleared.\nTo clear this interrupt, status mask bits that control the interrupt status and are generated by\nthe AHB clock domain state machine are cleared.\nBecause interrupt status bits are not cleared, the application can get the status of any core\nevents that occurred after it set this bit.\nThis is a self-clearing bit that the core clears after all necessary logic is reset in the core. This\ncan take several clocks, depending on the core’s current state.\nNote:Accessible in both Device and Host modes.\nBit 0CSRST: Core soft reset\nResets the HCLK and PCLK domains as follows:\nClears the interrupts and all the CSR register bits except for the following bits:\n–RSTPDMODL bit in OTG_FS_PCGCCTL\n–GAYEHCLK bit in OTG_FS_PCGCCTL\n–PWRCLMP bit in OTG_FS_PCGCCTL\n–STPPCLK bit in OTG_FS_PCGCCTL\n–FSLSPCS bit in OTG_FS_HCFG\n–DSPD bit in OTG_FS_DCFG\nAll module state machines (except for the AHB slave unit) are reset to the Idle state, and all\nthe transmit FIFOs and the receive FIFO are flushed.\nAny transactions on the AHB Master are terminated as soon as possible, after completing the\nlast data phase of an AHB transfer. Any transactions on the USB are terminated immediately.\nThe application can write to this bit any time it wants to reset the core. This is a self-clearing bit\nand the core clears this bit after all the necessary logic is reset in the core, which can take\nseveral clocks, depending on the current state of the core. Once this bit has been cleared, the\nsoftware must wait at least 3 PHY clocks before accessing the PHY domain (synchronization\ndelay). The software must also check that bit 31 in this register is set to 1 (AHB Master is Idle)\nbefore starting any operation.\nTypically, the software reset is used during software development and also when you\ndynamically change the PHY selection bits in the above listed USB configuration registers.\nWhen you change the PHY, the corresponding clock for the PHY is selected and used in the\nPHY domain. Once a new clock is selected, the PHY domain has to be reset for proper\nNote:Accessible in both Device and Host modes.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9731/995"
  },
  {
    "start_page": 731,
    "end_page": 735,
    "page_range": "731-735",
    "section": "",
    "full_name": "OTG_FS core interrupt register (OTG_FS_GINTSTS)",
    "short_name": "OTG_FS_GINTSTS",
    "address_offset": "0x014",
    "reset_value": "0x0400 0020",
    "content": "This register interrupts the application for system-level events in the current mode (Device\nmode or Host mode).\nSome of the bits in this register are valid only in Host mode, while others are valid in Device\nmode only. This register also indicates the current mode. To clear the interrupt status bits of\nthe rc_w1 type, the application must write 1 into the bit.\nThe FIFO status interrupts are read-only; once software reads from or writes to the FIFO\nwhile servicing these interrupts, FIFO interrupt conditions are cleared automatically.\nThe application must clear the OTG_FS_GINTSTS register at initialization before\nunmasking the interrupt bit to avoid any interrupts generated prior to initialization.\nBit 31WKUPINT: Resume/remote wakeup detected interrupt\nIn Device mode, this interrupt is asserted when a resume is detected on the USB. In Host\nmode, this interrupt is asserted when a remote wakeup is detected on the USB.\nNote:Accessible in both Device and Host modes.\nBit 30SRQINT: Session request/new session detected interrupt\nIn Host mode, this interrupt is asserted when a session request is detected from the device. In\nDevice mode, this interrupt is asserted when V\nis in the valid range for a B-peripheral\ndevice. Accessible in both Device and Host modes.\nBit 29DISCINT: Disconnect detected interrupt\nAsserted when a device disconnect is detected.\nNote:Only accessible in Host mode.\nBit 28CIDSCHG: Connector ID status change\nThe core sets this bit when there is a change in connector ID status.\nNote:Accessible in both Device and Host modes.\nBit 27Reserved\nBit 26PTXFE: Periodic TxFIFO empty\nAsserted when the periodic transmit FIFO is either half or completely empty and there is space\nfor at least one entry to be written in the periodic request queue. The half or completely empty\nstatus is determined by the periodic TxFIFO empty level bit in the Core AHB configuration\nregister (PTXFELVL bit in OTG_FS_GAHBCFG).\nNote:Only accessible in Host mode.\nUSB on-the-go full-speed (OTG_FS)RM0008\n732/995 Doc ID 13902 Rev 9\nBit 25HCINT: Host channels interrupt\nThe core sets this bit to indicate that an interrupt is pending on one of the channels of the core\n(in Host mode). The application must read the Host all channels interrupt (OTG_FS_HAINT)\nregister to determine the exact number of the channel on which the interrupt occurred, and\nthen read the corresponding Host channel-x interrupt (OTG_FS_HCINTx) register to\ndetermine the exact cause of the interrupt. The application must clear the appropriate status\nbit in the OTG_FS_HCINTx register to clear this bit.\nNote:Only accessible in Host mode.\nBit 24HPRTINT: Host port interrupt\nThe core sets this bit to indicate a change in port status of one of the OTG_FS controller ports\nin Host mode. The application must read the Host port control and status (OTG_FS_HPRT)\nregister to determine the exact event that caused this interrupt. The application must clear the\nappropriate status bit in the Host port control and status register to clear this bit.\nNote:Only accessible in Host mode.\nBits 23:22Reserved\nBit 21IPXFR: Incomplete periodic transfer\nIn Host mode, the core sets this interrupt bit when there are incomplete periodic transactions\nstill pending, which are scheduled for the current frame.\nNote:Only accessible in Host mode.\nINCOMPISOOUT: Incomplete isochronous OUT transfer\nIn Device mode, the core sets this interrupt to indicate that there is at least one isochronous\nOUT endpoint on which the transfer is not completed in the current frame. This interrupt is\nasserted along with the End of periodic frame interrupt (EOPF) bit in this register.\nNote:Only accessible in Device mode.\nBit 20IISOIXFR: Incomplete isochronous IN transfer\nThe core sets this interrupt to indicate that there is at least one isochronous IN endpoint on\nwhich the transfer is not completed in the current frame. This interrupt is asserted along with\nthe End of periodic frame interrupt (EOPF) bit in this register.\nNote:Only accessible in Device mode.\nBit 19OEPINT: OUT endpoint interrupt\nThe core sets this bit to indicate that an interrupt is pending on one of the OUT endpoints of\nthe core (in Device mode). The application must read the Device all endpoints interrupt\n(OTG_FS_DAINT) register to determine the exact number of the OUT endpoint on which the\ninterrupt occurred, and then read the corresponding Device OUT Endpoint-x Interrupt\n(OTG_FS_DOEPINTx) register to determine the exact cause of the interrupt. The application\nmust clear the appropriate status bit in the corresponding OTG_FS_DOEPINTx register to\nclear this bit.\nNote:Only accessible in Device mode.\nBit 18IEPINT: IN endpoint interrupt\nThe core sets this bit to indicate that an interrupt is pending on one of the IN endpoints of the\ncore (in Device mode). The application must read the Device All Endpoints Interrupt\n(OTG_FS_DAINT) register to determine the exact number of the IN endpoint on which the\ninterrupt occurred, and then read the corresponding Device IN Endpoint-x interrupt\n(OTG_FS_DIEPINTx) register to determine the exact cause of the interrupt. The application\nmust clear the appropriate status bit in the corresponding OTG_FS_DIEPINTx register to clear\nthis bit.\nNote:Only accessible in Device mode.\nBits 17:16Reserved\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9733/995\nBit 15EOPF: End of periodic frame interrupt\nIndicates that the period specified in the periodic frame interval field of the Device\nconfiguration register (PFIVL bit in OTG_FS_DCFG) has been reached in the current frame.\nNote:Only accessible in Device mode.\nBit 14ISOODRP: Isochronous OUT packet dropped interrupt\nThe core sets this bit when it fails to write an isochronous OUT packet into the RxFIFO\nbecause the RxFIFO does not have enough space to accommodate a maximum size packet\nfor the isochronous OUT endpoint.\nNote:Only accessible in Device mode.\nBit 13ENUMDNE: Enumeration done\nThe core sets this bit to indicate that speed enumeration is complete. The application must\nread the Device Status (OTG_FS_DSTS) register to obtain the enumerated speed.\nNote:Only accessible in Device mode.\nBit 12USBRST: USB reset\nThe core sets this bit to indicate that a reset is detected on the USB.\nNote:Only accessible in Device mode.\nBit 11USBSUSP: USB suspend\nThe core sets this bit to indicate that a suspend was detected on the USB. The core enters the\nSuspended state when there is no activity on the data lines for a period of 3 ms.\nNote:Only accessible in Device mode.\nBit 10ESUSP: Early suspend\nThe core sets this bit to indicate that an Idle state has been detected on the USB for 3 ms.\nNote:Only accessible in Device mode.\nBits 9:8Reserved\nBit 7GONAKEFF: Global OUT NAK effective\nIndicates that the Set global OUT NAK bit in the Device control register (SGONAK bit in\nOTG_FS_DCTL), set by the application, has taken effect in the core. This bit can be cleared by\nwriting the Clear global OUT NAK bit in the Device control register (CGONAK bit in\nNote:Only accessible in Device mode.\nBit 6GINAKEFF: Global IN non-periodic NAK effective\nIndicates that the Set global non-periodic IN NAK bit in the Device control register (SGINAK bit\nin OTG_FS_DCTL), set by the application, has taken effect in the core. That is, the core has\nsampled the Global IN NAK bit set by the application. This bit can be cleared by clearing the\nClear global non-periodic IN NAK bit in the Device control register (CGINAK bit in\nThis interrupt does not necessarily mean that a NAK handshake is sent out on the USB. The\nSTALL bit takes precedence over the NAK bit.\nNote:Only accessible in Device mode.\nBit 5NPTXFE: Non-periodic TxFIFO empty\nThis interrupt is asserted when the non-periodic TxFIFO is either half or completely empty, and\nthere is space for at least one entry to be written to the non-periodic transmit request queue.\nThe half or completely empty status is determined by the non-periodic TxFIFO empty level bit\nin the core AHB configuration register (TXFELVL bit in OTG_FS_GAHBCFG).\nBit 4RXFLVL: RxFIFO non-empty\nIndicates that there is at least one packet pending to be read from the RxFIFO.\nNote:Accessible in both Host and Device modes.\nUSB on-the-go full-speed (OTG_FS)RM0008\n734/995 Doc ID 13902 Rev 9\nBit 3SOF: Start of frame\nIn Host mode, the core sets this bit to indicate that an SOF (FS), or Keep-Alive (LS) is\ntransmitted on the USB. The application must write a 1 to this bit to clear the interrupt.\nIn Device mode, in the core sets this bit to indicate that an SOF token has been received on\nthe USB. The application can read the Device Status register to get the current frame number.\nThis interrupt is seen only when the core is operating in FS.\nNote:Accessible in both Host and Device modes.\nBit 2OTGINT: OTG interrupt\nThe core sets this bit to indicate an OTG protocol event. The application must read the OTG\nInterrupt Status (OTG_FS_GOTGINT) register to determine the exact event that caused this\ninterrupt. The application must clear the appropriate status bit in the OTG_FS_GOTGINT\nregister to clear this bit.\nNote:Accessible in both Host and Device modes.\nBit 1MMIS: Mode mismatch interrupt\nThe core sets this bit when the application is trying to access:\nA Host mode register, when the core is operating in Device mode\nA Device mode register, when the core is operating in Host mode\nThe register access is completed on the AHB with an OKAY response, but is ignored by the\ncore internally and does not affect the operation of the core.\nNote:Accessible in both Host and Device modes.\nBit 0CMOD: Current mode of operation\nIndicates the current mode.\n0: Device mode\n1: Host mode\nNote:Accessible in both Host and Device modes.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9735/995"
  },
  {
    "start_page": 735,
    "end_page": 738,
    "page_range": "735-738",
    "section": "",
    "full_name": "OTG_FS interrupt mask register (OTG_FS_GINTMSK)",
    "short_name": "OTG_FS_GINTMSK",
    "address_offset": "0x018",
    "reset_value": "0x0000 0000",
    "content": "This register works with the Core interrupt register to interrupt the application. When an\ninterrupt bit is masked, the interrupt associated with that bit is not generated. However, the\nCore Interrupt (OTG_FS_GINTSTS) register bit corresponding to that interrupt is still set.\nBit 31WUIM: Resume/remote wakeup detected interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Host and Device modes.\nBit 30SRQIM: Session request/new session detected interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Host and Device modes.\nBit 29DISCINT: Disconnect detected interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Host and Device modes.\nBit 28CIDSCHGM: Connector ID status change mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Host and Device modes.\nBit 27Reserved\nBit 26PTXFEM: Periodic TxFIFO empty mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Host mode.\nBit 25HCIM: Host channels interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Host mode.\nBit 24PRTIM: Host port interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Host mode.\nUSB on-the-go full-speed (OTG_FS)RM0008\n736/995 Doc ID 13902 Rev 9\nBit 23Reserved\nBit 22FSUSPM: Data fetch suspended mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 21IPXFRM: Incomplete periodic transfer mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Host mode.\nIISOOXFRM: Incomplete isochronous OUT transfer mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 20IISOIXFRM: Incomplete isochronous IN transfer mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 19OEPINT: OUT endpoints interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 18IEPINT: IN endpoints interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 17EPMISM: Endpoint mismatch interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 16Reserved\nBit 15EOPFM: End of periodic frame interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 14ISOODRPM: Isochronous OUT packet dropped interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 13ENUMDNEM: Enumeration done mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9737/995\nBit 12USBRST: USB reset mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 11USBSUSPM: USB suspend mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 10ESUSPM: Early suspend mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBits 9:8Reserved.\nBit 7GONAKEFFM: Global OUT NAK effective mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 6GINAKEFFM: Global non-periodic IN NAK effective mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Only accessible in Device mode.\nBit 5NPTXFEM: Non-periodic TxFIFO empty mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Device and Host modes.\nBit 4RXFLVLM: Receive FIFO non-empty mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Device and Host modes.\nBit 3SOFM: Start of frame mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Device and Host modes.\nBit 2OTGINT: OTG interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Device and Host modes.\nBit 1MMISM: Mode mismatch interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nNote:Accessible in both Device and Host modes.\nBit 0Reserved\nUSB on-the-go full-speed (OTG_FS)RM0008\n738/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 739,
    "end_page": 740,
    "page_range": "739-740",
    "section": "",
    "full_name": "OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)",
    "short_name": "OTG_FS_GRXFSIZ",
    "address_offset": "0x024",
    "reset_value": "0x0000 0200",
    "content": "The application can program the RAM size that must be allocated to the RxFIFO.\nBits 31:25Reserved\nBits 24:21FRMNUM: Frame number\nThis is the least significant 4 bits of the frame number in which the packet is received on the\nUSB. This field is supported only when isochronous OUT endpoints are supported.\nBits 20:17PKTSTS: Packet status\nIndicates the status of the received packet\n0001: Global OUT NAK (triggers an interrupt)\n0010: OUT data packet received\n0011: OUT transfer completed (triggers an interrupt)\n0100: SETUP transaction completed (triggers an interrupt)\n0110: SETUP data packet received\nOthers: Reserved\nBits 16:15DPID: Data PID\nIndicates the Data PID of the received OUT data packet\n00: DATA0\n10: DATA1\n01: DATA2\n11: MDATA\nBits 14:4BCNT: Byte count\nIndicates the byte count of the received data packet.\nBits 3:0EPNUM: Endpoint number\nIndicates the endpoint number to which the current received packet belongs.\nBits 31:16Reserved\nBits 15:0RXFD: RxFIFO depth\nThis value is in terms of 32-bit words.\nMinimum value is 16\nMaximum value is 256\nThe power-on reset value of this register is specified as the largest Rx data FIFO depth.\nUSB on-the-go full-speed (OTG_FS)RM0008\n740/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 740,
    "end_page": 740,
    "page_range": "740",
    "section": "",
    "full_name": "OTG_FS non-periodic transmit FIFO size register (OTG_FS_GNPTXFSIZ)",
    "short_name": "OTG_FS_GNPTXFSIZ",
    "address_offset": "0x028",
    "reset_value": "0x0000 0200",
    "content": ""
  },
  {
    "start_page": 740,
    "end_page": 741,
    "page_range": "740-741",
    "section": "",
    "full_name": "OTG_FS non-periodic transmit FIFO/queue status register",
    "short_name": "",
    "address_offset": "0x02C",
    "reset_value": "0x0008 0200",
    "content": "Note:In Device mode, this register is not valid.\nThis read-only register contains the free space information for the non-periodic TxFIFO and\nthe non-periodic transmit request queue.\nBits 31:16NPTXFD: Non-periodic TxFIFO depth\nThis value is in terms of 32-bit words.\nMinimum value is 16\nMaximum value is 256\nBits 15:0NPTXFSA: Non-periodic transmit RAM start address\nThis field contains the memory start address for non-periodic transmit FIFO RAM.\nBit 31Reserved\nBits 30:24NPTXQTOP: Top of the non-periodic transmit request queue\nEntry in the non-periodic Tx request queue that is currently being processed by the MAC.\nBits [30:27]: Channel/endpoint number\nBits [26:25]:\n–00: IN/OUT token\n–01: Zero-length transmit packet (device IN/host OUT)\n–11: Channel halt command\nBit [24]: Terminate (last entry for selected channel/endpoint)\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9741/995"
  },
  {
    "start_page": 741,
    "end_page": 742,
    "page_range": "741-742",
    "section": "",
    "full_name": "OTG_FS general core configuration register (OTG_FS_GCCFG)",
    "short_name": "OTG_FS_GCCFG",
    "address_offset": "0x038",
    "reset_value": "0x0000 0000",
    "content": "Bits 23:16NPTQXSAV: Non-periodic transmit request queue space available\nIndicates the amount of free space available in the non-periodic transmit request queue. This\nqueue holds both IN and OUT requests in Host mode. Device mode has only IN requests.\n00: Non-periodic transmit request queue is full\n01: dx1 location available\n10: dx2 locations available\nbxn: dxn locations available (0  n  dx8)\nOthers: Reserved\nBits 15:0NPTXFSAV: Non-periodic TxFIFO space available\nIndicates the amount of free space available in the non-periodic TxFIFO.\nValues are in terms of 32-bit words.\n00: Non-periodic TxFIFO is full\n01: dx1 word available\n10: dx2 words available\n0xn: dxn words available (where 0  n  dx256)\nOthers: Reserved\nBits 31:21Reserved\nBit 20SOFOUTEN: SOF output enable\n0 = SOF pulse not available on PAD\n1 = SOF pulse available on PAD\nBit 19VBUSBSEN: Enable the V\nsensing “B” device\n0 = V\nsensing “B” disabled\n1 = V\nsensing “B” enabled\nBit 18VBUSASEN: Enable the V\nsensing “A” device\n0 = V\nsensing “A” disabled\n1 = V\nsensing “A” enabled\nBit 17Reserved\nBit 16PWRDWN: Power down\nUsed to activate the transceiver in transmission/reception\n0 = Power down active\n1 = Power down deactivated (“Transceiver active”)\nBits 15:0Reserved.\nUSB on-the-go full-speed (OTG_FS)RM0008\n742/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 742,
    "end_page": 742,
    "page_range": "742",
    "section": "",
    "full_name": "OTG_FS core ID register (OTG_FS_CID)",
    "short_name": "OTG_FS_CID",
    "address_offset": "0x03C",
    "reset_value": "0x00001000",
    "content": "This is a read only register containing the Product ID."
  },
  {
    "start_page": 742,
    "end_page": 743,
    "page_range": "742-743",
    "section": "",
    "full_name": "OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)",
    "short_name": "OTG_FS_HPTXFSIZ",
    "address_offset": "0x100",
    "reset_value": "0x0200 0600",
    "content": "Bits 31:0PRODUCT_ID: Product ID field\nApplication-programmable ID field.\nBits 31:16PTXFSIZ: Host periodic TxFIFO depth\nThis value is in terms of 32-bit words.\nMinimum value is 16\nMaximum value is 512\nBits 15:0PTXSA: Host periodic TxFIFO start address\nThe power-on reset value of this register is the sum of the largest Rx data FIFO depth and\nlargest non-periodic Tx data FIFO depth.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9743/995"
  },
  {
    "start_page": 743,
    "end_page": 743,
    "page_range": "743",
    "section": "",
    "full_name": "OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXFx)",
    "short_name": "",
    "address_offset": "0x104",
    "reset_value": "0x02000400",
    "content": "(x=1..4, where x is the FIFO_number)"
  },
  {
    "start_page": 743,
    "end_page": 744,
    "page_range": "743-744",
    "section": "",
    "full_name": "OTG_FS host configuration register (OTG_FS_HCFG)",
    "short_name": "OTG_FS_HCFG",
    "address_offset": "0x400",
    "reset_value": "0x0000 0000",
    "content": "This register configures the core after power-on. Do not make changes to this register after\ninitializing the host.\nBits 31:16INEPTXFD: IN endpoint TxFIFO depth\nThis value is in terms of 32-bit words.\nMinimum value is 16\nMaximum value is 512\nThe power-on reset value of this register is specified as the largest IN endpoint FIFO number\nBits 15:0INEPTXSA: IN endpoint FIFOx transmit RAM start address\nThis field contains the memory start address for IN endpoint transmit FIFOx.\nBits 31:3Reserved\nBit 2FSLSS: FS- and LS-only support\nThe application uses this bit to control the core’s enumeration speed. Using this bit, the\napplication can make the core enumerate as an FS host, even if the connected device\nsupports HS traffic. Do not make changes to this field after initial programming.\n1: FS/LS-only, even if the connected device can support HS (read-only)\nUSB on-the-go full-speed (OTG_FS)RM0008\n744/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 744,
    "end_page": 745,
    "page_range": "744-745",
    "section": "",
    "full_name": "OTG_FS Host frame interval register (OTG_FS_HFIR)",
    "short_name": "OTG_FS_HFIR",
    "address_offset": "0x404",
    "reset_value": "0x0000 EA60",
    "content": "This register stores the frame interval information for the current speed to which the\nOTG_FS controller has enumerated.\nBits 1:0FSLSPCS: FS/LS PHY clock select\nWhen the core is in FS Host mode\n01: PHY clock is running at 48 MHz\nOthers: Reserved\nWhen the core is in LS Host mode\n00: Reserved\n01: PHY clock is running at 48 MHz.\n10: PHY clock is running at 6 MHz. In USB 1.1 FS mode, use 6 MHz when the UTMIFS PHY\nlow power mode is selected and the PHY supplies a 6 MHz clock during LS mode. If you\nselect a 6 MHz clock during LS mode, you must do a soft reset.\n11: Reserved\nBits 31:16Reserved\nBits 15:0FRIVL: Frame interval\nThe value that the application programs to this field specifies the interval between two\nconsecutive SOFs (FS) or Keep-Alive tokens (LS). This field contains the number of PHY\nclocks that constitute the required frame interval. The application can write a value to this\nregister only after the Port enable bit of the Host port control and status register (PENA bit in\nOTG_FS_HPRT) has been set. If no value is programmed, the core calculates the value based\non the PHY clock specified in the FS/LS PHY Clock Select field of the Host configuration\nregister (FSLSPCS in OTG_FS_HCFG). Do not change the value of this field after the initial\n1 ms × (PHY clock frequency for FS/LS)\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9745/995"
  },
  {
    "start_page": 745,
    "end_page": 745,
    "page_range": "745",
    "section": "",
    "full_name": "OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)",
    "short_name": "OTG_FS_HFNUM",
    "address_offset": "0x408",
    "reset_value": "0x0000 3FFF",
    "content": "This register indicates the current frame number. It also indicates the time remaining (in\nterms of the number of PHY clocks) in the current frame."
  },
  {
    "start_page": 745,
    "end_page": 746,
    "page_range": "745-746",
    "section": "",
    "full_name": "OTG_FS_Host periodic transmit FIFO/queue status register",
    "short_name": "",
    "address_offset": "0x410",
    "reset_value": "0x0008 0100",
    "content": "This read-only register contains the free space information for the periodic TxFIFO and the\nperiodic transmit request queue.\nBits 31:16FTREM: Frame time remaining\nIndicates the amount of time remaining in the current frame, in terms of PHY clocks. This field\ndecrements on each PHY clock. When it reaches zero, this field is reloaded with the value in\nthe Frame interval register and a new SOF is transmitted on the USB.\nBits 15:0FRNUM: Frame number\nThis field increments when a new SOF is transmitted on the USB, and is cleared to 0 when it\nreaches 0x3FFF.\nBits 31:24PTXQTOP: Top of the periodic transmit request queue\nThis indicates the entry in the periodic Tx request queue that is currently being processed by\nthe MAC.\nThis register is used for debugging.\nBit [31]: Odd/Even frame\n–0: send in even frame\n–1: send in odd frame\nBits [30:27]: Channel/endpoint number\nBits [26:25]: Type\n–00: IN/OUT\n–01: Zero-length packet\n–11: Disable channel command\nBit [24]: Terminate (last entry for the selected channel/endpoint)\nUSB on-the-go full-speed (OTG_FS)RM0008\n746/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 746,
    "end_page": 747,
    "page_range": "746-747",
    "section": "",
    "full_name": "OTG_FS Host all channels interrupt register (OTG_FS_HAINT)",
    "short_name": "OTG_FS_HAINT",
    "address_offset": "0x414",
    "reset_value": "0x0000 000",
    "content": "When a significant event occurs on a channel, the Host all channels interrupt register\ninterrupts the application using the Host channels interrupt bit of the Core interrupt register\n(HCINT bit in OTG_FS_GINTSTS). This is shown in Figure268. There is one interrupt bit\nper channel, up to a maximum of 16 bits. Bits in this register are set and cleared when the\napplication sets and clears bits in the corresponding Host channel-x interrupt register.\nBits 23:16PTXQSAV: Periodic transmit request queue space available\nIndicates the number of free locations available to be written in the periodic transmit request\nqueue. This queue holds both IN and OUT requests.\n00: Periodic transmit request queue is full\n01: dx1 location available\n10: dx2 locations available\nbxn: dxn locations available (0  dxn  8)\nOthers: Reserved\nBits 15:0PTXFSAVL: Periodic transmit data FIFO space available\nIndicates the number of free locations available to be written to in the periodic TxFIFO.\nValues are in terms of 32-bit words\n0000: Periodic TxFIFO is full\n0001: dx1 word available\n0010: dx2 words available\nbxn: dxn words available (where 0dxndx512)\nbx200: dx512 words available\nOthers: Reserved\nBits 31:16Reserved\nBits 15:0HAINT: Channel interrupts\nOne bit per channel: Bit 0 for Channel 0, bit 15 for Channel 15\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9747/995"
  },
  {
    "start_page": 747,
    "end_page": 747,
    "page_range": "747",
    "section": "",
    "full_name": "OTG_FS host all channels interrupt mask register (OTG_FS_HAINTMSK)",
    "short_name": "OTG_FS_HAINTMSK",
    "address_offset": "0x418",
    "reset_value": "0x0000 0000",
    "content": "The host all channel interrupt mask register works with the host all channel interrupt register\nto interrupt the application when an event occurs on a channel. There is one interrupt mask\nbit per channel, up to a maximum of 16 bits."
  },
  {
    "start_page": 747,
    "end_page": 750,
    "page_range": "747-750",
    "section": "",
    "full_name": "OTG_FS host port control and status register (OTG_FS_HPRT)",
    "short_name": "OTG_FS_HPRT",
    "address_offset": "0x440",
    "reset_value": "0x0000 0000",
    "content": "This register is available only in Host mode. Currently, the OTG Host supports only one port.\nA single register holds USB port-related information such as USB reset, enable, suspend,\nresume, connect status, and test mode for each port. It is shown in Figure268. The rc_w1\nbits in this register can trigger an interrupt to the application through the Host port interrupt\nbit of the core interrupt register (HPRTINT bit in OTG_FS_GINTSTS). On a Port Interrupt,\nthe application must read this register and clear the bit that caused the interrupt. For the\nrc_w1 bits, the application must write a 1 to the bit to clear the interrupt.\nBits 31:16Reserved\nBits 15:0HAINTM: Channel interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nOne bit per channel: Bit 0 for channel 0, bit 15 for channel 15\nBits 31:19Reserved\nBits 18:17PSPD: Port speed\nIndicates the speed of the device attached to this port.\n01: Full speed\n10: Low speed\n11: Reserved\nUSB on-the-go full-speed (OTG_FS)RM0008\n748/995 Doc ID 13902 Rev 9\nBits 16:13PTCTL: Port test control\nThe application writes a nonzero value to this field to put the port into a Test mode, and the\ncorresponding pattern is signaled on the port.\n0000: Test mode disabled\n0001: Test_J mode\n0010: Test_K mode\n0011: Test_SE0_NAK mode\n0100: Test_Packet mode\n0101: Test_Force_Enable\nOthers: Reserved\nBit 12PPWR: Port power\nThe application uses this field to control power to this port, and the core clears this bit on an\novercurrent condition.\n0: Power off\n1: Power on\nBits 11:10PLSTS: Port line status\nIndicates the current logic level USB data lines\nBit [10]: Logic level of OTG_FS_FS_DP\nBit [11]: Logic level of OTG_FS_FS_DM\nBit 9Reserved\nBit 8PRST: Port reset\nWhen the application sets this bit, a reset sequence is started on this port. The application\nmust time the reset period and clear this bit after the reset sequence is complete.\n0: Port not in reset\n1: Port in reset\nThe application must leave this bit set for a minimum duration of at least 10ms to start a reset\non the port. The application can leave it set for another 10 ms in addition to the required\nminimum duration, before clearing the bit, even though there is no maximum limit set by the\nUSB standard.\nBit 7PSUSP: Port suspend\nThe application sets this bit to put this port in Suspend mode. The core only stops sending\nSOFs when this is set. To stop the PHY clock, the application must set the Port clock stop bit,\nwhich asserts the suspend input pin of the PHY.\nThe read value of this bit reflects the current suspend status of the port. This bit is cleared by\nthe core after a remote wakeup signal is detected or the application sets the Port reset bit or\nPort resume bit in this register or the Resume/remote wakeup detected interrupt bit or\nDisconnect detected interrupt bit in the Core interrupt register (WKUINT or DISCINT in\nOTG_FS_GINTSTS, respectively).\n0: Port not in Suspend mode\n1: Port in Suspend mode\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9749/995\nBit 6PRES: Port resume\nThe application sets this bit to drive resume signaling on the port. The core continues to drive\nthe resume signal until the application clears this bit.\nIf the core detects a USB remote wakeup sequence, as indicated by the Port resume/remote\nwakeup detected interrupt bit of the Core interrupt register (WKUINT bit in\nOTG_FS_GINTSTS), the core starts driving resume signaling without application intervention\nand clears this bit when it detects a disconnect condition. The read value of this bit indicates\nwhether the core is currently driving resume signaling.\n0: No resume driven\n1: Resume driven\nBit 5POCCHNG: Port overcurrent change\nThe core sets this bit when the status of the Port overcurrent active bit (bit 4) in this register\nBit 4POCA: Port overcurrent active\nIndicates the overcurrent condition of the port.\n0: No overcurrent condition\n1: Overcurrent condition\nBit 3PENCHNG: Port enable/disable change\nThe core sets this bit when the status of the Port enable bit [2] in this register changes.\nBit 2PENA: Port enable\nA port is enabled only by the core after a reset sequence, and is disabled by an overcurrent\ncondition, a disconnect condition, or by the application clearing this bit. The application cannot\nset this bit by a register write. It can only clear it to disable the port. This bit does not trigger\nany interrupt to the application.\n0: Port disabled\n1: Port enabled\nBit 1PCDET: Port connect detected\nThe core sets this bit when a device connection is detected to trigger an interrupt to the\napplication using the Host port interrupt bit in the Core interrupt register (HPRTINT bit in\nOTG_FS_GINTSTS). The application must write a 1 to this bit to clear the interrupt.\nBit 0PCSTS: Port connect status\n0: No device is attached to the port\n1: A device is attached to the port\nUSB on-the-go full-speed (OTG_FS)RM0008\n750/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 750,
    "end_page": 751,
    "page_range": "750-751",
    "section": "",
    "full_name": "OTG_FS host channel-x characteristics register (OTG_FS_HCCHARx)",
    "short_name": "",
    "address_offset": "0x500",
    "reset_value": "0x0000 0000",
    "content": "(x=0..7, where x=Channel_number)\nBit 31CHENA: Channel enable\nThis field is set by the application and cleared by the OTG host.\n0: Channel disabled\n1: Channel enabled\nBit 30CHDIS: Channel disable\nThe application sets this bit to stop transmitting/receiving data on a channel, even before the\ntransfer for that channel is complete. The application must wait for the Channel disabled\ninterrupt before treating the channel as disabled.\nBit 29ODDFRM: Odd frame\nThis field is set (reset) by the application to indicate that the OTG host must perform a transfer\nin an odd frame. This field is applicable for only periodic (isochronous and interrupt)\n0: Even frame\n1: Odd frame\nBits 28:22DAD: Device address\nThis field selects the specific device serving as the data source or sink.\nBits 21:20Reserved\nBits 19:18EPTYP: Endpoint type\nIndicates the transfer type selected.\n00: Control\n01: Isochronous\n10: Bulk\n11: Interrupt\nBit 17LSDEV: Low-speed device\nThis field is set by the application to indicate that this channel is communicating to a low-\nspeed device.\nBit 16Reserved\nBit 15EPDIR: Endpoint direction\nIndicates whether the transaction is IN or OUT.\n0: OUT\n1: IN\nBits 14:11EPNUM: Endpoint number\nIndicates the endpoint number on the device serving as the data source or sink.\nBits 10:0MPSIZ: Maximum packet size\nIndicates the maximum packet size of the associated endpoint.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9751/995"
  },
  {
    "start_page": 751,
    "end_page": 752,
    "page_range": "751-752",
    "section": "",
    "full_name": "OTG_FS host channel-x interrupt register (OTG_FS_HCINTx) (x=0..7, where",
    "short_name": "",
    "address_offset": "0x508",
    "reset_value": "0x0000 0000",
    "content": "This register indicates the status of a channel with respect to USB- and AHB-related events.\nIt is shown in Figure268. The application must read this register when the Host channels\ninterrupt bit in the Core interrupt register (HCINT bit in OTG_FS_GINTSTS) is set. Before\nthe application can read this register, it must first read the Host all channels interrupt\n(OTG_FS_HAINT) register to get the exact channel number for the Host channel-x interrupt\nregister. The application must clear the appropriate bit in this register to clear the\ncorresponding bits in the OTG_FS_HAINT and OTG_FS_GINTSTS registers.\nBits 31:11Reserved\nBit 10DTERR: Data toggle error\nBit 9FRMOR: Frame overrun\nBit 8BBERR: Babble error\nBit 7TXERR: Transaction error\nIndicates one of the following errors occurred on the USB.\nCRC check failure\nBit stuff error\nFalse EOP\nBit 6Reserved\nBit 5ACK: ACK response received/transmitted interrupt\nBit 4NAK: NAK response received interrupt\nBit 3STALL: STALL response received interrupt\nBit 2Reserved\nBit 1CHH: Channel halted\nIndicates the transfer completed abnormally either because of any USB transaction error or in\nresponse to disable request by the application.\nBit 0XFRC: Transfer completed\nTransfer completed normally without any errors.\nUSB on-the-go full-speed (OTG_FS)RM0008\n752/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 752,
    "end_page": 753,
    "page_range": "752-753",
    "section": "",
    "full_name": "OTG_FS host channel-x interrupt mask register (OTG_FS_HCINTMSKx)",
    "short_name": "",
    "address_offset": "0x50C",
    "reset_value": "0x0000 0000",
    "content": "(x=0..7, where x=Channel_number)\nThis register reflects the mask for each channel status described in the previous section.\nBits 31:11Reserved\nBit 10DTERRM: Data toggle error mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 9FRMORM: Frame overrun mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 8BBERRM: Babble error mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 7TXERRM: Transaction error mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 6NYET: response received interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 5ACKM: ACK response received/transmitted interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 4NAKM: NAK response received interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 3STALLM: STALL response received interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 2Reserved\nBit 1CHHM: Channel halted mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 0XFRCM: Transfer completed mask\n0: Masked interrupt\n1: Unmasked interrupt\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9753/995"
  },
  {
    "start_page": 753,
    "end_page": 754,
    "page_range": "753-754",
    "section": "",
    "full_name": "OTG_FS host channel-x transfer size register (OTG_FS_HCTSIZx) (x=0..7,",
    "short_name": "",
    "address_offset": "0x510",
    "reset_value": "0x0000 0000",
    "content": "where x=Channel_number)\nBit 31Reserved\nBits 30:29DPID: Data PID\nThe application programs this field with the type of PID to use for the initial transaction. The\nhost maintains this field for the rest of the transfer.\n00: DATA0\n01: DATA2\n10: DATA1\n11: MDATA (non-control)/SETUP (control)\nBits 28:19PKTCNT: Packet count\nThis field is programmed by the application with the expected number of packets to be\ntransmitted (OUT) or received (IN).\nThe host decrements this count on every successful transmission or reception of an OUT/IN\npacket. Once this count reaches zero, the application is interrupted to indicate normal\nBits 18:0XFRSIZ: Transfer size\nFor an OUT, this field is the number of data bytes the host sends during the transfer.\nFor an IN, this field is the buffer size that the application has reserved for the transfer. The\napplication is expected to program this field as an integer multiple of the maximum packet size\nfor IN transactions (periodic and non-periodic).\nUSB on-the-go full-speed (OTG_FS)RM0008\n754/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 754,
    "end_page": 755,
    "page_range": "754-755",
    "section": "",
    "full_name": "OTG_FS device configuration register (OTG_FS_DCFG)",
    "short_name": "OTG_FS_DCFG",
    "address_offset": "0x800",
    "reset_value": "0x0220 0000",
    "content": "This register configures the core in Device mode after power-on or after certain control\ncommands or enumeration. Do not make changes to this register after initial programming.\nBits 31:13Reserved\nBits 12:11PFIVL: Periodic frame interval\nIndicates the time within a frame at which the application must be notified using the end of\nperiodic frame interrupt. This can be used to determine if all the isochronous traffic for that\nframe is complete.\n00: 80% of the frame interval\n01: 85% of the frame interval\n10: 90% of the frame interval\n11: 95% of the frame interval\nBits 10:4DAD: Device address\nThe application must program this field after every SetAddress control command.\nBit 3Reserved\nBit 2NZLSOHSK: Non-zero-length status OUT handshake\nThe application can use this field to select the handshake the core sends on receiving a\nnonzero-length data packet during the OUT transaction of a control transfer’s Status stage.\n1: Send a STALL handshake on a nonzero-length status OUT transaction and do not send\nthe received OUT packet to the application.\n0: Send the received OUT packet to the application (zero-length or nonzero-length) and\nsend a handshake based on the NAK and STALL bits for the endpoint in the Device endpoint\ncontrol register.\nBits 1:0DSPD: Device speed\nIndicates the speed at which the application requires the core to enumerate, or the maximum\nspeed the application can support. However, the actual bus speed is determined only after the\nchirp sequence is completed, and is based on the speed of the USB host to which the core is\n00: Reserved\n01: Reserved\n10: Reserved\n11: Full speed (USB 1.1 transceiver clock is 48 MHz)\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9755/995"
  },
  {
    "start_page": 755,
    "end_page": 756,
    "page_range": "755-756",
    "section": "",
    "full_name": "OTG_FS device control register (OTG_FS_DCTL)",
    "short_name": "OTG_FS_DCTL",
    "address_offset": "0x804",
    "reset_value": "0x0000 0000",
    "content": "Bits 31:12Reserved\nBit 11POPRGDNE: Power-on programming done\nThe application uses this bit to indicate that register programming is completed after a wakeup\nfrom power down mode.\nBit 10CGONAK: Clear global OUT NAK\nA write to this field clears the Global OUT NAK.\nBit 9SGONAK: Set global OUT NAK\nA write to this field sets the Global OUT NAK.\nThe application uses this bit to send a NAK handshake on all OUT endpoints.\nThe application must set the this bit only after making sure that the Global OUT NAK effective\nbit in the Core interrupt register (GONAKEFF bit in OTG_FS_GINTSTS) is cleared.\nBit 8CGINAK: Clear global IN NAK\nA write to this field clears the Global IN NAK.\nBit 7SGINAK: Set global IN NAK\nA write to this field sets the Global non-periodic IN NAK.The application uses this bit to send a\nNAK handshake on all non-periodic IN endpoints.\nThe application must set this bit only after making sure that the Global IN NAK effective bit in\nthe Core interrupt register (GINAKEFF bit in OTG_FS_GINTSTS) is cleared.\nBits 6:4TCTL: Test control\n000: Test mode disabled\n001: Test_J mode\n010: Test_K mode\n011: Test_SE0_NAK mode\n100: Test_Packet mode\n101: Test_Force_Enable\nOthers: Reserved\nBit 3GONSTS: Global OUT NAK status\n0: A handshake is sent based on the FIFO Status and the NAK and STALL bit settings.\n1: No data is written to the RxFIFO, irrespective of space availability. Sends a NAK\nhandshake on all packets, except on SETUP transactions. All isochronous OUT packets are\nUSB on-the-go full-speed (OTG_FS)RM0008\n756/995 Doc ID 13902 Rev 9\nTable186 contains the minimum duration (according to device state) for which the Soft\ndisconnect (SDIS) bit must be set for the USB host to detect a device disconnect. To\naccommodate clock jitter, it is recommended that the application add some extra delay to\nthe specified minimum duration."
  },
  {
    "start_page": 756,
    "end_page": 757,
    "page_range": "756-757",
    "section": "",
    "full_name": "OTG_FS device status register (OTG_FS_DSTS)",
    "short_name": "OTG_FS_DSTS",
    "address_offset": "0x808",
    "reset_value": "0x0000 0010",
    "content": "This register indicates the status of the core with respect to USB-related events. It must be\nread on interrupts from the Device all interrupts (OTG_FS_DAINT) register.\nBit 2GINSTS: Global IN NAK status\n0: A handshake is sent out based on the data availability in the transmit FIFO.\n1: A NAK handshake is sent out on all non-periodic IN endpoints, irrespective of the data\navailability in the transmit FIFO.\nBit 1SDIS: Soft disconnect\nThe application uses this bit to signal the USB OTG core to perform a soft disconnect. As long\nas this bit is set, the host does not see that the device is connected, and the device does not\nreceive signals on the USB. The core stays in the disconnected state until the application\nclears this bit.\n0: Normal operation. When this bit is cleared after a soft disconnect, the core generates a\ndevice connect event to the USB host. When the device is reconnected, the USB host\nrestarts device enumeration.\n1: The core generates a device disconnect event to the USB host.\nBit 0RWUSIG: Remote wakeup signaling\nWhen the application sets this bit, the core initiates remote signaling to wake up the USB host.\nThe application must set this bit to instruct the core to exit the Suspend state. As specified in\nthe USB 2.0 specification, the application must clear this bit 1 ms to 15 ms after setting it.\nTable 186.Minimum duration for soft disconnect\nOperating speedDevice stateMinimum duration\nFull speedSuspended1 ms + 2.5 µs\nFull speedIdle2.5 µs\nFull speedNot Idle or Suspended (Performing transactions)2.5 µs\nBits 31:22Reserved\nBits 21:8FNSOF: Frame number of the received SOF\nBits 7:4Reserved\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9757/995"
  },
  {
    "start_page": 757,
    "end_page": 758,
    "page_range": "757-758",
    "section": "",
    "full_name": "OTG_FS device IN endpoint common interrupt mask register",
    "short_name": "",
    "address_offset": "0x810",
    "reset_value": "0x0000 0000",
    "content": "This register works with each of the Device IN endpoint interrupt (OTG_FS_DIEPINTx)\nregisters for all endpoints to generate an interrupt per IN endpoint. The IN endpoint interrupt\nfor a specific status in the OTG_FS_DIEPINTx register can be masked by writing to the\ncorresponding bit in this register. Status bits are masked by default.\nBit 3EERR: Erratic error\nThe core sets this bit to report any erratic errors.\nDue to erratic errors, the OTG_FS controller goes into Suspended state and an interrupt is\ngenerated to the application with Early suspend bit of the Core interrupt register (ESUSP bit in\nOTG_FS_GINTSTS). If the early suspend is asserted due to an erratic error, the application\ncan only perform a soft disconnect recover.\nBits 2:1ENUMSPD: Enumerated speed\nIndicates the speed at which the OTG_FS controller has come up after speed detection\nthrough a chirp sequence.\n01: Reserved\n10: Reserved\n11: Full speed (PHY clock is running at 48 MHz)\nOthers: reserved\nBit 0SUSPSTS: Suspend status\nIn Device mode, this bit is set as long as a Suspend condition is detected on the USB. The core\nenters the Suspended state when there is no activity on the USB data lines for a period of\n3ms. The core comes out of the suspend:\n–When there is an activity on the USB data lines\n–When the application writes to the Remote wakeup signaling bit in the Device control register\n(RWUSIG bit in OTG_FS_DCTL).\nBits 31:10Reserved\nBit 9BIM: BNA interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 8TXFURM: FIFO underrun mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 7Reserved\nUSB on-the-go full-speed (OTG_FS)RM0008\n758/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 758,
    "end_page": 759,
    "page_range": "758-759",
    "section": "",
    "full_name": "OTG_FS device OUT endpoint common interrupt mask register",
    "short_name": "",
    "address_offset": "0x814",
    "reset_value": "0x0000 0000",
    "content": "This register works with each of the Device OUT endpoint interrupt (OTG_FS_DOEPINTx)\nregisters for all endpoints to generate an interrupt per OUT endpoint. The OUT endpoint\ninterrupt for a specific status in the OTG_FS_DOEPINTx register can be masked by writing\ninto the corresponding bit in this register. Status bits are masked by default.\nBit 6INEPNEM: IN endpoint NAK effective mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 5INEPNMM: IN token received with EP mismatch mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 4ITTXFEMSK: IN token received when TxFIFO empty mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 3TOM: Timeout condition mask (Non-isochronous endpoints)\n0: Masked interrupt\n1: Unmasked interrupt\nBit 2Reserved\nBit 1EPDM: Endpoint disabled interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 0XFRCM: Transfer completed interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBits 31:10Reserved\nBit 9BOIM: BNA interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 8OPEM: OUT packet error mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 7Reserved\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9759/995"
  },
  {
    "start_page": 759,
    "end_page": 760,
    "page_range": "759-760",
    "section": "",
    "full_name": "OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)",
    "short_name": "OTG_FS_DAINT",
    "address_offset": "0x818",
    "reset_value": "0x0000 0000",
    "content": "When a significant event occurs on an endpoint, a Device all endpoints interrupt register\ninterrupts the application using the Device OUT endpoints interrupt bit or Device IN\nendpoints interrupt bit of the Core interrupt register (OEPINT or IEPINT in\nOTG_FS_GINTSTS, respectively). There is one interrupt bit per endpoint, up to a maximum\nof 16 bits for OUT endpoints and 16 bits for IN endpoints. For a bidirectional endpoint, the\ncorresponding IN and OUT interrupt bits are used. Bits in this register are set and cleared\nwhen the application sets and clears bits in the corresponding Device Endpoint-x interrupt\nregister (OTG_FS_DIEPINTx/OTG_FS_DOEPINTx).\nBit 6B2BSTUP: Back-to-back SETUP packets received mask\nApplies to control OUT endpoints only.\n0: Masked interrupt\n1: Unmasked interrupt\nBit 5Reserved\nBit 4OTEPDM: OUT token received when endpoint disabled mask\nApplies to control OUT endpoints only.\n0: Masked interrupt\n1: Unmasked interrupt\nBit 3STUPM: SETUP phase done mask\nApplies to control endpoints only.\n0: Masked interrupt\n1: Unmasked interrupt\nBit 2Reserved\nBit 1EPDM: Endpoint disabled interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBit 0XFRCM: Transfer completed interrupt mask\n0: Masked interrupt\n1: Unmasked interrupt\nBits 31:16OEPINT: OUT endpoint interrupt bits\nOne bit per OUT endpoint:\nBit 16 for OUT endpoint 0, bit 31 for OUT endpoint 15\nBits 15:0IEPINT: IN endpoint interrupt bits\nOne bit per IN endpoint:\nBit 0 for IN endpoint 0, bit 15 for endpoint 15\nUSB on-the-go full-speed (OTG_FS)RM0008\n760/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 760,
    "end_page": 760,
    "page_range": "760",
    "section": "",
    "full_name": "OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)",
    "short_name": "OTG_FS_DAINTMSK",
    "address_offset": "0x81C",
    "reset_value": "0x0000 0000",
    "content": "The Device endpoint interrupt mask register works with the Device endpoint interrupt\nregister to interrupt the application when an event occurs on a device endpoint. However,\nthe Device all endpoints interrupt (OTG_FS_DAINT) register bit corresponding to that\ninterrupt is still set.\nOTG_FS device V"
  },
  {
    "start_page": 760,
    "end_page": 761,
    "page_range": "760-761",
    "section": "",
    "full_name": "discharge time register (OTG_FS_DVBUSDIS)",
    "short_name": "OTG_FS_DVBUSDIS",
    "address_offset": "0x0828",
    "reset_value": "0x0000 17D7",
    "content": "This register specifies the V\ndischarge time after V\npulsing during SRP.\nBits 31:16OEPM: OUT EP interrupt mask bits\nOne per OUT endpoint:\nBit 16 for OUT EP 0, bit 18 for OUT EP 3\n0: Masked interrupt\n1: Unmasked interrupt\nBits 15:0IEPM: IN EP interrupt mask bits\nOne bit per IN endpoint:\nBit 0 for IN EP 0, bit 3 for IN EP 3\n0: Masked interrupt\n1: Unmasked interrupt\nBits 31:16Reserved\nBits 15:0VBUSDT: Device V\ndischarge time\nSpecifies the V\ndischarge time after V\npulsing during SRP. This value equals:\ndischarge time in PHY clocks / 1 024\nDepending on your V\nload, this value may need adjusting.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9761/995\nOTG_FS device V"
  },
  {
    "start_page": 761,
    "end_page": 761,
    "page_range": "761",
    "section": "",
    "full_name": "pulsing time register (OTG_FS_DVBUSPULSE)",
    "short_name": "OTG_FS_DVBUSPULSE",
    "address_offset": "0x082C",
    "reset_value": "0x0000 05B8",
    "content": "This register specifies the V\npulsing time during SRP."
  },
  {
    "start_page": 761,
    "end_page": 762,
    "page_range": "761-762",
    "section": "",
    "full_name": "OTG_FS device IN endpoint FIFO empty interrupt mask register:",
    "short_name": "",
    "address_offset": "0x834",
    "reset_value": "0x0000 0000",
    "content": "This register is used to control the IN endpoint FIFO empty interrupt generation\nBits 31:12Reserved\nBits 11:0DVBUSP: Device V\npulsing time\nSpecifies the V\npulsing time during SRP. This value equals:\npulsing time in PHY clocks / 1 024\nBits 31:16Reserved\nBits 15:0INEPTXFEM: IN EP Tx FIFO empty interrupt mask bits\nThese bits act as mask bits for OTG_FS_DIEPINTx.\nTXFE interrupt one bit per IN endpoint:\nBit 0 for IN endpoint 0, bit 15 for IN endpoint 15\n0: Masked interrupt\n1: Unmasked interrupt\nUSB on-the-go full-speed (OTG_FS)RM0008\n762/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 762,
    "end_page": 763,
    "page_range": "762-763",
    "section": "",
    "full_name": "OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)",
    "short_name": "OTG_FS_DIEPCTL0",
    "address_offset": "0x900",
    "reset_value": "0x0000 0000",
    "content": "This section describes the device control IN endpoint 0 control register. Nonzero control\nendpoints use registers for endpoints 1–15.\nBit 31EPENA: Endpoint enable\nThe application sets this bit to start transmitting data on the endpoint 0.\nThe core clears this bit before setting any of the following interrupts on this endpoint:\n–Endpoint disabled\n–Transfer completed\nBit 30EPDIS: Endpoint disable\nThe application sets this bit to stop transmitting data on an endpoint, even before the transfer\nfor that endpoint is complete. The application must wait for the Endpoint disabled interrupt\nbefore treating the endpoint as disabled. The core clears this bit before setting the Endpoint\ndisabled interrupt. The application must set this bit only if Endpoint enable is already set for\nthis endpoint.\nBits 29:28Reserved\nBit 27SNAK: Set NAK\nA write to this bit sets the NAK bit for the endpoint.\nUsing this bit, the application can control the transmission of NAK handshakes on an endpoint.\nThe core can also set this bit for an endpoint after a SETUP packet is received on that\nBit 26CNAK: Clear NAK\nA write to this bit clears the NAK bit for the endpoint.\nBits 25:22TXFNUM: TxFIFO number\nThis value is set to the FIFO number that is assigned to IN endpoint 0.\nBit 21STALL: STALL handshake\nThe application can only set this bit, and the core clears it when a SETUP token is received for\nthis endpoint. If a NAK bit, a Global IN NAK or Global OUT NAK is set along with this bit, the\nSTALL bit takes priority.\nBit 20Reserved\nBits 19:18EPTYP: Endpoint type\nHardcoded to ‘00’ for control.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9763/995"
  },
  {
    "start_page": 763,
    "end_page": 766,
    "page_range": "763-766",
    "section": "",
    "full_name": "OTG device endpoint-x control register (OTG_FS_DIEPCTLx) (x = 1..3, where",
    "short_name": "",
    "address_offset": "0x900",
    "reset_value": "0x0000 0000",
    "content": "x= Endpoint_number)\nThe application uses this register to control the behavior of each logical endpoint other than\nendpoint 0.\nBit 17NAKSTS: NAK status\nIndicates the following:\n0: The core is transmitting non-NAK handshakes based on the FIFO status\n1: The core is transmitting NAK handshakes on this endpoint.\nWhen this bit is set, either by the application or core, the core stops transmitting data, even if\nthere are data available in the TxFIFO. Irrespective of this bit’s setting, the core always\nresponds to SETUP data packets with an ACK handshake.\nBit 16Reserved\nBit 15USBAEP: USB active endpoint\nThis bit is always set to 1, indicating that control endpoint 0 is always active in all\nconfigurations and interfaces.\nBits 14:2Reserved\nBits 1:0MPSIZ: Maximum packet size\nThe application must program this field with the maximum packet size for the current logical\n00: 64 bytes\n01: 32 bytes\n10: 16 bytes\n11: 8 bytes\nBit 31EPENA: Endpoint enable\nThe application sets this bit to start transmitting data on an endpoint.\nThe core clears this bit before setting any of the following interrupts on this endpoint:\n–SETUP phase done\n–Endpoint disabled\n–Transfer completed\nUSB on-the-go full-speed (OTG_FS)RM0008\n764/995 Doc ID 13902 Rev 9\nBit 30EPDIS: Endpoint disable\nThe application sets this bit to stop transmitting/receiving data on an endpoint, even before the\ntransfer for that endpoint is complete. The application must wait for the Endpoint disabled\ninterrupt before treating the endpoint as disabled. The core clears this bit before setting the\nEndpoint disabled interrupt. The application must set this bit only if Endpoint enable is already\nset for this endpoint.\nBit 29SODDFRM: Set odd frame\nApplies to isochronous IN and OUT endpoints only.\nWriting to this field sets the Even/Odd frame (EONUM) field to odd frame.\nBit 28SD0PID: Set DATA0 PID\nApplies to interrupt/bulk IN endpoints only.\nWriting to this field sets the endpoint data PID (DPID) field in this register to DATA0.\nSEVNFRM: Set even frame\nApplies to isochronous IN endpoints only.\nWriting to this field sets the Even/Odd frame (EONUM) field to even frame.\nBit 27SNAK: Set NAK\nA write to this bit sets the NAK bit for the endpoint.\nUsing this bit, the application can control the transmission of NAK handshakes on an endpoint.\nThe core can also set this bit for OUT endpoints on a Transfer completed interrupt, or after a\nSETUP is received on the endpoint.\nBit 26CNAK: Clear NAK\nA write to this bit clears the NAK bit for the endpoint.\nBits 25:22TXFNUM: TxFIFO number\nThese bits specify the FIFO number associated with this endpoint. Each active IN endpoint\nmust be programmed to a separate FIFO number.\nThis field is valid only for IN endpoints.\nBit 21STALL: STALL handshake\nApplies to non-control, non-isochronous IN endpoints only (access type is rw).\nThe application sets this bit to stall all tokens from the USB host to this endpoint. If a NAK\nbit, Global IN NAK, or Global OUT NAK is set along with this bit, the STALL bit takes priority.\nOnly the application can clear this bit, never the core.\nApplies to control endpoints only (access type is rs).\nThe application can only set this bit, and the core clears it, when a SETUP token is received\nfor this endpoint. If a NAK bit, Global IN NAK, or Global OUT NAK is set along with this bit,\nthe STALL bit takes priority. Irrespective of this bit’s setting, the core always responds to\nSETUP data packets with an ACK handshake.\nBit 20Reserved\nBits 19:18EPTYP: Endpoint type\nThis is the transfer type supported by this logical endpoint.\n00: Control\n01: Isochronous\n10: Bulk\n11: Interrupt\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9765/995\nBit 17NAKSTS: NAK status\nIt indicates the following:\n0: The core is transmitting non-NAK handshakes based on the FIFO status.\n1: The core is transmitting NAK handshakes on this endpoint.\nWhen either the application or the core sets this bit:\nFor non-isochronous IN endpoints: The core stops transmitting any data on an IN endpoint,\neven if there are data available in the TxFIFO.\nFor isochronous IN endpoints: The core sends out a zero-length data packet, even if there\nare data available in the TxFIFO.\nIrrespective of this bit’s setting, the core always responds to SETUP data packets with an ACK\nBit 16EONUM: Even/odd frame\nApplies to isochronous IN endpoints only.\nIndicates the frame number in which the core transmits/receives isochronous data for this\nendpoint. The application must program the even/odd frame number in which it intends to\ntransmit/receive isochronous data for this endpoint using the SEVNFRM and SODDFRM\nfields in this register.\n0: Even frame\n1: Odd frame\nDPID: Endpoint data PID\nApplies to interrupt/bulk IN endpoints only.\nContains the PID of the packet to be received or transmitted on this endpoint. The\napplication must program the PID of the first packet to be received or transmitted on this\nendpoint, after the endpoint is activated. The application uses the SD0PID register field to\nprogram either DATA0 or DATA1 PID.\n0: DATA0\n1: DATA1\nBit 15USBAEP: USB active endpoint\nIndicates whether this endpoint is active in the current configuration and interface. The core\nclears this bit for all endpoints (other than EP 0) after detecting a USB reset. After receiving\nthe SetConfiguration and SetInterface commands, the application must program endpoint\nregisters accordingly and set this bit.\nBits 14:11Reserved\nBits 10:0MPSIZ: Maximum packet size\nThe application must program this field with the maximum packet size for the current logical\nendpoint. This value is in bytes.\nUSB on-the-go full-speed (OTG_FS)RM0008\n766/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 766,
    "end_page": 767,
    "page_range": "766-767",
    "section": "",
    "full_name": "OTG_FS device control OUT endpoint 0 control register",
    "short_name": "",
    "address_offset": "0xB00",
    "reset_value": "0x0000 8000",
    "content": "This section describes the device control OUT endpoint 0 control register. Nonzero control\nendpoints use registers for endpoints 1–15.\nBit 31EPENA: Endpoint enable\nThe application sets this bit to start transmitting data on endpoint 0.\nThe core clears this bit before setting any of the following interrupts on this endpoint:\n–SETUP phase done\n–Endpoint disabled\n–Transfer completed\nBit 30EPDIS: Endpoint disable\nThe application cannot disable control OUT endpoint 0.\nBits 29:28Reserved\nBit 27SNAK: Set NAK\nA write to this bit sets the NAK bit for the endpoint.\nUsing this bit, the application can control the transmission of NAK handshakes on an endpoint.\nThe core can also set this bit on a Transfer completed interrupt, or after a SETUP is received\non the endpoint.\nBit 26CNAK: Clear NAK\nA write to this bit clears the NAK bit for the endpoint.\nBits 25:22Reserved\nBit 21STALL: STALL handshake\nThe application can only set this bit, and the core clears it, when a SETUP token is received\nfor this endpoint. If a NAK bit or Global OUT NAK is set along with this bit, the STALL bit takes\npriority. Irrespective of this bit’s setting, the core always responds to SETUP data packets with\nan ACK handshake.\nBit 20SNPM: Snoop mode\nThis bit configures the endpoint to Snoop mode. In Snoop mode, the core does not check the\ncorrectness of OUT packets before transferring them to application memory.\nBits 19:18EPTYP: Endpoint type\nHardcoded to 2’b00 for control.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9767/995"
  },
  {
    "start_page": 770,
    "end_page": 771,
    "page_range": "770-771",
    "section": "",
    "full_name": "OTG_FS device endpoint-x interrupt register (OTG_FS_DIEPINTx) (x=0..3,",
    "short_name": "",
    "address_offset": "0x908",
    "reset_value": "0x0000 0080",
    "content": "where x=Endpoint_number)\nThis register indicates the status of an endpoint with respect to USB- and AHB-related\nevents. It is shown in Figure268. The application must read this register when the IN\nendpoints interrupt bit of the Core interrupt register (IEPINT in OTG_FS_GINTSTS) is set.\nBefore the application can read this register, it must first read the Device all endpoints\ninterrupt (OTG_FS_DAINT) register to get the exact endpoint number for the Device\nendpoint-x interrupt register. The application must clear the appropriate bit in this register to\nclear the corresponding bits in the OTG_FS_DAINT and OTG_FS_GINTSTS registers.\nBits 31:8Reserved\nBit 7TXFE: Transmit FIFO empty\nThis interrupt is asserted when the TxFIFO for this endpoint is either half or completely empty.\nThe half or completely empty status is determined by the TxFIFO Empty Level bit in the Core\nAHB Configuration register (TXFELVL bit in OTG_FS_GAHBCFG).\nBit 6INEPNE: IN endpoint NAK effective\nThis bit can be cleared when the application clears the IN endpoint NAK by writing to the\nCNAK bit in OTG_FS_DIEPCTLx.\nThis interrupt indicates that the core has sampled the NAK bit set (either by the application or\nby the core). The interrupt indicates that the IN endpoint NAK bit set by the application has\ntaken effect in the core.\nThis interrupt does not guarantee that a NAK handshake is sent on the USB. A STALL bit\ntakes priority over a NAK bit.\nBit 5Reserved\nBit 4ITTXFE: IN token received when TxFIFO is empty\nApplies to non-periodic IN endpoints only.\nIndicates that an IN token was received when the associated TxFIFO (periodic/non-periodic)\nwas empty. This interrupt is asserted on the endpoint for which the IN token was received.\nBit 3TOC: Timeout condition\nApplies only to Control IN endpoints.\nIndicates that the core has detected a timeout condition on the USB for the last IN token on\nthis endpoint.\nBit 2Reserved.\nBit 1EPDISD: Endpoint disabled interrupt\nThis bit indicates that the endpoint is disabled per the application’s request.\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9771/995"
  },
  {
    "start_page": 771,
    "end_page": 772,
    "page_range": "771-772",
    "section": "",
    "full_name": "OTG_FS device endpoint-x interrupt register (OTG_FS_DOEPINTx) (x=0..3,",
    "short_name": "",
    "address_offset": "0xB08",
    "reset_value": "0x0000 0080",
    "content": "where x=Endpoint_number)\nThis register indicates the status of an endpoint with respect to USB- and AHB-related\nevents. It is shown in Figure268. The application must read this register when the OUT\nEndpoints Interrupt bit of the Core interrupt register (OEPINT bit in OTG_FS_GINTSTS) is\nset. Before the application can read this register, it must first read the Device all endpoints\ninterrupt (OTG_FS_DAINT) register to get the exact endpoint number for the Device\nEndpoint-x interrupt register. The application must clear the appropriate bit in this register to\nclear the corresponding bits in the OTG_FS_DAINT and OTG_FS_GINTSTS registers.\nBit 0XFRC: Transfer completed interrupt\nThis field indicates that the programmed transfer is complete on the AHB as well as on the\nUSB, for this endpoint.\nBits 31:7Reserved\nBit 6B2BSTUP: Back-to-back SETUP packets received\nApplies to Control OUT endpoints only.\nThis bit indicates that the core has received more than three back-to-back SETUP packets for\nthis particular endpoint.\nBit 5Reserved\nBit 4OTEPDIS: OUT token received when endpoint disabled\nApplies only to control OUT endpoints.\nIndicates that an OUT token was received when the endpoint was not yet enabled. This\ninterrupt is asserted on the endpoint for which the OUT token was received.\nBit 3STUP: SETUP phase done\nApplies to control OUT endpoints only.\nIndicates that the SETUP phase for the control endpoint is complete and no more back-to-\nback SETUP packets were received for the current control transfer. On this interrupt, the\napplication can decode the received SETUP data packet.\nBit 2Reserved\nBit 1EPDISD: Endpoint disabled interrupt\nThis bit indicates that the endpoint is disabled per the application’s request.\nBit 0XFRC: Transfer completed interrupt\nThis field indicates that the programmed transfer is complete on the AHB as well as on the\nUSB, for this endpoint.\nUSB on-the-go full-speed (OTG_FS)RM0008\n772/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 772,
    "end_page": 773,
    "page_range": "772-773",
    "section": "",
    "full_name": "OTG_FS device IN endpoint 0 transfer size register (OTG_FS_DIEPTSIZ0)",
    "short_name": "OTG_FS_DIEPTSIZ0",
    "address_offset": "0x910",
    "reset_value": "0x0000 0000",
    "content": "The application must modify this register before enabling endpoint 0. Once endpoint 0 is\nenabled using the endpoint enable bit in the device control endpoint 0 control registers\n(EPENA in OTG_FS_DIEPCTL0), the core modifies this register. The application can only\nread this register once the core has cleared the Endpoint enable bit.\nNonzero endpoints use the registers for endpoints 1–15.\nBits 31:21Reserved\nBits 20:19PKTCNT: Packet count\nIndicates the total number of USB packets that constitute the Transfer Size amount of data for\nendpoint 0.\nThis field is decremented every time a packet (maximum size or short packet) is read from the\nBits 18:7Reserved\nBits 6:0XFRSIZ: Transfer size\nIndicates the transfer size in bytes for endpoint 0. The core interrupts the application only after\nit has exhausted the transfer size amount of data. The transfer size can be set to the maximum\npacket size of the endpoint, to be interrupted at the end of each packet.\nThe core decrements this field every time a packet from the external memory is written to the\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9773/995"
  },
  {
    "start_page": 773,
    "end_page": 774,
    "page_range": "773-774",
    "section": "",
    "full_name": "OTG_FS device OUT endpoint 0 transfer size register (OTG_FS_DOEPTSIZ0)",
    "short_name": "OTG_FS_DOEPTSIZ0",
    "address_offset": "0xB10",
    "reset_value": "0x0000 0000",
    "content": "The application must modify this register before enabling endpoint 0. Once endpoint 0 is\nenabled using the Endpoint enable bit in the Device control endpoint 0 control registers\n(EPENA bit in OTG_FS_DOEPCTL0), the core modifies this register. The application can\nonly read this register once the core has cleared the Endpoint enable bit.\nNonzero endpoints use the registers for endpoints 1–15.\nBit 31Reserved\nBits 30:29STUPCNT: SETUP packet count\nThis field specifies the number of back-to-back SETUP data packets the endpoint can receive.\n01: 1 packet\n10: 2 packets\n11: 3 packets\nBits 28:20Reserved\nBit 19PKTCNT: Packet count\nThis field is decremented to zero after a packet is written into the RxFIFO.\nBits 18:7Reserved\nBits 6:0XFRSIZ: Transfer size\nIndicates the transfer size in bytes for endpoint 0. The core interrupts the application only after\nit has exhausted the transfer size amount of data. The transfer size can be set to the maximum\npacket size of the endpoint, to be interrupted at the end of each packet.\nThe core decrements this field every time a packet is read from the RxFIFO and written to the\nexternal memory.\nUSB on-the-go full-speed (OTG_FS)RM0008\n774/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 774,
    "end_page": 775,
    "page_range": "774-775",
    "section": "",
    "full_name": "OTG_FS device endpoint-x transfer size register (OTG_FS_DIEPTSIZx)",
    "short_name": "",
    "address_offset": "0x910",
    "reset_value": "0x0000 0000",
    "content": "(x=1..3, where x = Endpoint_number)\nThe application must modify this register before enabling the endpoint. Once the endpoint is\nenabled using the Endpoint enable bit in the Device endpoint-x control registers (EPENA bit\nin OTG_FS_DIEPCTLx), the core modifies this register. The application can only read this\nregister once the core has cleared the Endpoint enable bit.\nBit 31Reserved\nBits 30:29MCNT: Multi count\nFor periodic IN endpoints, this field indicates the number of packets that must be transmitted\nper frame on the USB. The core uses this field to calculate the data PID for isochronous IN\n01: 1 packet\n10: 2 packets\n11: 3 packets\nBit 28:19PKTCNT: Packet count\nIndicates the total number of USB packets that constitute the Transfer Size amount of data for\nthis endpoint.\nThis field is decremented every time a packet (maximum size or short packet) is read from the\nBits 18:0XFRSIZ: Transfer size\nThis field contains the transfer size in bytes for the current endpoint. The core only interrupts\nthe application after it has exhausted the transfer size amount of data. The transfer size can be\nset to the maximum packet size of the endpoint, to be interrupted at the end of each packet.\nThe core decrements this field every time a packet from the external memory is written to the\nRM0008USB on-the-go full-speed (OTG_FS)\nDoc ID 13902 Rev 9775/995"
  },
  {
    "start_page": 775,
    "end_page": 776,
    "page_range": "775-776",
    "section": "",
    "full_name": "OTG_FS device endpoint-x transfer size register (OTG_FS_DOEPTSIZx)",
    "short_name": "",
    "address_offset": "0xB10",
    "reset_value": "0x0000 0000",
    "content": "(x=1..3, where x=Endpoint_number)\nThe application must modify this register before enabling the endpoint. Once the endpoint is\nenabled using Endpoint Enable bit of the Device endpoint-x control registers (EPENA bit in\nOTG_FS_DOEPCTLx), the core modifies this register. The application can only read this\nregister once the core has cleared the Endpoint enable bit.\n15:0INEPTFSAV: IN endpoint TxFIFO space avail ()\nIndicates the amount of free space available in the Endpoint TxFIFO.\nValues are in terms of 32-bit words:\n0x0: Endpoint TxFIFO is full\n0x1: 1 word available\n0x2: 2 words available\n0xn: n words available (where 0 < n < 512)\n0x200: 512 words available\nOthers: Reserved\nBit 31Reserved\nBits 30:29RXDPID: Received data PID\nApplies to isochronous OUT endpoints only.\nThis is the data PID received in the last packet for this endpoint.\n00: DATA0\n01: DATA2\n10: DATA1\n11: MDATA\nUSB on-the-go full-speed (OTG_FS)RM0008\n776/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 776,
    "end_page": 776,
    "page_range": "776",
    "section": "26.14.5",
    "full_name": "OTG_FS power and clock gating control register",
    "short_name": "",
    "address_offset": "0xE00",
    "reset_value": "0x0000 0000",
    "content": "This register is available in Host and Device modes."
  },
  {
    "start_page": 906,
    "end_page": 909,
    "page_range": "906-909",
    "section": "",
    "full_name": "Ethernet MAC configuration register (ETH_MACCR)",
    "short_name": "ETH_MACCR",
    "address_offset": "0x0000",
    "reset_value": "0x0000 8000",
    "content": "The MAC configuration register is the operation mode register of the MAC. It establishes\nreceive and transmit operating modes.\nBits 31:24Reserved\nBit 23WD: Watchdog disable\nWhen this bit is set, the MAC disables the watchdog timer on the receiver, and can receive\nframes of up to 16 384 bytes.\nWhen this bit is reset, the MAC allows no more than 2 048 bytes of the frame being received\nand cuts off any bytes received after that.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9907/995\nBit 22JD: Jabber disable\nWhen this bit is set, the MAC disables the jabber timer on the transmitter, and can transfer\nframes of up to 16 384 bytes.\nWhen this bit is reset, the MAC cuts off the transmitter if the application sends out more than\n2048 bytes of data during transmission.\nBits 21:20Reserved\nBits 19:17IFG: Interframe gap\nThese bits control the minimum interframe gap between frames during transmission.\n000: 96 bit times\n001: 88 bit times\n010: 80 bit times\n111: 40 bit times\nNote:In Half-duplex mode, the minimum IFG can be configured for 64 bit times (IFG = 100)\nonly. Lower values are not considered.\nBit 16CSD: Carrier sense disable\nWhen set high, this bit makes the MAC transmitter ignore the MII CRS signal during frame\ntransmission in Half-duplex mode. No error is generated due to Loss of Carrier or No Carrier\nduring such transmission.\nWhen this bit is low, the MAC transmitter generates such errors due to Carrier Sense and even\naborts the transmissions.\nBit 15Reserved\nBit 14FES: Fast Ethernet speed\nIndicates the speed in Fast Ethernet (MII) mode:\n0: 10 Mbit/s\n1: 100 Mbit/s\nBit 13ROD: Receive own disable\nWhen this bit is set, the MAC disables the reception of frames in Half-duplex mode.\nWhen this bit is reset, the MAC receives all packets that are given by the PHY while\nThis bit is not applicable if the MAC is operating in Full-duplex mode.\nBit 12LM: Loopback mode\nWhen this bit is set, the MAC operates in loopback mode at the MII. The MII receive clock\ninput (RX_CLK) is required for the loopback to work properly, as the transmit clock is not\nlooped-back internally.\nBit 11DM: Duplex mode\nWhen this bit is set, the MAC operates in a Full-duplex mode where it can transmit and receive\nBit 10IPCO: IPv4 checksum offload\nWhen set, this bit enables IPv4 checksum checking for received frame payloads'\nTCP/UDP/ICMP headers. When this bit is reset, the checksum offload function in the receiver\nis disabled and the corresponding PCE and IP HCE status bits (see Table193 on page862)\nare always cleared.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n908/995 Doc ID 13902 Rev 9\nBit 9RD: Retry disable\nWhen this bit is set, the MAC attempts only 1 transmission. When a collision occurs on the\nMII, the MAC ignores the current frame transmission and reports a Frame Abort with\nexcessive collision error in the transmit frame status.\nWhen this bit is reset, the MAC attempts retries based on the settings of BL.\nNote:This bit is applicable only in the Half-duplex mode.\nBit 8Reserved\nBit 7APCS: Automatic pad/CRC stripping\nWhen this bit is set, the MAC strips the Pad/FCS field on incoming frames only if the length’s\nfield value is less than or equal to 1 500 bytes. All received frames with length field greater\nthan or equal to 1 501 bytes are passed on to the application without stripping the Pad/FCS\nWhen this bit is reset, the MAC passes all incoming frames unmodified.\nBits 6:5BL: Back-off limit\nThe Back-off limit determines the random integer number (r) of slot time delays (4096 bit\ntimes for 1000 Mbit/s and 512 bit times for 10/100 Mbit/s) the MAC waits before rescheduling a\ntransmission attempt during retries after a collision.\nNote:This bit is applicable only to Half-duplex mode.\n00: k = min (n, 10)\n01: k = min (n, 8)\n10: k = min (n, 4)\n11: k = min (n, 1),\nwhere n = retransmission attempt. The random integer r takes the value in the range 0  r < 2\nBit 4DC: Deferral check\nWhen this bit is set, the deferral check function is enabled in the MAC. The MAC issues a\nFrame Abort status, along with the excessive deferral error bit set in the transmit frame status\nwhen the transmit state machine is deferred for more than 24 288 bit times in 10/100-Mbit/s\nmode. Deferral begins when the transmitter is ready to transmit, but is prevented because of\nan active CRS (carrier sense) signal on the MII. Defer time is not cumulative. If the transmitter\ndefers for 10000 bit times, then transmits, collides, backs off, and then has to defer again after\ncompletion of back-off, the deferral timer resets to 0 and restarts.\nWhen this bit is reset, the deferral check function is disabled and the MAC defers until the CRS\nsignal goes inactive. This bit is applicable only in Half-duplex mode.\nBit 3TE: Transmitter enable\nWhen this bit is set, the transmit state machine of the MAC is enabled for transmission on the\nMII. When this bit is reset, the MAC transmit state machine is disabled after the completion of\nthe transmission of the current frame, and does not transmit any further frames.\nBit 2RE: Receiver enable\nWhen this bit is set, the receiver state machine of the MAC is enabled for receiving frames\nfrom the MII. When this bit is reset, the MAC receive state machine is disabled after the\ncompletion of the reception of the current frame, and will not receive any further frames from\nthe MII.\nBits 1:0Reserved\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9909/995"
  },
  {
    "start_page": 909,
    "end_page": 910,
    "page_range": "909-910",
    "section": "",
    "full_name": "Ethernet MAC frame filter register (ETH_MACFFR)",
    "short_name": "ETH_MACFFR",
    "address_offset": "0x0004",
    "reset_value": "0x0000 0000",
    "content": "The MAC frame filter register contains the filter controls for receiving frames. Some of the\ncontrols from this register go to the address check block of the MAC, which performs the first\nlevel of address filtering. The second level of filtering is performed on the incoming frame,\nbased on other controls such as pass bad frames and pass control frames.\nBit 31RA: Receive all\nWhen this bit is set, the MAC receiver passes all received frames on to the application,\nirrespective of whether they have passed the address filter. The result of the SA/DA filtering is\nupdated (pass or fail) in the corresponding bits in the receive status word. When this bit is\nreset, the MAC receiver passes on to the application only those frames that have passed the\nSA/DA address filter.\nBits 30:11Reserved\nBit 10HPF: Hash or perfect filter\nWhen set, this bit configures the address filter to pass a frame if it matches either the perfect\nfiltering or the hash filtering as set by the HM or HU bit. When low and if the HU/HM bit is set,\nthe frame is passed only if it matches the Hash filter.\nBit 9SAF: Source address filter\nThe MAC core compares the SA field of the received frames with the values programmed in\nthe enabled SA registers. If the comparison matches, then the SAMatch bit in the RxStatus\nword is set high. When this bit is set high and the SA filter fails, the MAC drops the frame.\nWhen this bit is reset, the MAC core forwards the received frame to the application. It also\nforwards the updated SA Match bit in RxStatus depending on the SA address comparison.\nBit 8SAIF: Source address inverse filtering\nWhen this bit is set, the address check block operates in inverse filtering mode for the SA\naddress comparison. The frames whose SA matches the SA registers are marked as failing\nthe SA address filter.\nWhen this bit is reset, frames whose SA does not match the SA registers are marked as failing\nthe SA address filter.\nBits 7:6PCF: Pass control frames\nThese bits control the forwarding of all control frames (including unicast and multicast PAUSE\nframes). Note that the processing of PAUSE control frames depends only on RFCE in Flow\nControl Register[2].\n00 or 01: MAC prevents all control frames from reaching the application\n10: MAC forwards all control frames to application even if they fail the address filter\n11: MAC forwards control frames that pass the address filter.\nBit 5BFD: Broadcast frames disable\nWhen this bit is set, the address filters filter all incoming broadcast frames.\nWhen this bit is reset, the address filters pass all received broadcast frames.\nBit 4PAM: Pass all multicast\nWhen set, this bit indicates that all received frames with a multicast destination address (first\nbit in the destination address field is '1') are passed.\nWhen reset, filtering of multicast frame depends on the HM bit.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n910/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 910,
    "end_page": 911,
    "page_range": "910-911",
    "section": "",
    "full_name": "Ethernet MAC hash table high register (ETH_MACHTHR)",
    "short_name": "ETH_MACHTHR",
    "address_offset": "0x0008",
    "reset_value": "0x0000 0000",
    "content": "The 64-bit Hash table is used for group address filtering. For hash filtering, the contents of\nthe destination address in the incoming frame are passed through the CRC logic, and the\nupper 6 bits in the CRC register are used to index the contents of the Hash table. The most\nsignificant bit determines the register to be used (hash table high/hash table low), and the\nother 5 bits determine which bit within the register. A hash value of 0b00000 selects bit 0 in\nthe selected register, and a value of 0b11111 selects bit 31 in the selected register.\nFor example, if the DA of the incoming frame is received as 0x1F52419CB6AF (0x1F is the\nfirst byte received on the MII interface), then the internally calculated 6-bit Hash value is\n0x2C and the HTH register bit[12] is checked for filtering. If the DA of the incoming frame is\nreceived as 0xA00A98000045, then the calculated 6-bit Hash value is 0x07 and the HTL\nregister bit[7] is checked for filtering.\nIf the corresponding bit value in the register is 1, the frame is accepted. Otherwise, it is\nrejected. If the PAM (pass all multicast) bit is set in the ETH_MACFFR register, then all\nmulticast frames are accepted regardless of the multicast hash values.\nThe Hash table high register contains the higher 32 bits of the multicast Hash table.\nBit 3DAIF: Destination address inverse filtering\nWhen this bit is set, the address check block operates in inverse filtering mode for the DA\naddress comparison for both unicast and multicast frames.\nWhen reset, normal filtering of frames is performed.\nBit 2HM: Hash multicast\nWhen set, MAC performs destination address filtering of received multicast frames according\nto the hash table.\nWhen reset, the MAC performs a perfect destination address filtering for multicast frames, that\nis, it compares the DA field with the values programmed in DA registers.\nBit 1HU: Hash unicast\nWhen set, MAC performs destination address filtering of unicast frames according to the hash\nWhen reset, the MAC performs a perfect destination address filtering for unicast frames, that\nis, it compares the DA field with the values programmed in DA registers.\nBit 0PM: Promiscuous mode\nWhen this bit is set, the address filters pass all incoming frames regardless of their destination\nor source address. The SA/DA filter fails status bits in the receive status word are always\ncleared when PM is set.\nBits 31:0HTH: Hash table high\nThis field contains the upper 32 bits of Hash table.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9911/995"
  },
  {
    "start_page": 911,
    "end_page": 911,
    "page_range": "911",
    "section": "",
    "full_name": "Ethernet MAC hash table low register (ETH_MACHTLR)",
    "short_name": "ETH_MACHTLR",
    "address_offset": "0x000C",
    "reset_value": "0x0000 0000",
    "content": "The Hash table low register contains the lower 32 bits of the multi-cast Hash table."
  },
  {
    "start_page": 911,
    "end_page": 912,
    "page_range": "911-912",
    "section": "",
    "full_name": "Ethernet MAC MII address register (ETH_MACMIIAR)",
    "short_name": "ETH_MACMIIAR",
    "address_offset": "0x0010",
    "reset_value": "0x0000 0000",
    "content": "The MII address register controls the management cycles to the external PHY through the\nmanagement interface.\nBits 31:0HTL: Hash table low\nThis field contains the lower 32 bits of the Hash table.\nBits 31:16Reserved\nBits 15:11PA: PHY address\nThis field tells which of the 32 possible PHY devices are being accessed.\nBits 10:6MR: MII register\nThese bits select the desired MII register in the selected PHY device.\nBit 5Reserved\nBits 4:2CR: Clock range\nThe CR clock range selection determines the HCLK frequency and is used to decide the\nfrequency of the MDC clock:\nSelection HCLK MDC Clock\n000 60-72 MHz HCLK/42\n001 Reserved -\n010 20-35 MHz HCLK/16\n011 35-60 MHz HCLK/26\n100, 101, 110, 111 Reserved -\nBit 1MW: MII write\nWhen set, this bit tells the PHY that this will be a Write operation using the MII Data register. If\nthis bit is not set, this will be a Read operation, placing the data in the MII Data register.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n912/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 912,
    "end_page": 912,
    "page_range": "912",
    "section": "",
    "full_name": "Ethernet MAC MII data register (ETH_MACMIIDR)",
    "short_name": "ETH_MACMIIDR",
    "address_offset": "0x0014",
    "reset_value": "0x0000 0000",
    "content": "The MAC MII Data register stores write data to be written to the PHY register located at the\naddress specified in ETH_MACMIIAR. ETH_MACMIIDR also stores read data from the PHY\nregister located at the address specified by ETH_MACMIIAR."
  },
  {
    "start_page": 912,
    "end_page": 914,
    "page_range": "912-914",
    "section": "",
    "full_name": "Ethernet MAC flow control register (ETH_MACFCR)",
    "short_name": "ETH_MACFCR",
    "address_offset": "0x0018",
    "reset_value": "0x0000 0000",
    "content": "The Flow control register controls the generation and reception of the control (Pause\nCommand) frames by the MAC. A write to a register with the Busy bit set to '1' causes the\nMAC to generate a pause control frame. The fields of the control frame are selected as\nspecified in the 802.3x specification, and the Pause Time value from this register is used in\nthe Pause Time field of the control frame. The Busy bit remains set until the control frame is\ntransferred onto the cable. The Host must make sure that the Busy bit is cleared before\nwriting to the register.\nBit 0MB: MII busy\nThis bit should read a logic 0 before writing to ETH_MACMIIAR and ETH_MACMIIDR. This bit\nmust also be reset to 0 during a Write to ETH_MACMIIAR. During a PHY register access, this\nbit is set to 0b1 by the application to indicate that a read or write access is in progress.\nETH_MACMIIDR (MII Data) should be kept valid until this bit is cleared by the MAC during a\nPHY Write operation. The ETH_MACMIIDR is invalid until this bit is cleared by the MAC during\na PHY Read operation. The ETH_MACMIIAR (MII Address) should not be written to until this bit\nis cleared.\nBits 31:16Reserved\nBits 15:0MD: MII data\nThis contains the 16-bit data value read from the PHY after a Management Read operation, or\nthe 16-bit data value to be written to the PHY before a Management Write operation.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9913/995\nBits 31:16PT: Pause time\nThis field holds the value to be used in the Pause Time field in the transmit control frame. If the\nPause Time bits is configured to be double-synchronized to the MII clock domain, then\nconsecutive write operations to this register should be performed only after at least 4 clock\ncycles in the destination clock domain.\nBits 15:8Reserved\nBit 7ZQPD: Zero-quanta pause disable\nWhen set, this bit disables the automatic generation of Zero-quanta pause control frames on\nthe deassertion of the flow-control signal from the FIFO layer.\nWhen this bit is reset, normal operation with automatic Zero-quanta pause control frame\ngeneration is enabled.\nBit 6Reserved\nBits 5:4PLT: Pause low threshold\nThis field configures the threshold of the Pause timer at which the Pause frame is\nautomatically retransmitted. The threshold values should always be less than the Pause Time\nconfigured in bits[31:16]. For example, if PT=100H (256 slot-times), and PLT=01, then a\nsecond PAUSE frame is automatically transmitted if initiated at 228 (256–28) slot-times after\nthe first PAUSE frame is transmitted.\nSelection Threshold\n00 Pause time minus 4 slot times\n01 Pause time minus 28 slot times\n10 Pause time minus 144 slot times\n11 Pause time minus 256 slot times\nSlot time is defined as time taken to transmit 512 bits (64 bytes) on the MII interface.\nBit 3UPFD: Unicast pause frame detect\nWhen this bit is set, the MAC detects the Pause frames with the station’s unicast address\nspecified in the ETH_MACA0HR and ETH_MACA0LR registers, in addition to detecting Pause\nframes with the unique multicast address.\nWhen this bit is reset, the MAC detects only a Pause frame with the unique multicast address\nspecified in the 802.3x standard.\nBit 2RFCE: Receive flow control enable\nWhen this bit is set, the MAC decodes the received Pause frame and disables its transmitter\nfor a specified (Pause Time) time.\nWhen this bit is reset, the decode function of the Pause frame is disabled.\nBit 1TFCE: Transmit flow control enable\nIn Full-duplex mode, when this bit is set, the MAC enables the flow control operation to\ntransmit Pause frames. When this bit is reset, the flow control operation in the MAC is\ndisabled, and the MAC does not transmit any Pause frames.\nIn Half-duplex mode, when this bit is set, the MAC enables the back-pressure operation. When\nthis bit is reset, the back pressure feature is disabled.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n914/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 914,
    "end_page": 915,
    "page_range": "914-915",
    "section": "",
    "full_name": "Ethernet MAC VLAN tag register (ETH_MACVLANTR)",
    "short_name": "ETH_MACVLANTR",
    "address_offset": "0x001C",
    "reset_value": "0x0000 0000",
    "content": "The VLAN tag register contains the IEEE 802.1Q VLAN Tag to identify the VLAN frames.\nThe MAC compares the 13\nand 14\nbytes of the receiving frame (Length/Type) with\n0x8100, and the following 2 bytes are compared with the VLAN tag; if a match occurs, the\nreceived VLAN bit in the receive frame status is set. The legal length of the frame is\nincreased from 1518 bytes to 1522 bytes.\nBit 0FCB/BPA: Flow control busy/back pressure activate\nThis bit initiates a Pause Control frame in Full-duplex mode and activates the back pressure\nfunction in Half-duplex mode if TFCE bit is set.\nIn Full-duplex mode, this bit should be read as 0 before writing to the Flow control register. To\ninitiate a Pause control frame, the Application must set this bit to 1. During a transfer of the\nControl frame, this bit continues to be set to signify that a frame transmission is in progress.\nAfter completion of the Pause control frame transmission, the MAC resets this bit to 0. The\nFlow control register should not be written to until this bit is cleared.\nIn Half-duplex mode, when this bit is set (and TFCE is set), back pressure is asserted by the\nMAC core. During back pressure, when the MAC receives a new frame, the transmitter starts\nsending a JAM pattern resulting in a collision. When the MAC is configured to Full-duplex\nmode, the BPA is automatically disabled.\nBits 31:17Reserved\nBit 16VLANTC: 12-bit VLAN tag comparison\nWhen this bit is set, a 12-bit VLAN identifier, rather than the complete 16-bit VLAN tag, is used\nfor comparison and filtering. Bits[11:0] of the VLAN tag are compared with the corresponding\nfield in the received VLAN-tagged frame.\nWhen this bit is reset, all 16 bits of the received VLAN frame’s fifteenth and sixteenth bytes are\nused for comparison.\nBits 15:0VLANTI: VLAN tag identifier (for receive frames)\nThis contains the 802.1Q VLAN tag to identify VLAN frames, and is compared to the fifteenth\nand sixteenth bytes of the frames being received for VLAN frames. Bits[15:13] are the user\npriority, Bit[12] is the canonical format indicator (CFI) and bits[11:0] are the VLAN tag’s VLAN\nidentifier (VID) field. When the VLANTC bit is set, only the VID (bits[11:0]) is used for\nIf VLANTI (VLANTI[11:0] if VLANTC is set) is all zeros, the MAC does not check the fifteenth\nand sixteenth bytes for VLAN tag comparison, and declares all frames with a Type field value\nof 0x8100 as VLAN frames.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9915/995"
  },
  {
    "start_page": 915,
    "end_page": 915,
    "page_range": "915",
    "section": "",
    "full_name": "Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)",
    "short_name": "ETH_MACRWUFFR",
    "address_offset": "0x0028",
    "reset_value": "0x0000 0000",
    "content": "This is the address through which the remote wakeup frame filter registers are written/read\nby the application. The Wakeup frame filter register is actually a pointer to eight (not\ntransparent) such wakeup frame filter registers. Eight sequential write operations to this\naddress with the offset (0x0028) will write all wakeup frame filter registers. Eight sequential\nread operations from this address with the offset (0x0028) will read all wakeup frame filter\nregisters. This register contains the higher 16 bits of the 7\nMAC address. Refer to Remote\nwakeup frame filter register section for additional information.\nFigure 319.Ethernet MAC remote wakeup frame filter register (ETH_MACRWUFFR)"
  },
  {
    "start_page": 915,
    "end_page": 916,
    "page_range": "915-916",
    "section": "",
    "full_name": "Ethernet MAC PMT control and status register (ETH_MACPMTCSR)",
    "short_name": "ETH_MACPMTCSR",
    "address_offset": "0x002C",
    "reset_value": "0x0000 0000",
    "content": "The ETH_MACPMTCSR programs the request wakeup events and monitors the wakeup\nFilter 0 Byte Mask\nFilter 1 Byte Mask\nFilter 2 Byte Mask\nFilter 3 Byte Mask\nFilter 3\nFilter 2\nFilter 1\nFilter 0\nFilter 3 OffsetFilter 2 OffsetFilter 1 OffsetFilter 0 Offset\nFilter 1 CRC - 16Filter 0 CRC - 16\nFilter 3 CRC - 16Filter 2 CRC - 16\nWakeup frame filter reg0\nWakeup frame filter reg1\nWakeup frame filter reg2\nWakeup frame filter reg3\nWakeup frame filter reg4\nWakeup frame filter reg5\nWakeup frame filter reg6\nWakeup frame filter reg7\nBit 31WFFRPR: Wakeup frame filter register pointer reset\nWhen set, it resets the Remote wakeup frame filter register pointer to 0b000. It is automatically\ncleared after 1 clock cycle.\nBits 30:10Reserved\nBit 9GU: Global unicast\nWhen set, it enables any unicast packet filtered by the MAC (DAF) address recognition to be a\nwakeup frame.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n916/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 916,
    "end_page": 917,
    "page_range": "916-917",
    "section": "",
    "full_name": "Ethernet MAC interrupt status register (ETH_MACSR)",
    "short_name": "ETH_MACSR",
    "address_offset": "0x0038",
    "reset_value": "0x0000 0000",
    "content": "The ETH_MACSR register contents identify the events in the MAC that can generate an\nBits 8:7Reserved\nBit 6WFR: Wakeup frame received\nWhen set, this bit indicates the power management event was generated due to reception of a\nwakeup frame. This bit is cleared by a read into this register.\nBit 5MPR: Magic packet received\nWhen set, this bit indicates the power management event was generated by the reception of a\nMagic Packet. This bit is cleared by a read into this register.\nBits 4:3Reserved\nBit 2WFE: Wakeup frame enable\nWhen set, this bit enables the generation of a power management event due to wakeup frame\nBit 1MPE: Magic Packet enable\nWhen set, this bit enables the generation of a power management event due to Magic Packet\nBit 0PD: Power down\nWhen this bit is set, all received frames will be dropped. This bit is cleared automatically when\na magic packet or wakeup frame is received, and Power-down mode is disabled. Frames\nreceived after this bit is cleared are forwarded to the application. This bit must only be set\nwhen either the Magic Packet Enable or Wakeup Frame Enable bit is set high.\nBits 15:10Reserved\nBit 9TSTS: Time stamp trigger status\nThis bit is set high when the system time value equals or exceeds the value specified in the\nTarget time high and low registers. This bit is cleared when this register is read.\nBits 8:7Reserved\nBit 6MMCTS: MMC transmit status\nThis bit is set high whenever an interrupt is generated in the ETH_MMCTIR Register. This bit is\ncleared when all the bits in this interrupt register (ETH_MMCTIR) are cleared.\nBit 5MMCRS: MMC receive status\nThis bit is set high whenever an interrupt is generated in the ETH_MMCRIR register. This bit is\ncleared when all the bits in this interrupt register (ETH_MMCRIR) are cleared.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9917/995"
  },
  {
    "start_page": 917,
    "end_page": 917,
    "page_range": "917",
    "section": "",
    "full_name": "Ethernet MAC interrupt mask register (ETH_MACIMR)",
    "short_name": "ETH_MACIMR",
    "address_offset": "0x003C",
    "reset_value": "0x0000 0000",
    "content": "The ETH_MACIMR register bits make it possible to mask the interrupt signal due to the\ncorresponding event in the ETH_MACSR register."
  },
  {
    "start_page": 917,
    "end_page": 918,
    "page_range": "917-918",
    "section": "",
    "full_name": "Ethernet MAC address 0 high register (ETH_MACA0HR)",
    "short_name": "ETH_MACA0HR",
    "address_offset": "0x0040",
    "reset_value": "0x0010 FFFF",
    "content": "The MAC address 0 high register holds the upper 16 bits of the 6-byte first MAC address of\nthe station. Note that the first DA byte that is received on the MII interface corresponds to\nthe LS Byte (bits [7:0]) of the MAC address low register. For example, if 0x112233445566\nis received (0x11 is the first byte) on the MII as the destination address, then the MAC\naddress 0 register [47:0] is compared with 0x66554433 2211.\nBit 4MMCS: MMC status\nThis bit is set high whenever any of bits 6:5 is set high. It is cleared only when both bits are low.\nBit 3PMTS: PMT status\nThis bit is set whenever a Magic packet or Wake-on-LAN frame is received in Power-down\nmode (See bits 5 and 6 in the ETH_MACPMTCSR register Ethernet MAC PMT control and\nstatus register (ETH_MACPMTCSR) on page915). This bit is cleared when both bits[6:5], of\nthis last register, are cleared due to a read operation to the ETH_MACPMTCSR register.\nBits 2:0Reserved\nBits 15:10Reserved\nBit 9TSTIM: Time stamp trigger interrupt mask\nWhen set, this bit disables the time stamp interrupt generation.\nBits 8:4Reserved\nBit 3PMTIM: PMT interrupt mask\nWhen set, this bit disables the assertion of the interrupt signal due to the setting of the PMT\nStatus bit in ETH_MACSR.\nBits 2:0Reserved\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n918/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 918,
    "end_page": 918,
    "page_range": "918",
    "section": "",
    "full_name": "Ethernet MAC address 0 low register (ETH_MACA0LR)",
    "short_name": "ETH_MACA0LR",
    "address_offset": "0x0044",
    "reset_value": "0xFFFF FFFF",
    "content": "The MAC address 0 low register holds the lower 32 bits of the 6-byte first MAC address of\nthe station."
  },
  {
    "start_page": 918,
    "end_page": 919,
    "page_range": "918-919",
    "section": "",
    "full_name": "Ethernet MAC address 1 high register (ETH_MACA1HR)",
    "short_name": "ETH_MACA1HR",
    "address_offset": "0x0048",
    "reset_value": "0x0000 FFFF",
    "content": "The MAC address 1 high register holds the upper 16 bits of the 6-byte second MAC address\nof the station.\nBit 31MO: Always 1.\nBits 30:16Reserved\nBits 15:0MACA0H: MAC address0 high [47:32]\nThis field contains the upper 16 bits (47:32) of the 6-byte MAC address0. This is used by the\nMAC for filtering for received frames and for inserting the MAC address in the transmit flow\ncontrol (Pause) frames.\nBits 31:0MACA0L: MAC address0 low [31:0]\nThis field contains the lower 32 bits of the 6-byte MAC address0. This is used by the MAC for\nfiltering for received frames and for inserting the MAC address in the transmit flow control\n(Pause) frames.\nBit 31AE: Address enable\nWhen this bit is set, the address filters use the MAC address1 for perfect filtering. When this bit\nis cleared, the address filters ignore the address for filtering.\nBit 30SA: Source address\nWhen this bit is set, the MAC address1[47:0] is used for comparison with the SA fields of the\nreceived frame.\nWhen this bit is cleared, the MAC address1[47:0] is used for comparison with the DA fields of\nthe received frame.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9919/995"
  },
  {
    "start_page": 919,
    "end_page": 919,
    "page_range": "919",
    "section": "",
    "full_name": "Ethernet MAC address1 low register (ETH_MACA1LR)",
    "short_name": "ETH_MACA1LR",
    "address_offset": "0x004C",
    "reset_value": "0xFFFF FFFF",
    "content": "The MAC address 1 low register holds the lower 32 bits of the 6-byte second MAC address\nof the station."
  },
  {
    "start_page": 919,
    "end_page": 920,
    "page_range": "919-920",
    "section": "",
    "full_name": "Ethernet MAC address 2 high register (ETH_MACA2HR)",
    "short_name": "ETH_MACA2HR",
    "address_offset": "0x0050",
    "reset_value": "0x0000 FFFF",
    "content": "The MAC address 2 high register holds the upper 16 bits of the 6-byte second MAC address\nof the station.\nBits 29:24MBC: Mask byte control\nThese bits are mask control bits for comparison of each of the MAC address1 bytes. When\nthey are set high, the MAC core does not compare the corresponding byte of received DA/SA\nwith the contents of the MAC address1 registers. Each bit controls the masking of the bytes as\n–Bit 29: ETH_MACA1HR [15:8]\n–Bit 28: ETH_MACA1HR [7:0]\n–Bit 27: ETH_MACA1LR [31:24]\n–Bit 24: ETH_MACA1LR [7:0]\nBits 23:16Reserved\nBits 15:0MACA1H: MAC address1 high [47:32]\nThis field contains the upper 16 bits (47:32) of the 6-byte second MAC address.\nBits 31:0MACA1L: MAC address1 low [31:0]\nThis field contains the lower 32 bits of the 6-byte MAC address1. The content of this field is\nundefined until loaded by the application after the initialization process.\nBit 31\nAE: Address enable\nWhen this bit is set, the address filters use the MAC address2 for perfect filtering. When reset,\nthe address filters ignore the address for filtering.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n920/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 920,
    "end_page": 920,
    "page_range": "920",
    "section": "",
    "full_name": "Ethernet MAC address 2 low register (ETH_MACA2LR)",
    "short_name": "ETH_MACA2LR",
    "address_offset": "0x0054",
    "reset_value": "0xFFFF FFFF",
    "content": "The MAC address 2 low register holds the lower 32 bits of the 6-byte second MAC address\nof the station."
  },
  {
    "start_page": 920,
    "end_page": 921,
    "page_range": "920-921",
    "section": "",
    "full_name": "Ethernet MAC address 3 high register (ETH_MACA3HR)",
    "short_name": "ETH_MACA3HR",
    "address_offset": "0x0058",
    "reset_value": "0x0000 FFFF",
    "content": "The MAC address 3 high register holds the upper 16 bits of the 6-byte second MAC address\nof the station.\nBit 30\nSA: Source address\nWhen this bit is set, the MAC address 2 [47:0] is used for comparison with the SA fields of the\nreceived frame.\nWhen this bit is reset, the MAC address 2 [47:0] is used for comparison with the DA fields of\nthe received frame.\nBits 29:24\nMBC: Mask byte control\nThese bits are mask control bits for comparison of each of the MAC address2 bytes. When set\nhigh, the MAC core does not compare the corresponding byte of received DA/SA with the\ncontents of the MAC address 2 registers. Each bit controls the masking of the bytes as follows:\n–Bit 29: ETH_MACA2HR [15:8]\n–Bit 28: ETH_MACA2HR [7:0]\n–Bit 27: ETH_MACA2LR [31:24]\n–Bit 24: ETH_MACA2LR [7:0]\nBits 23:16Reserved\nBits 15:0\nMACA2H: MAC address2 high [47:32]\nThis field contains the upper 16 bits (47:32) of the 6-byte MAC address2.\nBits 31:0\nMACA2L: MAC address2 low [31:0]\nThis field contains the lower 32 bits of the 6-byte second MAC address2. The content of this\nfield is undefined until loaded by the application after the initialization process.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9921/995"
  },
  {
    "start_page": 921,
    "end_page": 922,
    "page_range": "921-922",
    "section": "",
    "full_name": "Ethernet MAC address 3 low register (ETH_MACA3LR)",
    "short_name": "ETH_MACA3LR",
    "address_offset": "0x005C",
    "reset_value": "0xFFFF FFFF",
    "content": "The MAC address 3 low register holds the lower 32 bits of the 6-byte second MAC address\nof the station.\nBit 31AE: Address enable\nWhen this bit is set, the address filters use the MAC address3 for perfect filtering. When this bit\nis cleared, the address filters ignore the address for filtering.\nBit 30SA: Source address\nWhen this bit is set, the MAC address 3 [47:0] is used for comparison with the SA fields of the\nreceived frame.\nWhen this bit is cleared, the MAC address 3[47:0] is used for comparison with the DA fields of\nthe received frame.\nBits 29:24MBC: Mask byte control\nThese bits are mask control bits for comparison of each of the MAC address3 bytes. When\nthese bits are set high, the MAC core does not compare the corresponding byte of received\nDA/SA with the contents of the MAC address 3 registers. Each bit controls the masking of the\nbytes as follows:\n–Bit 29: ETH_MACA3HR [15:8]\n–Bit 28: ETH_MACA3HR [7:0]\n–Bit 27: ETH_MACA3LR [31:24]\n–Bit 24: ETH_MACA3LR [7:0]\nBits 23:16Reserved\nBits 15:0MACA3H: MAC address3 high [47:32]\nThis field contains the upper 16 bits (47:32) of the 6-byte MAC address3.\nBits 31:0MACA3L: MAC address3 low [31:0]\nThis field contains the lower 32 bits of the 6-byte second MAC address3. The content of this\nfield is undefined until loaded by the application after the initialization process.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n922/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 922,
    "end_page": 922,
    "page_range": "922",
    "section": "",
    "full_name": "Ethernet MMC control register (ETH_MMCCR)",
    "short_name": "ETH_MMCCR",
    "address_offset": "0x0100",
    "reset_value": "0x0000 0000",
    "content": "The Ethernet MMC Control register establishes the operating mode of the management"
  },
  {
    "start_page": 922,
    "end_page": 923,
    "page_range": "922-923",
    "section": "",
    "full_name": "Ethernet MMC receive interrupt register (ETH_MMCRIR)",
    "short_name": "ETH_MMCRIR",
    "address_offset": "0x0104",
    "reset_value": "0x0000 0000",
    "content": "The Ethernet MMC receive interrupt register maintains the interrupts generated when\nreceive statistic counters reach half their maximum values. (MSB of the counter is set.) It is\na 32-bit wide register. An interrupt bit is cleared when the respective MMC counter that\ncaused the interrupt is read. The least significant byte lane (bits [7:0]) of the respective\ncounter must be read in order to clear the interrupt bit.\nBits 31:4Reserved\nBit 3MCF: MMC counter freeze\nWhen set, this bit freezes all the MMC counters to their current value. (None of the MMC\ncounters are updated due to any transmitted or received frame until this bit is cleared to 0. If\nany MMC counter is read with the Reset on Read bit set, then that counter is also cleared in\nthis mode.)\nBit 2ROR: Reset on read\nWhen this bit is set, the MMC counters is reset to zero after read (self-clearing after reset). The\ncounters are cleared when the least significant byte lane (bits [7:0]) is read.\nBit 1CSR: Counter stop rollover\nWhen this bit is set, the counter does not roll over to zero after it reaches the maximum value.\nBit 0CR: Counter reset\nWhen it is set, all counters are reset. This bit is cleared automatically after 1 clock cycle.\nBits 31:18Reserved\nBit 17RGUFS: Received Good Unicast Frames Status\nThis bit is set when the received, good unicast frames, counter reaches half the maximum\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9923/995"
  },
  {
    "start_page": 923,
    "end_page": 924,
    "page_range": "923-924",
    "section": "",
    "full_name": "Ethernet MMC transmit interrupt register (ETH_MMCTIR)",
    "short_name": "ETH_MMCTIR",
    "address_offset": "0x0108",
    "reset_value": "0x0000 0000",
    "content": "The Ethernet MMC transmit Interrupt register maintains the interrupts generated when\ntransmit statistic counters reach half their maximum values. (MSB of the counter is set.) It is\na 32-bit wide register. An interrupt bit is cleared when the respective MMC counter that\ncaused the interrupt is read. The least significant byte lane (bits [7:0]) of the respective\ncounter must be read in order to clear the interrupt bit.\nBits 16:7Reserved\nBit 6RFAES: Received frames alignment error status\nThis bit is set when the received frames, with alignment error, counter reaches half the\nmaximum value.\nBit 5RFCES: Received frames CRC error status\nThis bit is set when the received frames, with CRC error, counter reaches half the maximum\nBits 4:0Reserved\nBits 31:22Reserved\nBit 21TGFS: Transmitted good frames status\nThis bit is set when the transmitted, good frames, counter reaches half the maximum value.\nBits 20:16Reserved\nBit 15TGFMSCS: Transmitted good frames more single collision status\nThis bit is set when the transmitted, good frames after more than a single collision, counter\nreaches half the maximum value.\nBit 14TGFSCS: Transmitted good frames single collision status\nThis bit is set when the transmitted, good frames after a single collision, counter reaches half\nthe maximum value.\nBits 13:0Reserved\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n924/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 924,
    "end_page": 924,
    "page_range": "924",
    "section": "",
    "full_name": "Ethernet MMC receive interrupt mask register (ETH_MMCRIMR)",
    "short_name": "ETH_MMCRIMR",
    "address_offset": "0x010C",
    "reset_value": "0x0000 0000",
    "content": "The Ethernet MMC receive interrupt mask register maintains the masks for interrupts\ngenerated when the receive statistic counters reach half their maximum value. (MSB of the\ncounter is set.) It is a 32-bit wide register."
  },
  {
    "start_page": 924,
    "end_page": 925,
    "page_range": "924-925",
    "section": "",
    "full_name": "Ethernet MMC transmit interrupt mask register (ETH_MMCTIMR)",
    "short_name": "ETH_MMCTIMR",
    "address_offset": "0x0110",
    "reset_value": "0x0000 0000",
    "content": "The Ethernet MMC transmit interrupt mask register maintains the masks for interrupts\ngenerated when the transmit statistic counters reach half their maximum value. (MSB of the\ncounter is set). It is a 32-bit wide register.\nBits 31:18Reserved\nBit 17RGUFM: Received good unicast frames mask\nSetting this bit masks the interrupt when the received, good unicast frames, counter reaches\nhalf the maximum value.\nBits 16:7Reserved\nBit 6RFAEM: Received frames alignment error mask\nSetting this bit masks the interrupt when the received frames, with alignment error, counter\nreaches half the maximum value.\nBit 5RFCEM: Received frame CRC error mask\nSetting this bit masks the interrupt when the received frames, with CRC error, counter reaches\nhalf the maximum value.\nBits 4:0Reserved\nBits 31:22Reserved\nBit 21TGFM: Transmitted good frames mask\nSetting this bit masks the interrupt when the transmitted, good frames, counter reaches half\nthe maximum value.\nBits 20:16Reserved\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9925/995\nEthernet MMC transmitted good frames after a single collision counter"
  },
  {
    "start_page": 925,
    "end_page": 925,
    "page_range": "925",
    "section": "",
    "full_name": "register (ETH_MMCTGFSCCR)",
    "short_name": "ETH_MMCTGFSCCR",
    "address_offset": "0x014C",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of successfully transmitted frames after a single collision\nin Half-duplex mode.\nEthernet MMC transmitted good frames after more than a single collision"
  },
  {
    "start_page": 925,
    "end_page": 926,
    "page_range": "925-926",
    "section": "",
    "full_name": "counter register (ETH_MMCTGFMSCCR)",
    "short_name": "ETH_MMCTGFMSCCR",
    "address_offset": "0x0150",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of successfully transmitted frames after more than a\nsingle collision in Half-duplex mode.\nBit 15TGFMSCM: Transmitted good frames more single collision mask\nSetting this bit masks the interrupt when the transmitted good frames after more than a single\ncollision counter reaches half the maximum value.\nBit 14TGFSCM: Transmitted good frames single collision mask\nSetting this bit masks the interrupt when the transmitted good frames after a single collision\ncounter reaches half the maximum value.\nBits 13:0Reserved\nBits 31:0TGFSCC: Transmitted good frames single collision counter\nTransmitted good frames after a single collision counter.\nBits 31:0TGFMSCC: Transmitted good frames more single collision counter\nTransmitted good frames after more than a single collision counter\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n926/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 926,
    "end_page": 926,
    "page_range": "926",
    "section": "",
    "full_name": "Ethernet MMC transmitted good frames counter register (ETH_MMCTGFCR)",
    "short_name": "ETH_MMCTGFCR",
    "address_offset": "0x0168",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of good frames transmitted."
  },
  {
    "start_page": 926,
    "end_page": 926,
    "page_range": "926",
    "section": "",
    "full_name": "Ethernet MMC received frames with CRC error counter register",
    "short_name": "",
    "address_offset": "0x0194",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of frames received with CRC error."
  },
  {
    "start_page": 926,
    "end_page": 927,
    "page_range": "926-927",
    "section": "",
    "full_name": "Ethernet MMC received frames with alignment error counter register",
    "short_name": "",
    "address_offset": "0x0198",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of frames received with alignment (dribble) error.\nBits 31:0TGFC: Transmitted good frames counter\nBits 31:0RFCEC: Received frames CRC error counter\nReceived frames with CRC error counter\nBits 31:0RFAEC: Received frames alignment error counter\nReceived frames with alignment error counter\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9927/995"
  },
  {
    "start_page": 927,
    "end_page": 927,
    "page_range": "927",
    "section": "",
    "full_name": "MMC received good unicast frames counter register (ETH_MMCRGUFCR)",
    "short_name": "ETH_MMCRGUFCR",
    "address_offset": "0x01C4",
    "reset_value": "0x0000 0000",
    "content": "This register contains the number of good unicast frames received."
  },
  {
    "start_page": 927,
    "end_page": 928,
    "page_range": "927-928",
    "section": "",
    "full_name": "Ethernet PTP time stamp control register (ETH_PTPTSCR)",
    "short_name": "ETH_PTPTSCR",
    "address_offset": "0x0700",
    "reset_value": "0x0000 0000",
    "content": "This register controls the time stamp generation and update logic.\nBits 31:0RGUFC: Received good unicast frames counter\nBits 31:5Reserved\nBit 5TSARU: Time stamp addend register update\nWhen this bit is set, the Time stamp addend register’s contents are updated to the PTP block\nfor fine correction. This bit is cleared when the update is completed. This register bit must be\nread as zero before you can set it.\nBit 4TSITE: Time stamp interrupt trigger enable\nWhen this bit is set, a time stamp interrupt is generated when the system time becomes greater\nthan the value written in Target Time register. When the Time Stamp Trigger interrupt is\ngenerated, this bit is cleared.\nBit 3TSSTU: Time stamp system time update\nWhen this bit is set, the system time is updated (added to or subtracted from) with the value\nspecified in the Time stamp high update and Time stamp low update registers. Both the\nTSSTU and TSSTI bits must be read as zero before you can set this bit. Once the update is\ncompleted in hardware, this bit is cleared.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n928/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 928,
    "end_page": 929,
    "page_range": "928-929",
    "section": "",
    "full_name": "Ethernet PTP subsecond increment register (ETH_PTPSSIR)",
    "short_name": "ETH_PTPSSIR",
    "address_offset": "0x0704",
    "reset_value": "0x0000 0000",
    "content": "This register contains the 8-bit value by which the subsecond register is incremented. In\nCoarse update mode (TSFCU bit in ETH_PTPTSCR), the value in this register is added to\nthe system time every clock cycle of HCLK. In Fine update mode, the value in this register is\nadded to the system time whenever the accumulator gets an overflow.\nBit 2TSSTI: Time stamp system time initialize\nWhen this bit is set, the system time is initialized (overwritten) with the value specified in the\nTime stamp high update and Time stamp low update registers. This bit must be read as zero\nbefore you can set it. When initialization is complete, this bit is cleared.\nBit 1TSFCU: Time stamp fine or coarse update\nWhen set, this bit indicates that the system time stamp is to be updated using the Fine Update\nmethod. When cleared, it indicates the system time stamp is to be updated using the Coarse\nBit 0TSE: Time stamp enable\nWhen this bit is set, time stamping is enabled for transmit and receive frames. When this bit is\ncleared, the time stamp function is suspended and time stamps are not added for transmit and\nreceive frames. Because the maintained system time is suspended, you must always initialize\nthe time stamp feature (system time) after setting this bit high.\nBits 31:8Reserved\nBits 7:0STSSI: System time subsecond increment\nThe value programmed in this register is added to the contents of the subsecond value of the\nsystem time in every update.\nFor example, to achieve 20 ns accuracy, the value is: 20/ 0.467= ~43 (or 0x2A).\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9929/995"
  },
  {
    "start_page": 929,
    "end_page": 929,
    "page_range": "929",
    "section": "",
    "full_name": "Ethernet PTP time stamp high register (ETH_PTPTSHR)",
    "short_name": "ETH_PTPTSHR",
    "address_offset": "0x0708",
    "reset_value": "0x0000 0000",
    "content": "This register contains the most significant (higher) 32 time bits. This read-only register\ncontains the seconds system time value. The Time stamp high register, along with Time\nstamp low register, indicates the current value of the system time maintained by the MAC.\nThough it is updated on a continuous basis."
  },
  {
    "start_page": 929,
    "end_page": 930,
    "page_range": "929-930",
    "section": "",
    "full_name": "Ethernet PTP time stamp low register (ETH_PTPTSLR)",
    "short_name": "ETH_PTPTSLR",
    "address_offset": "0x070C",
    "reset_value": "0x0000 0000",
    "content": "This register contains the least significant (lower) 32 time bits. This read-only register\ncontains the subsecond system time value.\nBits 31:0STS: System time second\nThe value in this field indicates the current value in seconds of the System Time maintained by\nthe core.\nBit 31STPNS: System time positive or negative sign\nThis bit indicates a positive or negative time value. When set, the bit indicates that time\nrepresentation is negative. When cleared, it indicates that time representation is positive.\nBecause the system time should always be positive, this bit is normally zero.\nBits 30:0STSS: System time subseconds\nThe value in this field has the subsecond time representation, with 0.46 ns accuracy.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n930/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 930,
    "end_page": 930,
    "page_range": "930",
    "section": "",
    "full_name": "Ethernet PTP time stamp high update register (ETH_PTPTSHUR)",
    "short_name": "ETH_PTPTSHUR",
    "address_offset": "0x0710",
    "reset_value": "0x0000 0000",
    "content": "This register contains the most significant (higher) 32 bits of the time to be written to, added\nto, or subtracted from the System Time value. The Time stamp high update register, along\nwith the Time stamp update low register, initializes or updates the system time maintained\nby the MAC. You have to write both of these registers before setting the TSSTI or TSSTU\nbits in the Time stamp control register."
  },
  {
    "start_page": 930,
    "end_page": 931,
    "page_range": "930-931",
    "section": "",
    "full_name": "Ethernet PTP time stamp low update register (ETH_PTPTSLUR)",
    "short_name": "ETH_PTPTSLUR",
    "address_offset": "0x0714",
    "reset_value": "0x0000 0000",
    "content": "This register contains the least significant (lower) 32 bits of the time to be written to, added\nto, or subtracted from the System Time value.\nBits 31:0TSUS: Time stamp update second\nThe value in this field indicates the time, in seconds, to be initialized or added to the system\nBit 31TSUPNS: Time stamp update positive or negative sign\nThis bit indicates positive or negative time value. When set, the bit indicates that time\nrepresentation is negative. When cleared, it indicates that time representation is positive.\nWhen TSSTI is set (system time initialization) this bit should be zero. If this bit is set when\nTSSTU is set, the value in the Time stamp update registers is subtracted from the system\ntime. Otherwise it is added to the system time.\nBits 30:0TSUSS: Time stamp update subseconds\nThe value in this field indicates the subsecond time to be initialized or added to the system\ntime. This value has an accuracy of 0.46ns (in other words, a value of 0x0000_0001 is\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9931/995"
  },
  {
    "start_page": 931,
    "end_page": 931,
    "page_range": "931",
    "section": "",
    "full_name": "Ethernet PTP time stamp addend register (ETH_PTPTSAR)",
    "short_name": "ETH_PTPTSAR",
    "address_offset": "0x0718",
    "reset_value": "0x0000 0000",
    "content": "This register is used by the software to readjust the clock frequency linearly to match the\nmaster clock frequency. This register value is used only when the system time is configured\nfor Fine update mode (TSFCU bit in ETH_PTPTSCR). This register content is added to a\n32-bit accumulator in every clock cycle and the system time is updated whenever the\naccumulator overflows."
  },
  {
    "start_page": 931,
    "end_page": 932,
    "page_range": "931-932",
    "section": "",
    "full_name": "Ethernet PTP target time high register (ETH_PTPTTHR)",
    "short_name": "ETH_PTPTTHR",
    "address_offset": "0x071C",
    "reset_value": "0x0000 0000",
    "content": "This register contains the higher 32 bits of time to be compared with the system time for\ninterrupt event generation. The Target time high register, along with Target time low register,\nis used to schedule an interrupt event (TSARU bit in ETH_PTPTSCR) when the system time\nexceeds the value programmed in these registers.\nBits 31:0TSA: Time stamp addend\nThis register indicates the 32-bit time value to be added to the Accumulator register to achieve\ntime synchronization.\nBits 31:0TTSH: Target time stamp high\nThis register stores the time in seconds. When the time stamp value matches or exceeds both\nTarget time stamp registers, the MAC, if enabled, generates an interrupt.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n932/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 932,
    "end_page": 932,
    "page_range": "932",
    "section": "",
    "full_name": "Ethernet PTP target time low register (ETH_PTPTTLR)",
    "short_name": "ETH_PTPTTLR",
    "address_offset": "0x0720",
    "reset_value": "0x0000 0000",
    "content": "This register contains the lower 32 bits of time to be compared with the system time for\ninterrupt event generation."
  },
  {
    "start_page": 932,
    "end_page": 934,
    "page_range": "932-934",
    "section": "",
    "full_name": "Ethernet DMA bus mode register (ETH_DMABMR)",
    "short_name": "ETH_DMABMR",
    "address_offset": "0x1000",
    "reset_value": "0x0000 2101",
    "content": "The bus mode register establishes the bus operating modes for the DMA.\nBits 31:0TTSL: Target time stamp low\nThis register stores the time in (signed) nanoseconds. When the value of the time stamp\nmatches or exceeds both Target time stamp registers, the MAC, if enabled, generates an\nBits 31:26Reserved\nBit 25AAB: Address-aligned beats\nWhen this bit is set high and the FB bit equals 1, the AHB interface generates all bursts aligned\nto the start address LS bits. If the FB bit equals 0, the first burst (accessing the data buffer’s\nstart address) is not aligned, but subsequent bursts are aligned to the address.\nBit 24FPM: 4xPBL mode\nWhen set high, this bit multiplies the PBL value programmed (bits [22:17] and bits [13:8]) four\ntimes. Thus the DMA transfers data in a maximum of 4, 8, 16, 32, 64 and 128 beats depending\non the PBL value.\nBit 23USP: Use separate PBL\nWhen set high, it configures the RxDMA to use the value configured in bits [22:17] as PBL\nwhile the PBL value in bits [13:8] is applicable to TxDMA operations only. When this bit is\ncleared, the PBL value in bits [13:8] is applicable for both DMA engines.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9933/995\nBits 22:17RDP: Rx DMA PBL\nThese bits indicate the maximum number of beats to be transferred in one RxDMA transaction.\nThis is the maximum value that is used in a single block read/write operation. The RxDMA\nalways attempts to burst as specified in RDP each time it starts a burst transfer on the host\nbus. RDP can be programmed with permissible values of 1, 2, 4, 8, 16, and 32. Any other value\nresults in undefined behavior.\nThese bits are valid and applicable only when USP is set high.\nBit 16FB: Fixed burst\nThis bit controls whether the AHB Master interface performs fixed burst transfers or not. When\nset, the AHB uses only SINGLE, INCR4, INCR8 or INCR16 during start of normal burst\ntransfers. When reset, the AHB uses SINGLE and INCR burst transfer operations.\nBits 15:14RTPR: Rx Tx priority ratio\nRxDMA requests are given priority over TxDMA requests in the following ratio:\n00: 1:1\n01: 2:1\n10: 3:1\n11: 4:1\nThis is valid only when the DA bit is cleared.\nBits 13:8PBL: Programmable burst length\nThese bits indicate the maximum number of beats to be transferred in one DMA transaction.\nThis is the maximum value that is used in a single block read/write operation. The DMA always\nattempts to burst as specified in PBL each time it starts a burst transfer on the host bus. PBL\ncan be programmed with permissible values of 1, 2, 4, 8, 16, and 32. Any other value results in\nundefined behavior. When USP is set, this PBL value is applicable for TxDMA transactions\nThe PBL values have the following limitations:\n–The maximum number of beats (PBL) possible is limited by the size of the Tx FIFO and Rx\n–The FIFO has a constraint that the maximum beat supported is half the depth of the FIFO.\n–If the PBL is common for both transmit and receive DMA, the minimum RxFIFO and Tx\nFIFO depths must be considered.\n–Do not program out-of-range PBL values, because the system may not behave properly.\nBit 7Reserved\nBits 6:2DSL: Descriptor skip length\nThis bit specifies the number of Word/Dword/Lword (depending on 32/64/128-bit bus) to skip\nbetween two unchained descriptors. The address skipping starts from the end of current\ndescriptor to the start of next descriptor. When DSL value equals zero, the descriptor table is\ntaken as contiguous by the DMA, in Ring mode.\nBit 1DA: DMA Arbitration\n0: Round-robin with Rx:Tx priority given in bits [15:14]\n1: Rx has priority over Tx\nBit 0SR: Software reset\nWhen this bit is set, the MAC DMA controller resets all MAC Subsystem internal registers and\nlogic. It is cleared automatically after the reset operation has completed in all of the core clock\ndomains. Read a 0 value in this bit before re-programming any register of the core.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n934/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 934,
    "end_page": 934,
    "page_range": "934",
    "section": "",
    "full_name": "Ethernet DMA transmit poll demand register (ETH_DMATPDR)",
    "short_name": "ETH_DMATPDR",
    "address_offset": "0x1004",
    "reset_value": "0x0000 0000",
    "content": "This register is used by the application to instruct the DMA to poll the transmit descriptor list.\nThe transmit poll demand register enables the Transmit DMA to check whether or not the\ncurrent descriptor is owned by DMA. The Transmit Poll Demand command is given to wake\nup the TxDMA if it is in Suspend mode. The TxDMA can go into Suspend mode due to an\nunderflow error in a transmitted frame or due to the unavailability of descriptors owned by\ntransmit DMA. You can issue this command anytime and the TxDMA resets it once it starts\nre-fetching the current descriptor from host memory."
  },
  {
    "start_page": 934,
    "end_page": 935,
    "page_range": "934-935",
    "section": "",
    "full_name": "EHERNET DMA receive poll demand register (ETH_DMARPDR)",
    "short_name": "ETH_DMARPDR",
    "address_offset": "0x1008",
    "reset_value": "0x0000 0000",
    "content": "This register is used by the application to instruct the DMA to poll the receive descriptor list.\nThe Receive poll demand register enables the receive DMA to check for new descriptors.\nThis command is given to wake up the RxDMA from Suspend state. The RxDMA can go into\nSuspend state only due to the unavailability of descriptors owned by it.\nBits 31:0TPD: Transmit poll demand\nWhen these bits are written with any value, the DMA reads the current descriptor pointed to by\nthe ETH_DMACHTDR register. If that descriptor is not available (owned by Host), transmission\nreturns to the Suspend state and ETH_DMASR register bit 2 is asserted. If the descriptor is\navailable, transmission resumes.\nBits 31:0RPD: Receive poll demand\nWhen these bits are written with any value, the DMA reads the current descriptor pointed to by\nthe ETH_DMACHRDR register. If that descriptor is not available (owned by Host), reception\nreturns to the Suspended state and ETH_DMASR register bit 7 is not asserted. If the\ndescriptor is available, the Receive DMA returns to active state.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9935/995"
  },
  {
    "start_page": 935,
    "end_page": 935,
    "page_range": "935",
    "section": "",
    "full_name": "Ethernet DMA receive descriptor list address register (ETH_DMARDLAR)",
    "short_name": "ETH_DMARDLAR",
    "address_offset": "0x100C",
    "reset_value": "0x0000 0000",
    "content": "The Receive descriptor list address register points to the start of the receive descriptor list.\nThe descriptor lists reside in the STM32F107xx's physical memory space and must be\nword-aligned. The DMA internally converts it to bus-width aligned address by making the\ncorresponding LS bits low. Writing to the ETH_DMARDLAR register is permitted only when\nreception is stopped. When stopped, the ETH_DMARDLAR register must be written to\nbefore the receive Start command is given."
  },
  {
    "start_page": 935,
    "end_page": 935,
    "page_range": "935",
    "section": "",
    "full_name": "Ethernet DMA transmit descriptor list address register (ETH_DMATDLAR)",
    "short_name": "ETH_DMATDLAR",
    "address_offset": "0x1010",
    "reset_value": "0x0000 0000",
    "content": "The Transmit descriptor list address register points to the start of the transmit descriptor list.\nThe descriptor lists reside in the STM32F107xx's physical memory space and must be\nword-aligned. The DMA internally converts it to bus-width-aligned address by taking the\ncorresponding LSB to low. Writing to the ETH_DMATDLAR register is permitted only when\ntransmission has stopped. Once transmission has stopped, the ETH_DMATDLAR register\ncan be written before the transmission Start command is given."
  },
  {
    "start_page": 935,
    "end_page": 939,
    "page_range": "935-939",
    "section": "",
    "full_name": "Ethernet DMA status register (ETH_DMASR)",
    "short_name": "ETH_DMASR",
    "address_offset": "0x1014",
    "reset_value": "0x0000 0000",
    "content": "The Status register contains all the status bits that the DMA reports to the application. The\nETH_DMASR register is usually read by the software driver during an interrupt service\nroutine or polling. Most of the fields in this register cause the host to be interrupted. The\nETH_DMASR register bits are not cleared when read. Writing 1 to (unreserved) bits in\nBits 31:0SRL: Start of receive list\nThis field contains the base address of the first descriptor in the receive descriptor list. The\nLSB bits [1/2/3:0] for 32/64/128-bit bus width) are internally ignored and taken as all-zero by\nthe DMA. Hence these LSB bits are read only.\nBits 31:0STL: Start of transmit list\nThis field contains the base address of the first descriptor in the transmit descriptor list. The\nLSB bits [1/2/3:0] for 32/64/128-bit bus width) are internally ignored and taken as all-zero by\nthe DMA. Hence these LSB bits are read-only.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n936/995 Doc ID 13902 Rev 9\nETH_DMASR register[16:0] clears them and writing 0 has no effect. Each field (bits [16:0])\ncan be masked by masking the appropriate bit in the ETH_DMAIER register.\nBits 31:30Reserved\nBit 29TSTS: Time stamp trigger status\nThis bit indicates an interrupt event in the MAC core's Time stamp generator block. The\nsoftware must read the MAC core’s status register, clearing its source (bit 9), to reset this bit to\n0. When this bit is high an interrupt is generated if enabled.\nBit 28PMTS: PMT status\nThis bit indicates an event in the MAC core’s PMT. The software must read the corresponding\nregisters in the MAC core to get the exact cause of interrupt and clear its source to reset this bit\nto 0. The interrupt is generated when this bit is high if enabled.\nBit 27MMCS: MMC status\nThis bit reflects an event in the MMC of the MAC core. The software must read the\ncorresponding registers in the MAC core to get the exact cause of interrupt and clear the\nsource of interrupt to make this bit as 0. The interrupt is generated when this bit is high if\nBit 26Reserved\nBits 25:23EBS: Error bits status\nThese bits indicate the type of error that caused a bus error (error response on the AHB\ninterface). Valid only with the fatal bus error bit (ETH_DMASR register [13]) set. This field does\nnot generate an interrupt.\nBit 231 Error during data transfer by TxDMA\n0 Error during data transfer by RxDMA\nBit 24 1 Error during read transfer\n0 Error during write transfer\nBit 25 1 Error during descriptor access\n0 Error during data buffer access\nBits 22:20TPS: Transmit process state\nThese bits indicate the Transmit DMA FSM state. This field does not generate an interrupt.\n000: Stopped; Reset or Stop Transmit Command issued\n001: Running; Fetching transmit transfer descriptor\n010: Running; Waiting for status\n011: Running; Reading Data from host memory buffer and queuing it to transmit buffer (Tx\n100, 101: Reserved for future use\n110: Suspended; Transmit descriptor unavailable or transmit buffer underflow\n111: Running; Closing transmit descriptor\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9937/995\nBits 19:17RPS: Receive process state\nThese bits indicate the Receive DMA FSM state. This field does not generate an interrupt.\n000: Stopped: Reset or Stop Receive Command issued\n001: Running: Fetching receive transfer descriptor\n010: Reserved for future use\n011: Running: Waiting for receive packet\n100: Suspended: Receive descriptor unavailable\n101: Running: Closing receive descriptor\n110: Reserved for future use\n111: Running: Transferring the receive packet data from receive buffer to host memory\nBit 16NIS: Normal interrupt summary\nThe normal interrupt summary bit value is the logical OR of the following when the\ncorresponding interrupt bits are enabled in the ETH_DMAIER register:\n–ETH_DMASR [0]: Transmit interrupt\n–ETH_DMASR [2]: Transmit buffer unavailable\n–ETH_DMASR [6]: Receive interrupt\n–ETH_DMASR [14]: Early receive interrupt\nOnly unmasked bits affect the normal interrupt summary bit.\nThis is a sticky bit and it must be cleared (by writing a 1 to this bit) each time a corresponding\nbit that causes NIS to be set is cleared.\nBit 15AIS: Abnormal interrupt summary\nThe abnormal interrupt summary bit value is the logical OR of the following when the\ncorresponding interrupt bits are enabled in the ETH_DMAIER register:\n–ETH_DMASR [1]:Transmit process stopped\n–ETH_DMASR [3]:Transmit jabber timeout\n–ETH_DMASR [4]: Receive FIFO overflow\n–ETH_DMASR [5]: Transmit underflow\n–ETH_DMASR [7]: Receive buffer unavailable\n–ETH_DMASR [8]: Receive process stopped\n–ETH_DMASR [9]: Receive watchdog timeout\n–ETH_DMASR [10]: Early transmit interrupt\n–ETH_DMASR [13]: Fatal bus error\nOnly unmasked bits affect the abnormal interrupt summary bit.\nThis is a sticky bit and it must be cleared each time a corresponding bit that causes AIS to be\nset is cleared.\nBit 14ERS: Early receive status\nThis bit indicates that the DMA had filled the first data buffer of the packet. Receive Interrupt\nETH_DMASR [6] automatically clears this bit.\nBit 13FBES: Fatal bus error status\nThis bit indicates that a bus error occurred, as detailed in [25:23]. When this bit is set, the\ncorresponding DMA engine disables all its bus accesses.\nBits 12:11Reserved\nBit 10ETS: Early transmit status\nThis bit indicates that the frame to be transmitted was fully transferred to the Transmit FIFO.\nBit 9RWTS: Receive watchdog timeout status\nThis bit is asserted when a frame with a length greater than 2 048 bytes is received.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n938/995 Doc ID 13902 Rev 9\nBit 8RPSS: Receive process stopped status\nThis bit is asserted when the receive process enters the Stopped state.\nBit 7RBUS: Receive buffer unavailable status\nThis bit indicates that the next descriptor in the receive list is owned by the host and cannot be\nacquired by the DMA. Receive process is suspended. To resume processing receive\ndescriptors, the host should change the ownership of the descriptor and issue a Receive Poll\nDemand command. If no Receive Poll Demand is issued, receive process resumes when the\nnext recognized incoming frame is received. ETH_DMASR [7] is set only when the previous\nreceive descriptor was owned by the DMA.\nBit 6RS: Receive status\nThis bit indicates the completion of the frame reception. Specific frame status information has\nbeen posted in the descriptor. Reception remains in the Running state.\nBit 5TUS: Transmit underflow status\nThis bit indicates that the transmit buffer had an underflow during frame transmission.\nTransmission is suspended and an underflow error TDES0[1] is set.\nBit 4ROS: Receive overflow status\nThis bit indicates that the receive buffer had an overflow during frame reception. If the partial\nframe is transferred to the application, the overflow status is set in RDES0[11].\nBit 3TJTS: Transmit jabber timeout status\nThis bit indicates that the transmit jabber timer expired, meaning that the transmitter had been\nexcessively active. The transmission process is aborted and placed in the Stopped state. This\ncauses the transmit jabber timeout TDES0[14] flag to be asserted.\nBit 2TBUS: Transmit buffer unavailable status\nThis bit indicates that the next descriptor in the transmit list is owned by the host and cannot be\nacquired by the DMA. Transmission is suspended. Bits [22:20] explain the transmit process\nstate transitions. To resume processing transmit descriptors, the host should change the\nownership of the bit of the descriptor and then issue a Transmit Poll Demand command.\nBit 1TPSS: Transmit process stopped status\nThis bit is set when the transmission is stopped.\nBit 0TS: Transmit status\nThis bit indicates that frame transmission is finished and TDES1[31] is set in the first descriptor.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9939/995"
  },
  {
    "start_page": 939,
    "end_page": 942,
    "page_range": "939-942",
    "section": "",
    "full_name": "Ethernet DMA operation mode register (ETH_DMAOMR)",
    "short_name": "ETH_DMAOMR",
    "address_offset": "0x1018",
    "reset_value": "0x0000 0000",
    "content": "The operation mode register establishes the Transmit and Receive operating modes and\ncommands. The ETH_DMAOMR register should be the last CSR to be written as part of\nDMA initialization.\nBits 31:27Reserved\nBit 26DTCEFD: Dropping of TCP/IP checksum error frames disable\nWhen this bit is set, the core does not drop frames that only have errors detected by the\nreceive checksum offload engine. Such frames do not have any errors (including FCS error) in\nthe Ethernet frame received by the MAC but have errors in the encapsulated payload only.\nWhen this bit is cleared, all error frames are dropped if the FEF bit is reset.\nBit 25RSF: Receive store and forward\nWhen this bit is set, a frame is read from the Rx FIFO after the complete frame has been\nwritten to it, ignoring RTC bits. When this bit is cleared, the Rx FIFO operates in Cut-through\nmode, subject to the threshold specified by the RTC bits.\nBit 24DFRF: Disable flushing of received frames\nWhen this bit is set, the RxDMA does not flush any frames due to the unavailability of receive\ndescriptors/buffers as it does normally when this bit is cleared. (See Receive process\nsuspended on page897)\nBits 23:22Reserved\nBit 21TSF: Transmit store and forward\nWhen this bit is set, transmission starts when a full frame resides in the Transmit FIFO. When\nthis bit is set, the TTC values specified by the ETH_DMAOMR register bits [16:14] are ignored.\nWhen this bit is cleared, the TTC values specified by the ETH_DMAOMR register bits [16:14]\nare taken into account.\nThis bit should be changed only when transmission is stopped.\nBit 20FTF: Flush transmit FIFO\nWhen this bit is set, the transmit FIFO controller logic is reset to its default values and thus all\ndata in the Tx FIFO are lost/flushed. This bit is cleared internally when the flushing operation is\ncomplete. The Operation mode register should not be written to until this bit is cleared.\nBits 19:17Reserved\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n940/995 Doc ID 13902 Rev 9\nBits 16:14TTC: Transmit threshold control\nThese three bits control the threshold level of the Transmit FIFO. Transmission starts when the\nframe size within the Transmit FIFO is larger than the threshold. In addition, full frames with a\nlength less than the threshold are also transmitted. These bits are used only when the TSF bit\n(Bit 21) is cleared.\n000: 64\n001: 128\n010: 192\n011: 256\n100: 40\n101: 32\n110: 24\n111: 16\nBit 13ST: Start/stop transmission\nWhen this bit is set, transmission is placed in the Running state, and the DMA checks the\ntransmit list at the current position for a frame to be transmitted. Descriptor acquisition is\nattempted either from the current position in the list, which is the transmit list base address set\nby the ETH_DMATDLAR register, or from the position retained when transmission was\nstopped previously. If the current descriptor is not owned by the DMA, transmission enters the\nSuspended state and the transmit buffer unavailable bit (ETH_DMASR [2]) is set. The Start\nTransmission command is effective only when transmission is stopped. If the command is\nissued before setting the DMA ETH_DMATDLAR register, the DMA behavior is unpredictable.\nWhen this bit is cleared, the transmission process is placed in the Stopped state after\ncompleting the transmission of the current frame. The next descriptor position in the transmit\nlist is saved, and becomes the current position when transmission is restarted. The Stop\nTransmission command is effective only when the transmission of the current frame is\ncomplete or when the transmission is in the Suspended state.\nBits 12:8Reserved\nBit 7FEF: Forward error frames\nWhen this bit is set, all frames except runt error frames are forwarded to the DMA.\nWhen this bit is cleared, the Rx FIFO drops frames with error status (CRC error, collision error,\ngiant frame, watchdog timeout, overflow). However, if the frame’s start byte (write) pointer is\nalready transferred to the read controller side (in Threshold mode), then the frames are not\ndropped. The Rx FIFO drops the error frames if that frame's start byte is not transferred\n(output) on the ARI bus.\nBit 6FUGF: Forward undersized good frames\nWhen this bit is set, the Rx FIFO forwards undersized frames (frames with no error and length\nless than 64 bytes) including pad-bytes and CRC).\nWhen this bit is cleared, the Rx FIFO drops all frames of less than 64 bytes, unless such a\nframe has already been transferred due to lower value of receive threshold (e.g., RTC = 01).\nBit 5Reserved\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9941/995\nBits 4:3RTC: Receive threshold control\nThese two bits control the threshold level of the Receive FIFO. Transfer (request) to DMA\nstarts when the frame size within the Receive FIFO is larger than the threshold. In addition, full\nframes with a length less than the threshold are transferred automatically.\nNote:Note that value of 11 is not applicable if the configured Receive FIFO size is 128 bytes.\nNote:These bits are valid only when the RSF bit is zero, and are ignored when the RSF bit is\nset to 1.\n00: 64\n01: 32\n10: 96\n11: 128\nBit 2OSF: Operate on second frame\nWhen this bit is set, this bit instructs the DMA to process a second frame of Transmit data even\nbefore status for first frame is obtained.\nBit 1SR: Start/stop receive\nWhen this bit is set, the receive process is placed in the Running state. The DMA attempts to\nacquire the descriptor from the receive list and processes incoming frames. Descriptor\nacquisition is attempted from the current position in the list, which is the address set by the\nDMA ETH_DMARDLAR register or the position retained when the receive process was\npreviously stopped. If no descriptor is owned by the DMA, reception is suspended and the\nreceive buffer unavailable bit (ETH_DMASR [7]) is set. The Start Receive command is effective\nonly when reception has stopped. If the command was issued before setting the DMA\nETH_DMARDLAR register, the DMA behavior is unpredictable.\nWhen this bit is cleared, RxDMA operation is stopped after the transfer of the current frame.\nThe next descriptor position in the receive list is saved and becomes the current position when\nthe receive process is restarted. The Stop Receive command is effective only when the\nReceive process is in either the Running (waiting for receive packet) or the Suspended state.\nBit 0Reserved\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n942/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 942,
    "end_page": 944,
    "page_range": "942-944",
    "section": "",
    "full_name": "Ethernet DMA interrupt enable register (ETH_DMAIER)",
    "short_name": "ETH_DMAIER",
    "address_offset": "0x101C",
    "reset_value": "0x0000 0000",
    "content": "The Interrupt enable register enables the interrupts reported by ETH_DMASR. Setting a bit\nto 1 enables a corresponding interrupt. After a hardware or software reset, all interrupts are\nBits 31:17Reserved\nBit 16NISE: Normal interrupt summary enable\nWhen this bit is set, a normal interrupt is enabled. When this bit is cleared, a normal interrupt\nis disabled. This bit enables the following bits:\n–ETH_DMASR [0]: Transmit Interrupt\n–ETH_DMASR [2]: Transmit buffer unavailable\n–ETH_DMASR [6]: Receive interrupt\n–ETH_DMASR [14]: Early receive interrupt\nBit 15AISE: Abnormal interrupt summary enable\nWhen this bit is set, an abnormal interrupt is enabled. When this bit is cleared, an abnormal\ninterrupt is disabled. This bit enables the following bits:\n–ETH_DMASR [1]: Transmit process stopped\n–ETH_DMASR [3]: Transmit jabber timeout\n–ETH_DMASR [4]: Receive overflow\n–ETH_DMASR [5]: Transmit underflow\n–ETH_DMASR [7]: Receive buffer unavailable\n–ETH_DMASR [8]: Receive process stopped\n–ETH_DMASR [9]: Receive watchdog timeout\n–ETH_DMASR [10]: Early transmit interrupt\n–ETH_DMASR [13]: Fatal bus error\nBit 14ERIE: Early receive interrupt enable\nWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]),\nthe early receive interrupt is enabled.\nWhen this bit is cleared, the early receive interrupt is disabled.\nBit 13FBEIE: Fatal bus error interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the fatal bus error interrupt is enabled.\nWhen this bit is cleared, the fatal bus error enable interrupt is disabled.\nBits 12:11Reserved\nBit 10ETIE: Early transmit interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER register\n[15]), the early transmit interrupt is enabled.\nWhen this bit is cleared, the early transmit interrupt is disabled.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9943/995\nThe Ethernet interrupt is generated only when the TSTS or PMTS bits of the DMA Status\nregister is asserted with their corresponding interrupt are unmasked, or when the NIS/AIS\nStatus bit is asserted and the corresponding Interrupt Enable bits (NISE/AISE) are enabled.\nBit 9RWTIE: receive watchdog timeout interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the receive watchdog timeout interrupt is enabled.\nWhen this bit is cleared, the receive watchdog timeout interrupt is disabled.\nBit 8RPSIE: Receive process stopped interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the receive stopped interrupt is enabled. When this bit is cleared, the receive\nstopped interrupt is disabled.\nBit 7RBUIE: Receive buffer unavailable interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the receive buffer unavailable interrupt is enabled.\nWhen this bit is cleared, the receive buffer unavailable interrupt is disabled.\nBit 6RIE: Receive interrupt enable\nWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]),\nthe receive interrupt is enabled.\nWhen this bit is cleared, the receive interrupt is disabled.\nBit 5TUIE: Underflow interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the transmit underflow interrupt is enabled.\nWhen this bit is cleared, the underflow interrupt is disabled.\nBit 4ROIE: Overflow interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the receive overflow interrupt is enabled.\nWhen this bit is cleared, the overflow interrupt is disabled.\nBit 3TJTIE: Transmit jabber timeout interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the transmit jabber timeout interrupt is enabled.\nWhen this bit is cleared, the transmit jabber timeout interrupt is disabled.\nBit 2TBUIE: Transmit buffer unavailable interrupt enable\nWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]),\nthe transmit buffer unavailable interrupt is enabled.\nWhen this bit is cleared, the transmit buffer unavailable interrupt is disabled.\nBit 1TPSIE: Transmit process stopped interrupt enable\nWhen this bit is set with the abnormal interrupt summary enable bit (ETH_DMAIER\nregister[15]), the transmission stopped interrupt is enabled.\nWhen this bit is cleared, the transmission stopped interrupt is disabled.\nBit 0TIE: Transmit interrupt enable\nWhen this bit is set with the normal interrupt summary enable bit (ETH_DMAIER register[16]),\nthe transmit interrupt is enabled.\nWhen this bit is cleared, the transmit interrupt is disabled.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n944/995 Doc ID 13902 Rev 9"
  },
  {
    "start_page": 944,
    "end_page": 944,
    "page_range": "944",
    "section": "",
    "full_name": "Ethernet DMA missed frame and buffer overflow counter register",
    "short_name": "",
    "address_offset": "0x1020",
    "reset_value": "0x0000 0000",
    "content": "The DMA maintains two counters to track the number of missed frames during reception.\nThis register reports the current value of the counter. The counter is used for diagnostic\npurposes. Bits [15:0] indicate missed frames due to the STM32F107xx buffer being\nunavailable (no receive descriptor was available). Bits [27:17] indicate missed frames due to\nRx FIFO overflow conditions and runt frames (good frames of less than 64 bytes)."
  },
  {
    "start_page": 944,
    "end_page": 945,
    "page_range": "944-945",
    "section": "",
    "full_name": "Ethernet DMA current host transmit descriptor register (ETH_DMACHTDR)",
    "short_name": "ETH_DMACHTDR",
    "address_offset": "0x1048",
    "reset_value": "0x0000 0000",
    "content": "The Current host transmit descriptor register points to the start address of the current\ntransmit descriptor read by the DMA.\nBits 31:29Reserved\nBit 28OFOC: Overflow bit for FIFO overflow counter\nBits 27:17MFA: Missed frames by the application\nIndicates the number of frames missed by the application\nBit 16OMFC: Overflow bit for missed frame counter\nBits 15:0MFC: Missed frames by the controller\nIndicates the number of frames missed by the Controller due to the host receive buffer being\nunavailable. This counter is incremented each time the DMA discards an incoming frame.\nBits 31:0HTDAP: Host transmit descriptor address pointer\nCleared on reset. Pointer updated by DMA during operation.\nRM0008Ethernet (ETH): media access control (MAC) with DMA controller\nDoc ID 13902 Rev 9945/995"
  },
  {
    "start_page": 945,
    "end_page": 945,
    "page_range": "945",
    "section": "",
    "full_name": "Ethernet DMA current host receive descriptor register (ETH_DMACHRDR)",
    "short_name": "ETH_DMACHRDR",
    "address_offset": "0x104C",
    "reset_value": "0x0000 0000",
    "content": "The Current host receive descriptor register points to the start address of the current receive\ndescriptor read by the DMA."
  },
  {
    "start_page": 945,
    "end_page": 945,
    "page_range": "945",
    "section": "",
    "full_name": "Ethernet DMA current host transmit buffer address register",
    "short_name": "",
    "address_offset": "0x1050",
    "reset_value": "0x0000 0000",
    "content": "The Current host transmit buffer address register points to the current transmit buffer\naddress being read by the DMA."
  },
  {
    "start_page": 945,
    "end_page": 946,
    "page_range": "945-946",
    "section": "",
    "full_name": "Ethernet DMA current host receive buffer address register",
    "short_name": "",
    "address_offset": "0x1054",
    "reset_value": "0x0000 0000",
    "content": "The current host receive buffer address register points to the current receive buffer address\nbeing read by the DMA.\nBits 31:0HRDAP: Host receive descriptor address pointer\nCleared on Reset. Pointer updated by DMA during operation.\nBits 31:0HTBAP: Host transmit buffer address pointer\nCleared on reset. Pointer updated by DMA during operation.\nBits 31:0HRBAP: Host receive buffer address pointer\nCleared on reset. Pointer updated by DMA during operation.\nEthernet (ETH): media access control (MAC) with DMA controllerRM0008\n946/995 Doc ID 13902 Rev 9"
  }
]